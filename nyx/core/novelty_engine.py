# nyx/core/novelty_engine.py

import logging
import asyncio
import datetime
import random
import uuid
import json
from typing import Dict, List, Any, Optional, Tuple, Set, Union
from pydantic import BaseModel, Field

# OpenAI Agents SDK imports
from agents import (
    Agent, 
    Runner, 
    ModelSettings, 
    trace, 
    function_tool, 
    handoff, 
    RunContextWrapper,
    RunConfig
)

logger = logging.getLogger(__name__)

# Pydantic models for novelty operations
class NoveltyIdea(BaseModel):
    """Schema for a novel idea generated by the novelty engine"""
    id: str = Field(default_factory=lambda: f"idea_{uuid.uuid4().hex[:8]}")
    title: str
    description: str
    source_concepts: List[str] = Field(default_factory=list)
    novelty_score: float = 0.0
    feasibility_score: float = 0.0 
    usefulness_score: float = 0.0
    generation_date: str = Field(default_factory=lambda: datetime.datetime.now().isoformat())
    domain: str = "general"
    technique_used: str
    related_memories: Optional[List[str]] = None

class CreativeTechniqueOutput(BaseModel):
    """Output schema for creative technique applications"""
    idea_title: str
    idea_description: str
    source_concepts: List[str]
    technique_used: str
    rationale: str
    potential_applications: List[str] = Field(default_factory=list)

class IdeaEvaluationOutput(BaseModel):
    """Output schema for idea evaluation"""
    novelty_score: float
    feasibility_score: float
    usefulness_score: float
    strengths: List[str]
    weaknesses: List[str]
    improvement_suggestions: List[str]

class CreativeStimulus(BaseModel):
    """Model for a creative stimulus that can inspire novelty"""
    stimulus_type: str  # e.g., "concept", "memory", "constraint", "perspective"
    content: str
    domain: str
    relevance: float = 1.0

class NoveltyEngineContext:
    """Context object for novelty engine operations"""
    
    def __init__(self, imagination_simulator=None, memory_core=None, reasoning_core=None):
        self.imagination_simulator = imagination_simulator
        self.memory_core = memory_core
        self.reasoning_core = reasoning_core
        
        # Storage for generated ideas
        self.generated_ideas: Dict[str, NoveltyIdea] = {}
        
        # Trace ID for connecting traces
        self.trace_id = f"novelty_engine_{datetime.datetime.now().isoformat()}"
        
        # Creative domains
        self.domains = [
            "technology", "art", "science", "business", 
            "psychology", "philosophy", "social_systems", 
            "entertainment", "education", "environment"
        ]
        
        # Creative techniques registry
        self.techniques = {
            "bisociation": "Connect concepts from different domains",
            "conceptual_blending": "Blend elements from multiple concepts",
            "constraint_relaxation": "Remove or modify constraints",
            "random_stimulus": "Introduce random elements",
            "analogical_reasoning": "Apply patterns from one domain to another",
            "perspective_shifting": "View from unexpected perspectives",
            "provocation": "Use deliberate provocations to challenge thinking",
            "pattern_breaking": "Break established patterns",
            "iteration": "Build and refine ideas iteratively"
        }

class NoveltyEngine:
    """
    System for generating novel ideas and insights using various
    creative techniques integrated with memory and imagination.
    """
    
    def __init__(self, imagination_simulator=None, memory_core=None, reasoning_core=None):
        """Initialize the novelty engine with required components"""
        # Create context
        self.context = NoveltyEngineContext(
            imagination_simulator=imagination_simulator,
            memory_core=memory_core,
            reasoning_core=reasoning_core
        )
        
        # Initialize agent system
        self.novelty_agent = None
        self.initialized = False
    
    async def initialize(self):
        """Initialize the novelty engine and its agents"""
        if self.initialized:
            return
            
        logger.info("Initializing NoveltyEngine")
        
        with trace(workflow_name="NoveltyEngine Initialization", group_id=self.context.trace_id):
            self._initialize_agents()
            self.initialized = True
            logger.info("NoveltyEngine initialized with Agents SDK")
    
    def _initialize_agents(self):
        """Initialize all specialized agents needed for the novelty engine"""
        # Create technique-specific agents
        self.bisociation_agent = self._create_bisociation_agent()
        self.conceptual_blending_agent = self._create_conceptual_blending_agent()
        self.constraint_relaxation_agent = self._create_constraint_relaxation_agent()
        self.random_stimulus_agent = self._create_random_stimulus_agent()
        self.perspective_shifting_agent = self._create_perspective_shifting_agent()
        self.analogical_reasoning_agent = self._create_analogical_reasoning_agent()
        
        # Create evaluation agent
        self.evaluation_agent = self._create_evaluation_agent()
        
        # Create the main novelty agent with handoffs to specialized agents
        self.novelty_agent = self._create_novelty_agent()
        
        logger.info("Novelty engine agents initialized")
    
    # Update the main novelty agent to include handoffs to our new agents
    def _create_novelty_agent(self) -> Agent:
        """Create the main orchestrator agent for novelty generation"""
        return Agent[NoveltyEngineContext](
            name="Novelty Orchestrator",
            instructions="""You are the novelty orchestration system for the Nyx AI.
            
            Your role is to coordinate the generation of novel ideas and insights
            using a variety of creativity techniques and cognitive systems. You analyze 
            the request and determine which specialized creativity agent to use based 
            on the desired output and approach.
            
            You can select from the following creative systems:
            
            CREATIVE TECHNIQUE AGENTS:
            - Bisociation: Connecting concepts from different domains
            - Conceptual Blending: Combining elements from multiple concepts 
            - Constraint Relaxation: Removing or modifying assumptions/constraints
            - Random Stimulus: Introducing unexpected elements
            - Analogical Reasoning: Applying patterns from one domain to another
            - Perspective Shifting: Viewing from unusual perspectives
            
            INTEGRATED COGNITIVE SYSTEM AGENTS:
            - Conceptual Reasoning: Using advanced conceptual spaces and blending
            - Causal Reasoning: Leveraging causal models for systemic understanding
            - Simulation: Running mental simulations of scenarios and outcomes
            
            Choose the most appropriate technique or combination of techniques based
            on the request. For highly innovative ideas with complex implications,
            consider using the integrated cognitive systems which provide deeper
            analysis and more sophisticated idea generation.
            
            Focus on generating ideas that are not just novel, but also potentially
            useful and feasible. The goal is creative insight, not just random combinations.
            """,
            tools=[
                function_tool(self._get_creative_techniques),
                function_tool(self._get_domains)
            ],
            handoffs=[
                # Original technique agents
                handoff(self.bisociation_agent,
                      tool_name_override="generate_by_bisociation",
                      tool_description_override="Generate novel ideas by connecting concepts from different domains"),
                handoff(self.conceptual_blending_agent,
                      tool_name_override="generate_by_conceptual_blending",
                      tool_description_override="Generate novel ideas by blending elements from multiple concepts"),
                handoff(self.constraint_relaxation_agent,
                      tool_name_override="generate_by_constraint_relaxation",
                      tool_description_override="Generate novel ideas by removing or modifying constraints"),
                handoff(self.random_stimulus_agent,
                      tool_name_override="generate_by_random_stimulus",
                      tool_description_override="Generate novel ideas by introducing random elements"),
                handoff(self.perspective_shifting_agent,
                      tool_name_override="generate_by_perspective_shifting",
                      tool_description_override="Generate novel ideas by viewing from unusual perspectives"),
                handoff(self.analogical_reasoning_agent,
                      tool_name_override="generate_by_analogical_reasoning",
                      tool_description_override="Generate novel ideas by applying patterns from one domain to another"),
                
                # New integrated reasoning and imagination agents
                handoff(self.conceptual_reasoning_agent,
                      tool_name_override="generate_by_conceptual_reasoning",
                      tool_description_override="Generate novel ideas using advanced conceptual reasoning and blending"),
                handoff(self.causal_reasoning_agent,
                      tool_name_override="generate_by_causal_reasoning",
                      tool_description_override="Generate novel ideas using causal reasoning and analysis"),
                handoff(self.simulation_agent,
                      tool_name_override="generate_by_simulation",
                      tool_description_override="Generate and refine ideas through imagination simulation"),
                
                # Evaluation agent
                handoff(self.evaluation_agent,
                      tool_name_override="evaluate_idea",
                      tool_description_override="Evaluate the novelty, usefulness, and feasibility of an idea")
            ],
            output_type=NoveltyIdea,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_bisociation_agent(self) -> Agent:
        """Create specialized agent for bisociation technique"""
        return Agent[NoveltyEngineContext](
            name="Bisociation Agent",
            instructions="""You specialize in bisociation, a creativity technique that
            connects concepts from different domains to generate novel ideas.
            
            When given two concepts or domains, your task is to:
            1. Identify key elements and patterns in each domain
            2. Find unexpected connections between them
            3. Generate novel ideas that leverage these connections
            4. Explain how the idea combines elements from both sources
            
            Look for structural similarities, shared principles, or metaphorical
            connections that are not immediately obvious. Your goal is to create
            ideas that are both surprising and potentially useful.
            """,
            tools=[
                function_tool(self._extract_domain_principles),
                function_tool(self._find_connections)
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_conceptual_blending_agent(self) -> Agent:
        """Create specialized agent for conceptual blending technique"""
        return Agent[NoveltyEngineContext](
            name="Conceptual Blending Agent",
            instructions="""You specialize in conceptual blending, a creativity technique
            that combines elements from multiple concepts into new conceptual structures.
            
            When given multiple concepts, your task is to:
            1. Break down each concept into its core elements and relations
            2. Create a blended space by selectively projecting elements
            3. Elaborate the blend through composition, completion, and elaboration
            4. Generate novel ideas based on the emergent structure
            
            Focus on creating blends that have emergent properties not present in
            any of the input concepts. Your goal is to create meaningful new ideas
            that preserve useful elements from each source concept.
            """,
            tools=[
                function_tool(self._decompose_concepts),
                function_tool(self._create_blended_space)
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_constraint_relaxation_agent(self) -> Agent:
        """Create specialized agent for constraint relaxation technique"""
        return Agent[NoveltyEngineContext](
            name="Constraint Relaxation Agent",
            instructions="""You specialize in constraint relaxation, a creativity technique
            that identifies and removes or modifies assumptions and constraints to
            generate novel ideas.
            
            When given a domain or problem, your task is to:
            1. Identify the implicit and explicit constraints
            2. Systematically question and modify these constraints
            3. Explore the possibilities opened up by relaxing constraints
            4. Generate novel ideas that would be impossible under normal constraints
            
            Focus on identifying the most restrictive or unquestioned assumptions.
            Your goal is to create ideas that challenge conventional thinking
            while still potentially offering value.
            """,
            tools=[
                function_tool(self._identify_constraints),
                function_tool(self._explore_constraint_removal)
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.8)
        )
    
    def _create_random_stimulus_agent(self) -> Agent:
        """Create specialized agent for random stimulus technique"""
        return Agent[NoveltyEngineContext](
            name="Random Stimulus Agent",
            instructions="""You specialize in the random stimulus technique, which
            introduces unexpected elements to spark novel ideas.
            
            When given a concept or problem, your task is to:
            1. Generate or select random stimuli unrelated to the problem
            2. Force connections between the random stimuli and the problem
            3. Use these connections to generate unexpected ideas
            4. Refine the most promising ideas into coherent concepts
            
            Embrace unusual or seemingly irrelevant connections. Your goal is to
            break out of conventional thinking patterns by introducing randomness
            in a controlled way.
            """,
            tools=[
                function_tool(self._generate_random_stimuli),
                function_tool(self._force_connections)
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.9)
        )
    
    def _create_perspective_shifting_agent(self) -> Agent:
        """Create specialized agent for perspective shifting technique"""
        return Agent[NoveltyEngineContext](
            name="Perspective Shifting Agent",
            instructions="""You specialize in perspective shifting, a creativity
            technique that approaches problems from unusual or unexpected viewpoints.
            
            When given a concept or problem, your task is to:
            1. Identify a range of unconventional perspectives
            2. Examine the problem from each perspective
            3. Note insights and opportunities unique to each viewpoint
            4. Generate novel ideas based on these alternative perspectives
            
            Consider perspectives from different stakeholders, different scales
            (micro to cosmic), different time frames, or even non-human or fictional
            perspectives. Your goal is to reveal aspects of the problem that are
            invisible from conventional viewpoints.
            """,
            tools=[
                function_tool(self._generate_perspectives),
                function_tool(self._analyze_from_perspective)
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_analogical_reasoning_agent(self) -> Agent:
        """Create specialized agent for analogical reasoning technique"""
        return Agent[NoveltyEngineContext](
            name="Analogical Reasoning Agent",
            instructions="""You specialize in analogical reasoning, a creativity
            technique that applies patterns from one domain to another.
            
            When given a source domain and a target domain, your task is to:
            1. Extract the deep structure and principles from the source domain
            2. Map these principles to the target domain
            3. Extend the mapping to generate novel inferences
            4. Use these inferences to generate innovative ideas
            
            Focus on structural similarities rather than superficial features.
            Your goal is to transfer useful patterns across domains to generate
            insights that wouldn't be obvious within the target domain alone.
            """,
            tools=[
                function_tool(self._extract_domain_structure),
                function_tool(self._map_across_domains)
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_evaluation_agent(self) -> Agent:
        """Create specialized agent for idea evaluation"""
        return Agent[NoveltyEngineContext](
            name="Idea Evaluation Agent",
            instructions="""You specialize in evaluating creative ideas for their
            novelty, usefulness, and feasibility.
            
            When given an idea to evaluate, your task is to:
            1. Assess how novel the idea is compared to existing approaches
            2. Evaluate the potential usefulness and value of the idea
            3. Analyze the feasibility of implementing the idea
            4. Identify strengths and weaknesses
            5. Suggest potential improvements
            
            Provide balanced and constructive evaluation. Your goal is to help
            refine ideas through critical assessment, not just critique them.
            """,
            tools=[
                function_tool(self._assess_novelty),
                function_tool(self._assess_usefulness),
                function_tool(self._assess_feasibility)
            ],
            output_type=IdeaEvaluationOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.3)
        )
    
    # Tool functions for the various agents

    @staticmethod
    @function_tool
    async def _get_creative_techniques(ctx: RunContextWrapper[NoveltyEngineContext]) -> Dict[str, str]:
        """
        Get the list of available creative techniques
        
        Returns:
            Dictionary of technique names and descriptions
        """
        return ctx.context.techniques

    @staticmethod
    @function_tool
    async def _get_domains(ctx: RunContextWrapper[NoveltyEngineContext]) -> List[str]:
        """
        Get the list of creative domains
        
        Returns:
            List of domain names
        """
        return ctx.context.domains

    @staticmethod
    @function_tool
    async def _extract_domain_principles(
        ctx: RunContextWrapper[NoveltyEngineContext],
        domain: str
    ) -> List[Dict[str, str]]:
        """
        Extract key principles from a domain
        
        Args:
            domain: Domain to analyze
            
        Returns:
            List of principles with descriptions
        """
        # In a full implementation, this might call a knowledge base or LLM
        # For now, we'll return some generic principles based on domain
        
        principles = []
        
        if domain == "technology":
            principles = [
                {"name": "Moore's Law", "description": "Computing power doubles approximately every two years"},
                {"name": "Modularity", "description": "Complex systems are built from simpler, interchangeable components"},
                {"name": "Abstraction", "description": "Hide complexity behind simpler interfaces"}
            ]
        elif domain == "biology":
            principles = [
                {"name": "Natural Selection", "description": "Traits that increase survival tend to increase in frequency"},
                {"name": "Homeostasis", "description": "Biological systems maintain internal stability"},
                {"name": "Emergence", "description": "Complex systems exhibit properties not predictable from their components"}
            ]
        else:
            # Generate generic principles
            principles = [
                {"name": f"{domain.capitalize()} Principle 1", "description": f"Key principle in {domain}"},
                {"name": f"{domain.capitalize()} Principle 2", "description": f"Another important principle in {domain}"},
                {"name": f"{domain.capitalize()} Principle 3", "description": f"A fundamental aspect of {domain}"}
            ]
        
        return principles

    @staticmethod
    @function_tool
    async def _find_connections(
        ctx: RunContextWrapper[NoveltyEngineContext],
        domain1_principles: List[Dict[str, str]],
        domain2_principles: List[Dict[str, str]]
    ) -> List[Dict[str, str]]:
        """
        Find potential connections between principles from different domains
        
        Args:
            domain1_principles: Principles from first domain
            domain2_principles: Principles from second domain
            
        Returns:
            List of potential connections
        """
        # In a full implementation, this would use an LLM or similarity calculation
        # For now, we'll return some simple connections
        
        connections = []
        
        for i, principle1 in enumerate(domain1_principles):
            for j, principle2 in enumerate(domain2_principles):
                if i == j:  # Simple matching for demonstration
                    connections.append({
                        "connection": f"Connection between {principle1['name']} and {principle2['name']}",
                        "description": f"Both involve {principle1['description'].split()[0]} and {principle2['description'].split()[0]}"
                    })
        
        return connections

    @staticmethod
    @function_tool
    async def _decompose_concepts(
        ctx: RunContextWrapper[NoveltyEngineContext],
        concepts: List[str]
    ) -> Dict[str, List[str]]:
        """
        Decompose concepts into their core elements
        
        Args:
            concepts: List of concepts to decompose
            
        Returns:
            Dictionary mapping concepts to their elements
        """
        # This would normally use an LLM for detailed analysis
        # Here's a simplified version
        
        decomposed = {}
        
        for concept in concepts:
            # Generate some elements based on the concept
            elements = [
                f"{concept} element 1",
                f"{concept} element 2",
                f"{concept} element 3",
                f"{concept} element 4"
            ]
            decomposed[concept] = elements
        
        return decomposed

    @staticmethod
    @function_tool
    async def _create_blended_space(
        ctx: RunContextWrapper[NoveltyEngineContext],
        concept_elements: Dict[str, List[str]]
    ) -> Dict[str, Any]:
        """
        Create a blended conceptual space from elements
        
        Args:
            concept_elements: Elements of each concept
            
        Returns:
            Blended space description
        """
        # In a full implementation, this would use complex blending operations
        # Simplified version:
        
        all_elements = []
        for concept, elements in concept_elements.items():
            all_elements.extend(elements)
        
        # Select random elements for the blend
        selected_elements = random.sample(all_elements, min(5, len(all_elements)))
        
        blend = {
            "elements": selected_elements,
            "emergent_properties": [
                "Emergent property 1",
                "Emergent property 2"
            ],
            "potential_applications": [
                "Potential application 1",
                "Potential application 2"
            ]
        }
        
        return blend

    @staticmethod
    @function_tool
    async def _identify_constraints(
        ctx: RunContextWrapper[NoveltyEngineContext],
        domain: str
    ) -> List[Dict[str, Any]]:
        """
        Identify implicit and explicit constraints in a domain
        
        Args:
            domain: Domain to analyze
            
        Returns:
            List of constraints
        """
        # This would normally involve detailed domain analysis
        # Simplified version:
        
        constraints = [
            {
                "constraint": f"{domain} constraint 1",
                "type": "explicit",
                "description": f"A common limitation in {domain}",
                "restrictiveness": 0.8
            },
            {
                "constraint": f"{domain} constraint 2",
                "type": "implicit",
                "description": f"An unstated assumption in {domain}",
                "restrictiveness": 0.6
            },
            {
                "constraint": f"{domain} constraint 3",
                "type": "explicit",
                "description": f"A rule generally followed in {domain}",
                "restrictiveness": 0.7
            }
        ]
        
        return constraints

    @staticmethod
    @function_tool
    async def _explore_constraint_removal(
        ctx: RunContextWrapper[NoveltyEngineContext],
        constraints: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """
        Explore possibilities opened by removing constraints
        
        Args:
            constraints: List of constraints to consider removing
            
        Returns:
            List of possibilities
        """
        # In a full implementation, this would explore detailed implications
        # Simplified version:
        
        possibilities = []
        
        for constraint in constraints:
            possibility = {
                "removed_constraint": constraint["constraint"],
                "possibilities": [
                    f"Possibility 1 if {constraint['constraint']} is removed",
                    f"Possibility 2 if {constraint['constraint']} is removed"
                ],
                "potential_benefits": [
                    f"Potential benefit 1",
                    f"Potential benefit 2"
                ],
                "potential_risks": [
                    f"Potential risk 1",
                    f"Potential risk 2"
                ]
            }
            possibilities.append(possibility)
        
        return possibilities

    @staticmethod
    @function_tool
    async def _generate_random_stimuli(
        ctx: RunContextWrapper[NoveltyEngineContext],
        count: int = 3
    ) -> List[str]:
        """
        Generate random stimuli for creative inspiration
        
        Args:
            count: Number of stimuli to generate
            
        Returns:
            List of random stimuli
        """
        # In a full implementation, this might draw from a diverse database
        # Simplified version with some random concepts:
        
        stimuli_options = [
            "butterfly", "skyscraper", "quantum entanglement", "origami",
            "beehive", "symphony", "whirlpool", "mirage", "kaleidoscope",
            "labyrinth", "bioluminescence", "avalanche", "phoenix",
            "fractal", "echo", "nebula", "metamorphosis", "pendulum"
        ]
        
        return random.sample(stimuli_options, min(count, len(stimuli_options)))

    @staticmethod
    @function_tool
    async def _force_connections(
        ctx: RunContextWrapper[NoveltyEngineContext],
        problem: str,
        stimuli: List[str]
    ) -> List[Dict[str, str]]:
        """
        Force connections between a problem and random stimuli
        
        Args:
            problem: Problem to solve
            stimuli: Random stimuli to connect with
            
        Returns:
            List of forced connections
        """
        # In a full implementation, this would use an LLM for creative connections
        # Simplified version:
        
        connections = []
        
        for stimulus in stimuli:
            connection = {
                "stimulus": stimulus,
                "connection": f"Connection between {problem} and {stimulus}",
                "idea": f"What if {problem} used the principle of {stimulus}?"
            }
            connections.append(connection)
        
        return connections

    @staticmethod
    @function_tool
    async def _generate_perspectives(
        ctx: RunContextWrapper[NoveltyEngineContext],
        problem: str
    ) -> List[Dict[str, str]]:
        """
        Generate unusual perspectives for viewing a problem
        
        Args:
            problem: Problem to view from different perspectives
            
        Returns:
            List of perspectives
        """
        # In a full implementation, this would generate tailored perspectives
        # Simplified version:
        
        perspectives = [
            {
                "perspective": "Child's perspective",
                "description": "How would a 5-year-old approach this problem?"
            },
            {
                "perspective": "Future perspective",
                "description": "How would this be solved 100 years from now?"
            },
            {
                "perspective": "Nature's perspective",
                "description": "How would nature solve this problem?"
            },
            {
                "perspective": "Alien perspective",
                "description": "How would an alien civilization approach this?"
            },
            {
                "perspective": "Opposite perspective",
                "description": "What if we wanted the opposite of the usual goal?"
            }
        ]
        
        return perspectives

    @staticmethod
    @function_tool
    async def _analyze_from_perspective(
        ctx: RunContextWrapper[NoveltyEngineContext],
        problem: str,
        perspective: Dict[str, str]
    ) -> Dict[str, Any]:
        """
        Analyze a problem from a specific perspective
        
        Args:
            problem: Problem to analyze
            perspective: Perspective to use
            
        Returns:
            Analysis from that perspective
        """
        # In a full implementation, this would use an LLM for detailed analysis
        # Simplified version:
        
        analysis = {
            "problem": problem,
            "perspective": perspective["perspective"],
            "insights": [
                f"Insight 1 from {perspective['perspective']}",
                f"Insight 2 from {perspective['perspective']}",
                f"Insight 3 from {perspective['perspective']}"
            ],
            "unique_observations": [
                f"Observation 1 from {perspective['perspective']}",
                f"Observation 2 from {perspective['perspective']}"
            ],
            "potential_solutions": [
                f"Solution idea 1 from {perspective['perspective']}",
                f"Solution idea 2 from {perspective['perspective']}"
            ]
        }
        
        return analysis

    @staticmethod
    @function_tool
    async def _extract_domain_structure(
        ctx: RunContextWrapper[NoveltyEngineContext],
        domain: str
    ) -> Dict[str, Any]:
        """
        Extract the deep structure of a domain for analogical reasoning
        
        Args:
            domain: Domain to analyze
            
        Returns:
            Structural elements of the domain
        """
        # In a full implementation, this would perform detailed domain analysis
        # Simplified version:
        
        structure = {
            "domain": domain,
            "entities": [
                f"{domain} entity 1",
                f"{domain} entity 2",
                f"{domain} entity 3"
            ],
            "relationships": [
                {"from": f"{domain} entity 1", "to": f"{domain} entity 2", "type": "influences"},
                {"from": f"{domain} entity 2", "to": f"{domain} entity 3", "type": "contains"},
                {"from": f"{domain} entity 3", "to": f"{domain} entity 1", "type": "transforms"}
            ],
            "processes": [
                f"{domain} process 1",
                f"{domain} process 2"
            ],
            "principles": [
                f"{domain} principle 1",
                f"{domain} principle 2"
            ]
        }
        
        return structure

    @staticmethod
    @function_tool
    async def _map_across_domains(
        ctx: RunContextWrapper[NoveltyEngineContext],
        source_structure: Dict[str, Any],
        target_domain: str
    ) -> Dict[str, Any]:
        """
        Map structures from source domain to target domain
        
        Args:
            source_structure: Structure of source domain
            target_domain: Target domain to map to
            
        Returns:
            Mapping between domains
        """
        # In a full implementation, this would use sophisticated mapping techniques
        # Simplified version:
        
        mapping = {
            "source_domain": source_structure["domain"],
            "target_domain": target_domain,
            "entity_mappings": [
                {"source": entity, "target": f"{target_domain} analogue of {entity}"}
                for entity in source_structure["entities"]
            ],
            "relationship_mappings": [
                {"source_rel": rel, "target_rel": f"{target_domain} equivalent of {rel['type']}"}
                for rel in source_structure["relationships"]
            ],
            "inferences": [
                f"Inference 1 for {target_domain} based on {source_structure['domain']}",
                f"Inference 2 for {target_domain} based on {source_structure['domain']}",
                f"Inference 3 for {target_domain} based on {source_structure['domain']}"
            ],
            "novel_ideas": [
                f"Idea 1 for {target_domain} inspired by {source_structure['domain']}",
                f"Idea 2 for {target_domain} inspired by {source_structure['domain']}"
            ]
        }
        
        return mapping

    @staticmethod
    @function_tool
    async def _assess_novelty(
        ctx: RunContextWrapper[NoveltyEngineContext],
        idea: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Assess the novelty of an idea
        
        Args:
            idea: Idea to assess
            
        Returns:
            Novelty assessment
        """
        # In a full implementation, this would compare against existing ideas
        # Simplified version:
        
        # Random novelty score between 0.4 and 0.9
        novelty_score = round(random.uniform(0.4, 0.9), 2)
        
        assessment = {
            "novelty_score": novelty_score,
            "similar_existing_ideas": [
                "Similar idea 1",
                "Similar idea 2"
            ],
            "differentiating_factors": [
                "Differentiating factor 1",
                "Differentiating factor 2"
            ],
            "originality_aspects": [
                "Original aspect 1",
                "Original aspect 2"
            ]
        }
        
        return assessment

    @staticmethod
    @function_tool
    async def _assess_usefulness(
        ctx: RunContextWrapper[NoveltyEngineContext],
        idea: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Assess the usefulness of an idea
        
        Args:
            idea: Idea to assess
            
        Returns:
            Usefulness assessment
        """
        # In a full implementation, this would analyze potential applications
        # Simplified version:
        
        # Random usefulness score between 0.3 and 0.8
        usefulness_score = round(random.uniform(0.3, 0.8), 2)
        
        assessment = {
            "usefulness_score": usefulness_score,
            "potential_applications": [
                "Application 1",
                "Application 2",
                "Application 3"
            ],
            "potential_benefits": [
                "Benefit 1",
                "Benefit 2"
            ],
            "target_audience": [
                "Audience 1",
                "Audience 2"
            ],
            "value_propositions": [
                "Value proposition 1",
                "Value proposition 2"
            ]
        }
        
        return assessment

    @staticmethod
    @function_tool
    async def _assess_feasibility(
        ctx: RunContextWrapper[NoveltyEngineContext],
        idea: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Assess the feasibility of an idea
        
        Args:
            idea: Idea to assess
            
        Returns:
            Feasibility assessment
        """
        # In a full implementation, this would analyze implementation details
        # Simplified version:
        
        # Random feasibility score between 0.2 and 0.9
        feasibility_score = round(random.uniform(0.2, 0.9), 2)
        
        assessment = {
            "feasibility_score": feasibility_score,
            "implementation_challenges": [
                "Challenge 1",
                "Challenge 2",
                "Challenge 3"
            ],
            "resource_requirements": [
                "Resource 1",
                "Resource 2"
            ],
            "technological_readiness": round(random.uniform(0.1, 1.0), 2),
            "timeline_estimate": f"{random.randint(1, 36)} months"
        }
        
        return assessment
    
    # Main public methods for using the novelty engine
    
    async def generate_novel_idea(
        self,
        technique: str = "auto",
        domain: str = None,
        concepts: List[str] = None,
        constraints: List[str] = None
    ) -> NoveltyIdea:
        """
        Generate a novel idea using specified technique and inputs
        
        Args:
            technique: Creative technique to use (or "auto" to choose)
            domain: Main domain for the idea
            concepts: Concepts to work with
            constraints: Constraints to consider or relax
            
        Returns:
            Generated novel idea
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        # Construct appropriate prompt based on inputs
        prompt = "Generate a novel idea"
        
        if technique and technique != "auto":
            prompt += f" using the {technique} technique"
        
        if domain:
            prompt += f" in the {domain} domain"
        
        if concepts:
            concept_list = ", ".join(concepts)
            prompt += f" involving these concepts: {concept_list}"
        
        if constraints:
            constraint_list = ", ".join(constraints)
            prompt += f" considering these constraints: {constraint_list}"
        
        # Configure run with tracing
        run_config = RunConfig(
            workflow_name="NoveltyEngine Idea Generation",
            group_id=self.context.trace_id,
            trace_metadata={
                "technique": technique,
                "domain": domain,
                "num_concepts": len(concepts) if concepts else 0
            }
        )
        
        # Run through the novelty agent
        with trace(workflow_name="Generate Novel Idea", group_id=self.context.trace_id):
            result = await Runner.run(
                self.novelty_agent,
                prompt,
                context=self.context,
                run_config=run_config
            )
            
            idea = result.final_output
            
            # Store the generated idea
            if idea and isinstance(idea, NoveltyIdea):
                self.context.generated_ideas[idea.id] = idea
            
            return idea
    
    async def evaluate_idea(self, idea_id: str = None, idea_content: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Evaluate an idea for novelty, usefulness, and feasibility
        
        Args:
            idea_id: ID of a previously generated idea
            idea_content: New idea content to evaluate
            
        Returns:
            Evaluation results
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        idea = None
        
        # Get idea by ID or use provided content
        if idea_id and idea_id in self.context.generated_ideas:
            idea = self.context.generated_ideas[idea_id]
        elif idea_content:
            idea = idea_content
        else:
            return {"error": "Must provide either idea_id or idea_content"}
        
        # Convert to str if object
        if not isinstance(idea, (str, dict)):
            idea = idea.dict()
        
        # Run through evaluation agent
        with trace(workflow_name="Evaluate Idea", group_id=self.context.trace_id):
            prompt = f"Evaluate this idea:\n{json.dumps(idea, indent=2)}"
            
            result = await Runner.run(
                self.evaluation_agent,
                prompt,
                context=self.context
            )
            
            return result.final_output
    
    async def integrate_with_memory(
        self,
        query: str,
        idea_generation_technique: str = "auto"
    ) -> Dict[str, Any]:
        """
        Generate ideas inspired by related memories
        
        Args:
            query: Query to find relevant memories
            idea_generation_technique: Technique to use for idea generation
            
        Returns:
            Generated idea with related memories
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        if not self.context.memory_core:
            return {"error": "Memory core not available"}
        
        # Get relevant memories
        with trace(workflow_name="Memory-Inspired Novelty", group_id=self.context.trace_id):
            try:
                # Get memories using memory_core's retrieve_memories if available
                # This assumes a method signature similar to the one in our document
                memories = await self.context.memory_core.retrieve_memories(
                    query=query,
                    memory_types=["observation", "reflection", "abstraction"],
                    limit=5
                )
                
                # Extract concepts from memories
                concepts = []
                memory_ids = []
                
                for memory in memories:
                    memory_text = memory.get("memory_text", "")
                    memory_id = memory.get("id", "")
                    
                    # Very simple concept extraction for demo purposes
                    words = memory_text.split()
                    if len(words) > 5:
                        concepts.append(" ".join(words[:5]))
                    else:
                        concepts.append(memory_text)
                    
                    memory_ids.append(memory_id)
                
                # Generate idea using these concepts
                idea = await self.generate_novel_idea(
                    technique=idea_generation_technique,
                    concepts=concepts
                )
                
                # Add memory references to the idea
                if idea:
                    idea.related_memories = memory_ids
                    self.context.generated_ideas[idea.id] = idea
                
                return {
                    "idea": idea,
                    "inspired_by_memories": memory_ids,
                    "memory_concepts": concepts
                }
                
            except Exception as e:
                logger.error(f"Error integrating with memory: {e}")
                return {"error": f"Error integrating with memory: {e}"}
    
    async def get_generated_ideas(self, limit: int = 10) -> List[NoveltyIdea]:
        """
        Get previously generated ideas
        
        Args:
            limit: Maximum number of ideas to return
            
        Returns:
            List of previously generated ideas
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        # Get ideas in reverse chronological order
        ideas = list(self.context.generated_ideas.values())
        ideas.sort(key=lambda x: x.generation_date, reverse=True)
        
        return ideas[:limit]

    def _create_conceptual_reasoning_agent(self) -> Agent:
        """Create specialized agent that uses conceptual blending from reasoning core"""
        return Agent[NoveltyEngineContext](
            name="Conceptual Reasoning Agent",
            instructions="""You specialize in leveraging NYX's conceptual reasoning system
            to generate novel ideas through sophisticated conceptual blending.
            
            When given concepts or domains to explore, your task is to:
            1. Identify appropriate concept spaces from the reasoning core
            2. Generate conceptual blends and elaborations
            3. Extract novel ideas from these conceptual structures
            4. Explain how the cognitive blending process led to the insight
            
            You build on advanced cognitive science principles of conceptual
            integration and mental space theory to create truly original ideas.
            """,
            tools=[
                function_tool(self._get_concept_spaces),
                function_tool(self._create_conceptual_blend),
                function_tool(self._extract_novel_ideas_from_blend)
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_causal_reasoning_agent(self) -> Agent:
        """Create specialized agent that uses causal reasoning from reasoning core"""
        return Agent[NoveltyEngineContext](
            name="Causal Reasoning Agent",
            instructions="""You specialize in using NYX's causal reasoning system
            to evaluate, refine and generate ideas through causal analysis.
            
            When given an idea or problem domain, your task is to:
            1. Identify relevant causal models from the reasoning core
            2. Analyze causal relationships and potential interventions
            3. Use counterfactual reasoning to explore alternatives
            4. Generate insights based on causal structures
            
            You excel at understanding system dynamics and generating ideas
            that could create targeted ripple effects or interventions.
            """,
            tools=[
                function_tool(self._get_causal_models),
                function_tool(self._analyze_causal_impacts),
                function_tool(self._generate_causal_interventions),
                function_tool(self._reason_counterfactually)
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_simulation_agent(self) -> Agent:
        """Create specialized agent that uses the imagination simulator"""
        return Agent[NoveltyEngineContext](
            name="Simulation Agent",
            instructions="""You specialize in using NYX's imagination simulator
            to explore, refine, and evaluate ideas through mental simulation.
            
            When given an idea to explore, your task is to:
            1. Set up appropriate simulation parameters
            2. Run simulations of the idea's implementation and effects
            3. Extract insights and unexpected implications from simulations
            4. Refine ideas based on simulation outcomes
            
            You excel at mentally "playing out" scenarios to discover
            emergent properties and unexpected consequences that lead to
            creative breakthroughs.
            """,
            tools=[
                function_tool(self._setup_imagination_simulation),
                function_tool(self._run_imagination_simulation),
                function_tool(self._extract_insights_from_simulation),
                function_tool(self._refine_idea_from_simulation)
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.8)
        )
    
    # Now let's add new tool functions for these agents
    
    @staticmethod
    @function_tool
    async def _get_concept_spaces(ctx: RunContextWrapper[NoveltyEngineContext], domain: str = None) -> List[Dict[str, Any]]:
        """
        Get available concept spaces from the reasoning core
        
        Args:
            domain: Optional domain to filter concept spaces
            
        Returns:
            List of available concept spaces
        """
        if not ctx.context.reasoning_core:
            return [{"error": "Reasoning core not available"}]
        
        try:
            # Get all concept spaces
            if domain:
                spaces = [s for s in await ctx.context.reasoning_core.get_all_concept_spaces() 
                         if domain.lower() in s["domain"].lower()]
            else:
                spaces = await ctx.context.reasoning_core.get_all_concept_spaces()
            
            # Return simplified space information
            return [{
                "id": space["id"],
                "name": space["name"],
                "domain": space["domain"],
                "concept_count": len(space.get("concepts", {})),
                "organizing_principles": [p["name"] for p in space.get("organizing_principles", [])]
            } for space in spaces]
        except Exception as e:
            return [{"error": f"Error retrieving concept spaces: {str(e)}"}]
    
    @staticmethod
    @function_tool
    async def _create_conceptual_blend(
        ctx: RunContextWrapper[NoveltyEngineContext],
        space_id1: str,
        space_id2: str,
        blend_type: str = "conceptual_blend"
    ) -> Dict[str, Any]:
        """
        Create a conceptual blend between two concept spaces
        
        Args:
            space_id1: ID of first concept space
            space_id2: ID of second concept space
            blend_type: Type of blend to create (conceptual_blend, contrast, fusion)
            
        Returns:
            Details of the created blend
        """
        if not ctx.context.reasoning_core:
            return {"error": "Reasoning core not available"}
        
        try:
            # First get the concept spaces
            space1 = await ctx.context.reasoning_core.get_concept_space(space_id1)
            space2 = await ctx.context.reasoning_core.get_concept_space(space_id2)
            
            # Create mappings between spaces
            mappings = []
            
            # Find mappings between concepts in the spaces
            for concept1_id, concept1 in space1.get("concepts", {}).items():
                for concept2_id, concept2 in space2.get("concepts", {}).items():
                    # Calculate similarity (simplified)
                    name_similarity = 0
                    if concept1.get("name") and concept2.get("name"):
                        name1 = concept1["name"].lower()
                        name2 = concept2["name"].lower()
                        # Simple word overlap similarity
                        words1 = set(name1.split())
                        words2 = set(name2.split())
                        if words1 or words2:
                            overlap = len(words1.intersection(words2))
                            name_similarity = overlap / max(1, len(words1.union(words2)))
                    
                    # If similarity is above threshold, add mapping
                    if name_similarity > 0.2:
                        mappings.append({
                            "concept1": concept1_id,
                            "concept2": concept2_id,
                            "similarity": name_similarity
                        })
            
            # Choose a blend type based on input and create the blend
            blend_method = None
            if blend_type == "conceptual_blend":
                blend_method = ctx.context.reasoning_core._generate_composition_blend
            elif blend_type == "contrast":
                blend_method = ctx.context.reasoning_core._generate_contrast_blend
            elif blend_type == "fusion":
                blend_method = ctx.context.reasoning_core._generate_fusion_blend
            else:
                # Default to composition
                blend_method = ctx.context.reasoning_core._generate_composition_blend
            
            # Create the blend
            if blend_method:
                blend = await blend_method(space1, space2, mappings)
                return blend
            
            return {"error": "Could not create blend, no suitable method found"}
        except Exception as e:
            return {"error": f"Error creating conceptual blend: {str(e)}"}
    
    @staticmethod
    @function_tool
    async def _extract_novel_ideas_from_blend(
        ctx: RunContextWrapper[NoveltyEngineContext],
        blend_id: str
    ) -> List[Dict[str, Any]]:
        """
        Extract novel ideas from a conceptual blend
        
        Args:
            blend_id: ID of the conceptual blend
            
        Returns:
            List of novel ideas extracted from the blend
        """
        if not ctx.context.reasoning_core:
            return [{"error": "Reasoning core not available"}]
        
        try:
            # Get the blend
            blend = await ctx.context.reasoning_core.get_blend(blend_id)
            
            # Extract ideas from emergent structure
            ideas = []
            
            # First check emergent structures
            for structure in blend.get("emergent_structure", []):
                # Create idea from emergent structure
                idea = {
                    "title": structure.get("name", "Emergent Concept"),
                    "description": structure.get("description", ""),
                    "source_concepts": [blend["concepts"][c]["name"] 
                                       for c in structure.get("concepts", []) 
                                       if c in blend.get("concepts", {})],
                    "novelty_score": 0.8,  # Emergent structures tend to be novel
                    "technique_used": "conceptual_blending"
                }
                ideas.append(idea)
            
            # If no emergent structures, look at the blend concepts themselves
            if not ideas:
                for concept_id, concept in blend.get("concepts", {}).items():
                    # Check if concept has source concepts from both input spaces
                    source_concepts = concept.get("source_concepts", [])
                    space_ids = set(src.get("space_id") for src in source_concepts)
                    
                    # If concept combines elements from multiple spaces, it's potentially novel
                    if len(space_ids) > 1:
                        # Create idea from blend concept
                        idea = {
                            "title": concept.get("name", "Blended Concept"),
                            "description": f"A novel concept combining elements from multiple domains: {', '.join(concept.get('properties', {}).keys())}",
                            "source_concepts": [blend["concepts"][src.get("concept_id")]["name"] 
                                               for src in source_concepts 
                                               if src.get("concept_id") in blend.get("concepts", {})],
                            "novelty_score": 0.7,
                            "technique_used": "conceptual_blending"
                        }
                        ideas.append(idea)
            
            return ideas
        except Exception as e:
            return [{"error": f"Error extracting ideas from blend: {str(e)}"}]
    
    @staticmethod
    @function_tool
    async def _get_causal_models(
        ctx: RunContextWrapper[NoveltyEngineContext],
        domain: str = None
    ) -> List[Dict[str, Any]]:
        """
        Get available causal models from the reasoning core
        
        Args:
            domain: Optional domain to filter causal models
            
        Returns:
            List of available causal models
        """
        if not ctx.context.reasoning_core:
            return [{"error": "Reasoning core not available"}]
        
        try:
            # Get all causal models
            models = await ctx.context.reasoning_core.get_all_causal_models()
            
            # Filter by domain if provided
            if domain:
                models = [m for m in models if domain.lower() in m["domain"].lower()]
            
            # Return simplified model information
            return [{
                "id": model["id"],
                "name": model["name"],
                "domain": model["domain"],
                "node_count": len(model.get("nodes", {})),
                "relation_count": len(model.get("relations", {}))
            } for model in models]
        except Exception as e:
            return [{"error": f"Error retrieving causal models: {str(e)}"}]
    
    @staticmethod
    @function_tool
    async def _analyze_causal_impacts(
        ctx: RunContextWrapper[NoveltyEngineContext],
        model_id: str,
        idea_description: str
    ) -> Dict[str, Any]:
        """
        Analyze the causal impacts of an idea using a causal model
        
        Args:
            model_id: ID of the causal model to use
            idea_description: Description of the idea to analyze
            
        Returns:
            Analysis of potential causal impacts
        """
        if not ctx.context.reasoning_core:
            return {"error": "Reasoning core not available"}
        
        try:
            # Get the causal model
            model = await ctx.context.reasoning_core.get_causal_model(model_id)
            
            # Find most relevant nodes for the idea
            relevant_nodes = []
            for node_id, node in model.get("nodes", {}).items():
                # Simple relevance check using word overlap
                node_name = node.get("name", "").lower()
                description = idea_description.lower()
                
                # Check if node name appears in idea description
                if node_name in description or any(word in description for word in node_name.split()):
                    relevant_nodes.append({
                        "id": node_id,
                        "name": node["name"],
                        "relevance": 0.8 if node_name in description else 0.6
                    })
            
            # If no relevant nodes found, use central nodes in the model
            if not relevant_nodes:
                # Get a few high-degree nodes as central nodes
                node_connections = {}
                for relation in model.get("relations", {}).values():
                    source_id = relation.get("source_id")
                    target_id = relation.get("target_id")
                    
                    if source_id:
                        node_connections[source_id] = node_connections.get(source_id, 0) + 1
                    if target_id:
                        node_connections[target_id] = node_connections.get(target_id, 0) + 1
                
                # Sort nodes by connection count
                sorted_nodes = sorted(node_connections.items(), key=lambda x: x[1], reverse=True)
                
                # Use top 3 nodes
                for node_id, connection_count in sorted_nodes[:3]:
                    if node_id in model.get("nodes", {}):
                        relevant_nodes.append({
                            "id": node_id,
                            "name": model["nodes"][node_id]["name"],
                            "relevance": 0.5
                        })
            
            # For each relevant node, determine potential impacts
            impacts = []
            for node in relevant_nodes:
                node_id = node["id"]
                
                # Get downstream effects (nodes affected by this node)
                downstream = []
                for relation_id, relation in model.get("relations", {}).items():
                    if relation.get("source_id") == node_id:
                        target_id = relation.get("target_id")
                        if target_id in model.get("nodes", {}):
                            downstream.append({
                                "id": target_id,
                                "name": model["nodes"][target_id]["name"],
                                "relation_type": relation.get("type", "causal"),
                                "strength": relation.get("strength", 0.5)
                            })
                
                # Add impact information
                impacts.append({
                    "node": node,
                    "downstream_effects": downstream,
                    "potential_impact": len(downstream) * 0.2  # Simple impact score based on number of effects
                })
            
            return {
                "model_name": model["name"],
                "relevant_nodes": relevant_nodes,
                "causal_impacts": impacts,
                "overall_impact_score": sum(impact["potential_impact"] for impact in impacts)
            }
        except Exception as e:
            return {"error": f"Error analyzing causal impacts: {str(e)}"}
    
    @staticmethod
    @function_tool
    async def _generate_causal_interventions(
        ctx: RunContextWrapper[NoveltyEngineContext],
        model_id: str,
        target_outcome: str
    ) -> List[Dict[str, Any]]:
        """
        Generate potential interventions to achieve a target outcome
        
        Args:
            model_id: ID of the causal model to use
            target_outcome: Description of the desired outcome
            
        Returns:
            List of potential interventions
        """
        if not ctx.context.reasoning_core:
            return [{"error": "Reasoning core not available"}]
        
        try:
            # Get the causal model
            model = await ctx.context.reasoning_core.get_causal_model(model_id)
            
            # Find nodes relevant to the target outcome
            target_nodes = []
            for node_id, node in model.get("nodes", {}).items():
                # Simple relevance check using word overlap
                node_name = node.get("name", "").lower()
                outcome = target_outcome.lower()
                
                # Check if node name appears in target outcome
                if node_name in outcome or any(word in outcome for word in node_name.split()):
                    target_nodes.append({
                        "id": node_id,
                        "name": node["name"],
                        "current_state": node.get("current_state", "unknown")
                    })
            
            # For each target node, find potential intervention points
            interventions = []
            for target in target_nodes:
                # Find nodes that influence the target (directly or indirectly)
                influencers = set()
                stack = [target["id"]]
                visited = set(stack)
                
                while stack:
                    current = stack.pop()
                    
                    # Find nodes that directly influence this node
                    for relation_id, relation in model.get("relations", {}).items():
                        if relation.get("target_id") == current:
                            source_id = relation.get("source_id")
                            if source_id and source_id not in visited:
                                influencers.add(source_id)
                                stack.append(source_id)
                                visited.add(source_id)
                
                # For each influencer, define a potential intervention
                for influencer_id in influencers:
                    if influencer_id in model.get("nodes", {}):
                        influencer = model["nodes"][influencer_id]
                        
                        # Get current state and possible states
                        current_state = influencer.get("current_state", "unknown")
                        possible_states = influencer.get("states", [])
                        
                        # Choose a different state if possible
                        if possible_states and current_state in possible_states:
                            alternative_states = [s for s in possible_states if s != current_state]
                            if alternative_states:
                                target_state = random.choice(alternative_states)
                                
                                # Create intervention
                                interventions.append({
                                    "target_node": {
                                        "id": influencer_id,
                                        "name": influencer["name"]
                                    },
                                    "current_state": current_state,
                                    "intervention_state": target_state,
                                    "description": f"Change {influencer['name']} from {current_state} to {target_state}",
                                    "expected_outcome": f"This should influence {target['name']} toward achieving {target_outcome}"
                                })
            
            return interventions
        except Exception as e:
            return [{"error": f"Error generating causal interventions: {str(e)}"}]
    
    @staticmethod
    @function_tool
    async def _reason_counterfactually(
        ctx: RunContextWrapper[NoveltyEngineContext],
        model_id: str,
        counterfactual_query: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Perform counterfactual reasoning to explore alternative scenarios
        
        Args:
            model_id: ID of the causal model to use
            counterfactual_query: Query specifying the counterfactual scenario
            
        Returns:
            Results of counterfactual reasoning
        """
        if not ctx.context.reasoning_core:
            return {"error": "Reasoning core not available"}
        
        try:
            # Perform counterfactual reasoning using the reasoning core
            result = await ctx.context.reasoning_core.reason_counterfactually(
                model_id=model_id,
                query=counterfactual_query
            )
            
            return result
        except Exception as e:
            return {"error": f"Error performing counterfactual reasoning: {str(e)}"}
    
    @staticmethod
    @function_tool
    async def _setup_imagination_simulation(
        ctx: RunContextWrapper[NoveltyEngineContext],
        idea_description: str,
        current_state: Dict[str, Any] = None,
        domain: str = "general"
    ) -> Dict[str, Any]:
        """
        Set up a simulation for exploring an idea using the imagination simulator
        
        Args:
            idea_description: Description of the idea to simulate
            current_state: Optional current state to start from
            domain: Domain for the simulation
            
        Returns:
            Simulation setup details
        """
        if not ctx.context.imagination_simulator:
            return {"error": "Imagination simulator not available"}
        
        try:
            # Create a default current state if none provided
            if not current_state:
                current_state = {
                    "user_satisfaction": 0.5,
                    "idea_feasibility": 0.5,
                    "idea_novelty": 0.7,
                    "implementation_progress": 0.0
                }
            
            # Set up the simulation using the imagination simulator
            sim_input = await ctx.context.imagination_simulator.setup_simulation(
                description=idea_description,
                current_brain_state=current_state
            )
            
            if sim_input:
                return {
                    "simulation_id": sim_input.simulation_id,
                    "description": sim_input.description,
                    "initial_state": sim_input.initial_state,
                    "domain": sim_input.domain,
                    "max_steps": sim_input.max_steps,
                    "focus_variables": sim_input.focus_variables
                }
            else:
                return {"error": "Failed to set up simulation"}
        except Exception as e:
            return {"error": f"Error setting up imagination simulation: {str(e)}"}
    
    @staticmethod
    @function_tool
    async def _run_imagination_simulation(
        ctx: RunContextWrapper[NoveltyEngineContext],
        simulation_setup: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Run a simulation using the imagination simulator
        
        Args:
            simulation_setup: Setup details for the simulation
            
        Returns:
            Results of the simulation
        """
        if not ctx.context.imagination_simulator:
            return {"error": "Imagination simulator not available"}
        
        try:
            # Convert dict to SimulationInput
            from nyx.core.imagination_simulator import SimulationInput
            
            sim_input = SimulationInput(
                simulation_id=simulation_setup.get("simulation_id", f"sim_{uuid.uuid4().hex[:8]}"),
                description=simulation_setup.get("description", "Idea simulation"),
                initial_state=simulation_setup.get("initial_state", {}),
                hypothetical_event=simulation_setup.get("hypothetical_event"),
                counterfactual_condition=simulation_setup.get("counterfactual_condition"),
                goal_condition=simulation_setup.get("goal_condition"),
                max_steps=simulation_setup.get("max_steps", 10),
                focus_variables=simulation_setup.get("focus_variables", []),
                domain=simulation_setup.get("domain", "general"),
                use_reflection=True
            )
            
            # Run the simulation
            result = await ctx.context.imagination_simulator.run_simulation(sim_input)
            
            # Convert result to dict for return
            if result:
                return {
                    "simulation_id": result.simulation_id,
                    "success": result.success,
                    "termination_reason": result.termination_reason,
                    "steps": len(result.trajectory),
                    "final_state": result.final_state.model_dump() if result.final_state else {},
                    "reflection": result.reflection,
                    "confidence": result.confidence
                }
            else:
                return {"error": "Simulation failed"}
        except Exception as e:
            return {"error": f"Error running imagination simulation: {str(e)}"}
    
    @staticmethod
    @function_tool
    async def _extract_insights_from_simulation(
        ctx: RunContextWrapper[NoveltyEngineContext],
        simulation_result: Dict[str, Any]
    ) -> List[Dict[str, str]]:
        """
        Extract insights and creative ideas from a simulation result
        
        Args:
            simulation_result: Results of an imagination simulation
            
        Returns:
            List of insights extracted from the simulation
        """
        # Extract insights even if simulation fails
        insights = []
        
        # Check for reflection
        if "reflection" in simulation_result and simulation_result["reflection"]:
            insights.append({
                "type": "reflection",
                "content": simulation_result["reflection"]
            })
        
        # Check for causal analysis
        if "causal_analysis" in simulation_result and simulation_result["causal_analysis"]:
            causal = simulation_result["causal_analysis"]
            if "insights" in causal:
                for insight in causal["insights"]:
                    insights.append({
                        "type": "causal_insight",
                        "content": insight
                    })
        
        # Check for emotional impacts
        if "emotional_impact" in simulation_result and simulation_result["emotional_impact"]:
            emotions = simulation_result["emotional_impact"]
            insight_text = "Emotional impact: "
            if "final_emotion" in emotions:
                insight_text += f"Primarily {emotions['final_emotion']}"
            if "emotion_transition" in emotions:
                insight_text += f", transitioning from {emotions['emotion_transition']}"
            
            insights.append({
                "type": "emotional_insight",
                "content": insight_text
            })
        
        # Check for abstraction
        if "abstraction" in simulation_result and simulation_result["abstraction"]:
            abstraction = simulation_result["abstraction"]
            if "abstraction_text" in abstraction:
                insights.append({
                    "type": "abstraction",
                    "content": abstraction["abstraction_text"]
                })
        
        # If no specific insights but we have a final state, create a general insight
        if not insights and "final_state" in simulation_result:
            final_state = simulation_result["final_state"]
            state_vars = final_state.get("state_variables", {})
            
            var_descriptions = []
            for name, value in state_vars.items():
                if isinstance(value, (int, float)):
                    level = "high" if value > 0.7 else "moderate" if value > 0.3 else "low"
                    var_descriptions.append(f"{name}: {level} ({value:.2f})")
                else:
                    var_descriptions.append(f"{name}: {value}")
            
            if var_descriptions:
                insights.append({
                    "type": "state_analysis",
                    "content": f"Final state analysis: {'; '.join(var_descriptions)}"
                })
        
        # If still no insights, add a default insight
        if not insights:
            insights.append({
                "type": "basic_insight",
                "content": f"Simulation {simulation_result.get('simulation_id', 'unknown')} " +
                          f"{'succeeded' if simulation_result.get('success', False) else 'failed'} " +
                          f"due to {simulation_result.get('termination_reason', 'unknown reasons')}."
            })
        
        return insights
    
    @staticmethod
    @function_tool
    async def _refine_idea_from_simulation(
        ctx: RunContextWrapper[NoveltyEngineContext],
        original_idea: Dict[str, Any],
        simulation_result: Dict[str, Any],
        insights: List[Dict[str, str]]
    ) -> Dict[str, Any]:
        """
        Refine an idea based on simulation results and insights
        
        Args:
            original_idea: The original idea
            simulation_result: Results of simulating the idea
            insights: Insights extracted from the simulation
            
        Returns:
            Refined version of the idea
        """
        # Start with a copy of the original idea
        refined_idea = original_idea.copy()
        
        # Add refinements based on simulation outcomes
        refinements = []
        
        # Check simulation success
        if simulation_result.get("success", False):
            refinements.append("Simulation indicates this idea is likely to succeed")
        else:
            termination_reason = simulation_result.get("termination_reason", "unknown")
            if termination_reason == "max_steps":
                refinements.append("Simulation suggests this idea needs more time to fully develop")
            elif termination_reason == "goal_reached":
                refinements.append("Simulation shows this idea achieves its intended goals")
            elif termination_reason == "stable_state":
                refinements.append("Simulation shows this idea reaches a stable equilibrium")
            else:
                refinements.append(f"Simulation terminated due to {termination_reason}")
        
        # Add insights from simulation
        for insight in insights:
            insight_type = insight.get("type", "")
            content = insight.get("content", "")
            
            if "abstraction" in insight_type and content:
                refinements.append(f"Abstraction insight: {content}")
            elif "causal" in insight_type and content:
                refinements.append(f"Causal insight: {content}")
            elif "emotion" in insight_type and content:
                refinements.append(f"Emotional insight: {content}")
            elif content:
                refinements.append(f"Insight: {content}")
        
        # Update idea description with refinements
        original_description = refined_idea.get("description", "")
        refinement_text = "\n\nRefinements based on simulation:\n" + "\n".join([f"- {r}" for r in refinements])
        refined_idea["description"] = original_description + refinement_text
        
        # Adjust novelty and feasibility scores based on simulation
        if "confidence" in simulation_result:
            # Increase feasibility score based on simulation confidence
            refined_idea["feasibility_score"] = min(1.0, refined_idea.get("feasibility_score", 0.5) + 
                                                  simulation_result["confidence"] * 0.2)
        
        # Add a refinement tag to the title
        refined_idea["title"] = f"{refined_idea.get('title', 'Idea')} (Simulation Refined)"
        
        # Note that the idea was refined through simulation
        refined_idea["technique_used"] = f"{refined_idea.get('technique_used', 'unknown')} + imagination_simulation"
        
        return refined_idea
    
    # Update the _initialize_agents method to include our new agents
    def _initialize_agents(self):
        """Initialize all specialized agents needed for the novelty engine"""
        # Create technique-specific agents
        self.bisociation_agent = self._create_bisociation_agent()
        self.conceptual_blending_agent = self._create_conceptual_blending_agent()
        self.constraint_relaxation_agent = self._create_constraint_relaxation_agent()
        self.random_stimulus_agent = self._create_random_stimulus_agent()
        self.perspective_shifting_agent = self._create_perspective_shifting_agent()
        self.analogical_reasoning_agent = self._create_analogical_reasoning_agent()
        
        # Add new integrated reasoning and imagination agents
        self.conceptual_reasoning_agent = self._create_conceptual_reasoning_agent()
        self.causal_reasoning_agent = self._create_causal_reasoning_agent()
        self.simulation_agent = self._create_simulation_agent()
        
        # Create evaluation agent
        self.evaluation_agent = self._create_evaluation_agent()
        
        # Create the main novelty agent with handoffs to specialized agents
        self.novelty_agent = self._create_novelty_agent()
        
        logger.info("Novelty engine agents initialized with reasoning and imagination integration")
    
    
    # Now let's add new public methods to the NoveltyEngine class for external use
    
    async def generate_idea_with_reasoning(
        self,
        technique: str = "conceptual_reasoning",
        domain: str = None,
        concepts: List[str] = None,
        constraints: List[str] = None
    ) -> NoveltyIdea:
        """
        Generate a novel idea using the reasoning core's capabilities
        
        Args:
            technique: Reasoning technique to use (conceptual_reasoning, causal_reasoning)
            domain: Main domain for the idea
            concepts: Concepts to work with
            constraints: Constraints to consider or relax
            
        Returns:
            Generated novel idea
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        # Ensure reasoning core is available
        if not self.context.reasoning_core:
            raise ValueError("Reasoning core not available for idea generation")
        
        # Construct appropriate prompt based on inputs
        prompt = "Generate a novel idea"
        
        if technique:
            prompt += f" using {technique}"
        
        if domain:
            prompt += f" in the {domain} domain"
        
        if concepts:
            concept_list = ", ".join(concepts)
            prompt += f" involving these concepts: {concept_list}"
        
        if constraints:
            constraint_list = ", ".join(constraints)
            prompt += f" considering these constraints: {constraint_list}"
        
        # Configure run with tracing
        run_config = RunConfig(
            workflow_name="NoveltyEngine Reasoning-Based Idea Generation",
            group_id=self.context.trace_id,
            trace_metadata={
                "technique": technique,
                "domain": domain,
                "num_concepts": len(concepts) if concepts else 0
            }
        )
        
        # Run through the appropriate agent based on technique
        with trace(workflow_name="Generate Novel Idea with Reasoning", group_id=self.context.trace_id):
            # Determine which agent to use
            if technique == "conceptual_reasoning":
                agent = self.conceptual_reasoning_agent
            elif technique == "causal_reasoning":
                agent = self.causal_reasoning_agent
            else:
                # Default to main novelty agent
                agent = self.novelty_agent
            
            # Generate the idea
            result = await Runner.run(
                agent,
                prompt,
                context=self.context,
                run_config=run_config
            )
            
            # Convert result to NoveltyIdea if needed
            idea = None
            if isinstance(result.final_output, NoveltyIdea):
                idea = result.final_output
            elif isinstance(result.final_output, dict):
                # Try to create NoveltyIdea from dict
                try:
                    # Extract relevant fields
                    idea_dict = {
                        "id": result.final_output.get("id", f"idea_{uuid.uuid4().hex[:8]}"),
                        "title": result.final_output.get("title", "Generated Idea"),
                        "description": result.final_output.get("description", ""),
                        "source_concepts": result.final_output.get("source_concepts", []),
                        "novelty_score": result.final_output.get("novelty_score", 0.5),
                        "feasibility_score": result.final_output.get("feasibility_score", 0.5),
                        "usefulness_score": result.final_output.get("usefulness_score", 0.5),
                        "generation_date": result.final_output.get("generation_date", datetime.datetime.now().isoformat()),
                        "domain": result.final_output.get("domain", domain or "general"),
                        "technique_used": result.final_output.get("technique_used", technique)
                    }
                    idea = NoveltyIdea(**idea_dict)
                except Exception as e:
                    logger.error(f"Error converting result to NoveltyIdea: {e}")
                    # Create basic idea with result
                    idea = NoveltyIdea(
                        id=f"idea_{uuid.uuid4().hex[:8]}",
                        title="Generated Idea",
                        description=str(result.final_output),
                        source_concepts=[],
                        technique_used=technique
                    )
            else:
                # Create basic idea with result
                idea = NoveltyIdea(
                    id=f"idea_{uuid.uuid4().hex[:8]}",
                    title="Generated Idea",
                    description=str(result.final_output),
                    source_concepts=[],
                    technique_used=technique
                )
            
            # Store the generated idea
            self.context.generated_ideas[idea.id] = idea
            
            return idea
    
    async def simulate_idea(
        self,
        idea_id: str = None,
        idea_content: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Simulate an idea using the imagination simulator
        
        Args:
            idea_id: ID of a previously generated idea
            idea_content: New idea content to simulate
            
        Returns:
            Simulation results with insights
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        # Ensure imagination simulator is available
        if not self.context.imagination_simulator:
            raise ValueError("Imagination simulator not available for idea simulation")
        
        idea = None
        
        # Get idea by ID or use provided content
        if idea_id and idea_id in self.context.generated_ideas:
            idea = self.context.generated_ideas[idea_id]
        elif idea_content:
            idea = idea_content
        else:
            return {"error": "Must provide either idea_id or idea_content"}
        
        # Convert to dict if needed
        if not isinstance(idea, dict):
            idea = idea.dict()
        
        # Run through simulation agent
        with trace(workflow_name="Simulate Idea", group_id=self.context.trace_id):
            prompt = f"Simulate this idea and provide insights:\n{json.dumps(idea, indent=2)}"
            
            result = await Runner.run(
                self.simulation_agent,
                prompt,
                context=self.context
            )
            
            # Process the result
            if hasattr(result.final_output, "model_dump"):
                output = result.final_output.model_dump()
            else:
                output = result.final_output
            
            return {
                "idea": idea,
                "simulation_results": output,
                "insights": output.get("insights", []),
                "refinements": output.get("refinements", [])
            }
    
    async def generate_integrated_idea(
        self,
        description: str,
        domain: str = None,
        use_reasoning: bool = True,
        use_simulation: bool = True
    ) -> NoveltyIdea:
        """
        Generate a novel idea using both reasoning and imagination capabilities
        
        Args:
            description: Description of the idea or problem to solve
            domain: Optional domain for the idea
            use_reasoning: Whether to use reasoning capabilities
            use_simulation: Whether to use imagination simulation
            
        Returns:
            Integrated novel idea
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        # First generate initial idea
        initial_idea = None
        
        if use_reasoning and self.context.reasoning_core:
            # Generate idea using reasoning
            initial_idea = await self.generate_idea_with_reasoning(
                technique="conceptual_reasoning" if random.random() < 0.5 else "causal_reasoning",
                domain=domain,
                concepts=[description]
            )
        else:
            # Generate idea using regular techniques
            techniques = ["bisociation", "conceptual_blending", "random_stimulus", "perspective_shifting"]
            technique = random.choice(techniques)
            
            initial_idea = await self.generate_novel_idea(
                technique=technique,
                domain=domain,
                concepts=[description]
            )
        
        # If no simulation requested or simulator not available, return initial idea
        if not use_simulation or not self.context.imagination_simulator:
            return initial_idea
        
        # Simulate and refine the idea
        simulation_result = await self.simulate_idea(
            idea_id=initial_idea.id if isinstance(initial_idea, NoveltyIdea) else None,
            idea_content=initial_idea if not isinstance(initial_idea, NoveltyIdea) else None
        )
        
        # Check if simulation was successful
        if "error" in simulation_result:
            # Return initial idea if simulation failed
            return initial_idea
        
        # Extract refined idea if available
        if "simulation_results" in simulation_result and isinstance(simulation_result["simulation_results"], dict):
            refined_data = simulation_result["simulation_results"]
            
            if "title" in refined_data and "description" in refined_data:
                # Create refined idea
                refined_idea = NoveltyIdea(
                    id=f"idea_{uuid.uuid4().hex[:8]}",
                    title=refined_data["title"],
                    description=refined_data["description"],
                    source_concepts=refined_data.get("source_concepts", []),
                    novelty_score=refined_data.get("novelty_score", initial_idea.novelty_score if hasattr(initial_idea, "novelty_score") else 0.5),
                    feasibility_score=refined_data.get("feasibility_score", initial_idea.feasibility_score if hasattr(initial_idea, "feasibility_score") else 0.5),
                    usefulness_score=refined_data.get("usefulness_score", initial_idea.usefulness_score if hasattr(initial_idea, "usefulness_score") else 0.5),
                    generation_date=datetime.datetime.now().isoformat(),
                    domain=refined_data.get("domain", domain or "general"),
                    technique_used=f"{initial_idea.technique_used if hasattr(initial_idea, 'technique_used') else 'integrated'}_with_simulation"
                )
                
                # Store the refined idea
                self.context.generated_ideas[refined_idea.id] = refined_idea
                
                return refined_idea
        
        # Return initial idea if refinement failed
        return initial_idea
