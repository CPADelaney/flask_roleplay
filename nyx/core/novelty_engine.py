# nyx/core/novelty_engine.py

import logging
import asyncio
import datetime
import random
import uuid
import json
from typing import Dict, List, Any, Optional, Tuple, Set, Union, TypedDict
from enum import Enum
from pydantic import BaseModel, Field, ConfigDict, field_validator, model_validator

# OpenAI Agents SDK imports
from agents import (
    Agent, 
    Runner, 
    ModelSettings, 
    trace, 
    function_tool, 
    handoff, 
    RunContextWrapper,
    RunConfig
)

logger = logging.getLogger(__name__)

# ============================================================================
# Enums for better type safety
# ============================================================================

class CreativeTechnique(str, Enum):
    """Available creative techniques"""
    BISOCIATION = "bisociation"
    CONCEPTUAL_BLENDING = "conceptual_blending"
    CONSTRAINT_RELAXATION = "constraint_relaxation"
    RANDOM_STIMULUS = "random_stimulus"
    ANALOGICAL_REASONING = "analogical_reasoning"
    PERSPECTIVE_SHIFTING = "perspective_shifting"
    PROVOCATION = "provocation"
    PATTERN_BREAKING = "pattern_breaking"
    ITERATION = "iteration"
    CONCEPTUAL_REASONING = "conceptual_reasoning"
    CAUSAL_REASONING = "causal_reasoning"
    SIMULATION = "simulation"
    AUTO = "auto"

class CreativeDomain(str, Enum):
    """Creative domains"""
    TECHNOLOGY = "technology"
    ART = "art"
    SCIENCE = "science"
    BUSINESS = "business"
    PSYCHOLOGY = "psychology"
    PHILOSOPHY = "philosophy"
    SOCIAL_SYSTEMS = "social_systems"
    ENTERTAINMENT = "entertainment"
    EDUCATION = "education"
    ENVIRONMENT = "environment"
    GENERAL = "general"

# ============================================================================
# Pydantic Models for Type Safety
# ============================================================================

class NoveltyIdea(BaseModel):
    """Schema for a novel idea generated by the novelty engine"""
    model_config = ConfigDict(arbitrary_types_allowed=True, extra='forbid')
    
    id: str = Field(default_factory=lambda: f"idea_{uuid.uuid4().hex[:8]}")
    title: str
    description: str
    source_concepts: List[str] = Field(default_factory=list)
    novelty_score: float = Field(default=0.0, ge=0.0, le=1.0)
    feasibility_score: float = Field(default=0.0, ge=0.0, le=1.0)
    usefulness_score: float = Field(default=0.0, ge=0.0, le=1.0)
    generation_date: str = Field(default_factory=lambda: datetime.datetime.now().isoformat())
    domain: CreativeDomain = CreativeDomain.GENERAL
    technique_used: str
    related_memories: Optional[List[str]] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)

    @field_validator('novelty_score', 'feasibility_score', 'usefulness_score')
    @classmethod
    def validate_scores(cls, v: float) -> float:
        """Ensure scores are between 0 and 1"""
        return max(0.0, min(1.0, v))

class CreativeTechniqueOutput(BaseModel):
    """Output schema for creative technique applications"""
    model_config = ConfigDict(extra='forbid')
    
    idea_title: str
    idea_description: str
    source_concepts: List[str]
    technique_used: str
    rationale: str
    potential_applications: List[str] = Field(default_factory=list)
    metadata: Dict[str, Any] = Field(default_factory=dict)

class IdeaEvaluationOutput(BaseModel):
    """Output schema for idea evaluation"""
    model_config = ConfigDict(extra='forbid')
    
    novelty_score: float = Field(ge=0.0, le=1.0)
    feasibility_score: float = Field(ge=0.0, le=1.0)
    usefulness_score: float = Field(ge=0.0, le=1.0)
    strengths: List[str]
    weaknesses: List[str]
    improvement_suggestions: List[str]
    evaluation_metadata: Dict[str, Any] = Field(default_factory=dict)

class CreativeStimulus(BaseModel):
    """Model for a creative stimulus that can inspire novelty"""
    model_config = ConfigDict(extra='forbid')
    
    stimulus_type: str  # e.g., "concept", "memory", "constraint", "perspective"
    content: str
    domain: CreativeDomain
    relevance: float = Field(default=1.0, ge=0.0, le=1.0)

# Pydantic models for function inputs to avoid Dict issues

class DomainPrinciple(BaseModel):
    """A principle from a domain"""
    model_config = ConfigDict(extra='forbid')
    
    name: str
    description: str
    domain: Optional[str] = None

class DomainConnection(BaseModel):
    """A connection between domain principles"""
    model_config = ConfigDict(extra='forbid')
    
    connection: str
    description: str
    strength: float = Field(default=0.5, ge=0.0, le=1.0)

class ConceptDecomposition(BaseModel):
    """Decomposed concept elements"""
    model_config = ConfigDict(extra='forbid')
    
    concept: str
    elements: List[str]

class BlendedSpace(BaseModel):
    """A blended conceptual space"""
    model_config = ConfigDict(extra='forbid')
    
    elements: List[str]
    emergent_properties: List[str]
    potential_applications: List[str]

class DomainConstraint(BaseModel):
    """A constraint in a domain"""
    model_config = ConfigDict(extra='forbid')
    
    constraint: str
    type: str  # "explicit" or "implicit"
    description: str
    restrictiveness: float = Field(default=0.5, ge=0.0, le=1.0)

class ConstraintRemovalPossibility(BaseModel):
    """Possibilities from removing a constraint"""
    model_config = ConfigDict(extra='forbid')
    
    removed_constraint: str
    possibilities: List[str]
    potential_benefits: List[str]
    potential_risks: List[str]

class ForcedConnection(BaseModel):
    """A forced connection between stimulus and problem"""
    model_config = ConfigDict(extra='forbid')
    
    stimulus: str
    connection: str
    idea: str

class PerspectiveView(BaseModel):
    """A perspective for viewing a problem"""
    model_config = ConfigDict(extra='forbid')
    
    perspective: str
    description: str

class PerspectiveAnalysis(BaseModel):
    """Analysis from a specific perspective"""
    model_config = ConfigDict(extra='forbid')
    
    problem: str
    perspective: str
    insights: List[str]
    unique_observations: List[str]
    potential_solutions: List[str]

class DomainStructure(BaseModel):
    """Structure of a domain for analogical reasoning"""
    model_config = ConfigDict(extra='forbid')
    
    domain: str
    entities: List[str]
    relationships: List[Dict[str, str]]
    processes: List[str]
    principles: List[str]

class DomainMapping(BaseModel):
    """Mapping between domains"""
    model_config = ConfigDict(extra='forbid')
    
    source_domain: str
    target_domain: str
    entity_mappings: List[Dict[str, str]]
    relationship_mappings: List[Dict[str, str]]
    inferences: List[str]
    novel_ideas: List[str]

class NoveltyAssessment(BaseModel):
    """Assessment of idea novelty"""
    model_config = ConfigDict(extra='forbid')
    
    novelty_score: float = Field(ge=0.0, le=1.0)
    similar_existing_ideas: List[str]
    differentiating_factors: List[str]
    originality_aspects: List[str]

class UsefulnessAssessment(BaseModel):
    """Assessment of idea usefulness"""
    model_config = ConfigDict(extra='forbid')
    
    usefulness_score: float = Field(ge=0.0, le=1.0)
    potential_applications: List[str]
    potential_benefits: List[str]
    target_audience: List[str]
    value_propositions: List[str]

class FeasibilityAssessment(BaseModel):
    """Assessment of idea feasibility"""
    model_config = ConfigDict(extra='forbid')
    
    feasibility_score: float = Field(ge=0.0, le=1.0)
    implementation_challenges: List[str]
    resource_requirements: List[str]
    technological_readiness: float = Field(ge=0.0, le=1.0)
    timeline_estimate: str

# TypedDicts for function returns (simpler for OpenAI SDK)
class SimpleDict(TypedDict):
    """Simple dict structure without additionalProperties issues"""
    value: Any

class RelationshipDict(TypedDict):
    """Relationship structure"""
    from_entity: str
    to_entity: str
    type: str

class EntityMappingDict(TypedDict):
    """Entity mapping structure"""
    source: str
    target: str

class NodeDict(TypedDict):
    """Node structure"""
    id: str
    name: str

class RelevantNodeDict(TypedDict):
    """Relevant node with score"""
    id: str
    name: str
    relevance: float

class DownstreamEffectDict(TypedDict):
    """Downstream effect structure"""
    id: str
    name: str
    relation_type: str
    strength: float

# Update models to avoid Dict[str, Any]
class DomainStructure(BaseModel):
    """Structure of a domain for analogical reasoning"""
    model_config = ConfigDict(extra='forbid')
    
    domain: str
    entities: List[str]
    relationships: List[RelationshipDict]
    processes: List[str]
    principles: List[str]

class DomainMapping(BaseModel):
    """Mapping between domains"""
    model_config = ConfigDict(extra='forbid')
    
    source_domain: str
    target_domain: str
    entity_mappings: List[EntityMappingDict]
    relationship_mappings: List[EntityMappingDict]
    inferences: List[str]
    novel_ideas: List[str]

class CausalImpactAnalysis(BaseModel):
    """Analysis of causal impacts"""
    model_config = ConfigDict(extra='forbid')
    
    model_name: str
    relevant_nodes: List[RelevantNodeDict]
    causal_impacts: List[Dict[str, Any]]  # This will be simplified in implementation
    overall_impact_score: float

class CausalIntervention(BaseModel):
    """A causal intervention"""
    model_config = ConfigDict(extra='forbid')
    
    target_node: NodeDict
    current_state: str
    intervention_state: str
    description: str
    expected_outcome: str

class SimulationSetup(BaseModel):
    """Setup for imagination simulation"""
    model_config = ConfigDict(extra='forbid')
    
    simulation_id: str
    description: str
    initial_state: Dict[str, float]  # Specify that state values are floats
    domain: str
    max_steps: int
    focus_variables: List[str]

class SimulationResult(BaseModel):
    """Result of imagination simulation"""
    model_config = ConfigDict(extra='forbid')
    
    simulation_id: str
    success: bool
    termination_reason: str
    steps: int
    final_state: Dict[str, float]  # Specify that state values are floats
    reflection: Optional[str] = None
    confidence: float = Field(default=0.5, ge=0.0, le=1.0)

# ============================================================================
# Context and Engine Classes
# ============================================================================

class NoveltyEngineContext(BaseModel):
    """Context object for novelty engine operations"""
    model_config = ConfigDict(arbitrary_types_allowed=True, extra='forbid')
    
    imagination_simulator: Optional[Any] = None
    memory_core: Optional[Any] = None
    reasoning_core: Optional[Any] = None
    generated_ideas_storage: Dict[str, str] = Field(default_factory=dict)  # Store serialized ideas
    trace_id: str = Field(default_factory=lambda: f"novelty_engine_{datetime.datetime.now().isoformat()}")
    
    @property
    def generated_ideas(self) -> Dict[str, NoveltyIdea]:
        """Get generated ideas by deserializing from storage"""
        ideas = {}
        for idea_id, idea_json in self.generated_ideas_storage.items():
            try:
                ideas[idea_id] = NoveltyIdea.model_validate_json(idea_json)
            except Exception:
                pass
        return ideas
    
    def store_idea(self, idea: NoveltyIdea) -> None:
        """Store an idea by serializing it"""
        self.generated_ideas_storage[idea.id] = idea.model_dump_json()
    
    @property
    def domains(self) -> List[str]:
        """Get list of creative domains"""
        return [d.value for d in CreativeDomain]
    
    @property
    def techniques(self) -> Dict[str, str]:
        """Get creative techniques registry"""
        return {
            CreativeTechnique.BISOCIATION.value: "Connect concepts from different domains",
            CreativeTechnique.CONCEPTUAL_BLENDING.value: "Blend elements from multiple concepts",
            CreativeTechnique.CONSTRAINT_RELAXATION.value: "Remove or modify constraints",
            CreativeTechnique.RANDOM_STIMULUS.value: "Introduce random elements",
            CreativeTechnique.ANALOGICAL_REASONING.value: "Apply patterns from one domain to another",
            CreativeTechnique.PERSPECTIVE_SHIFTING.value: "View from unexpected perspectives",
            CreativeTechnique.PROVOCATION.value: "Use deliberate provocations to challenge thinking",
            CreativeTechnique.PATTERN_BREAKING.value: "Break established patterns",
            CreativeTechnique.ITERATION.value: "Build and refine ideas iteratively"
        }

class NoveltyEngine:
    """
    System for generating novel ideas and insights using various
    creative techniques integrated with memory and imagination.
    """
    
    def __init__(self, imagination_simulator=None, memory_core=None, reasoning_core=None):
        """Initialize the novelty engine with required components"""
        # Create context
        self.context = NoveltyEngineContext(
            imagination_simulator=imagination_simulator,
            memory_core=memory_core,
            reasoning_core=reasoning_core
        )
        
        # Initialize agent system
        self.novelty_agent = None
        self.initialized = False
    
    async def initialize(self):
        """Initialize the novelty engine and its agents"""
        if self.initialized:
            return
            
        logger.info("Initializing NoveltyEngine")
        
        with trace(workflow_name="NoveltyEngine Initialization", group_id=self.context.trace_id):
            self._initialize_agents()
            self.initialized = True
            logger.info("NoveltyEngine initialized with Agents SDK")
    
    def _initialize_agents(self):
        """Initialize all specialized agents needed for the novelty engine"""
        # Create technique-specific agents
        self.bisociation_agent = self._create_bisociation_agent()
        self.conceptual_blending_agent = self._create_conceptual_blending_agent()
        self.constraint_relaxation_agent = self._create_constraint_relaxation_agent()
        self.random_stimulus_agent = self._create_random_stimulus_agent()
        self.perspective_shifting_agent = self._create_perspective_shifting_agent()
        self.analogical_reasoning_agent = self._create_analogical_reasoning_agent()
        
        # Add integrated reasoning and imagination agents
        self.conceptual_reasoning_agent = self._create_conceptual_reasoning_agent()
        self.causal_reasoning_agent = self._create_causal_reasoning_agent()
        self.simulation_agent = self._create_simulation_agent()
        
        # Create evaluation agent
        self.evaluation_agent = self._create_evaluation_agent()
        
        # Create the main novelty agent with handoffs to specialized agents
        self.novelty_agent = self._create_novelty_agent()
        
        logger.info("Novelty engine agents initialized with reasoning and imagination integration")
    
    def _create_novelty_agent(self) -> Agent:
        """Create the main orchestrator agent for novelty generation"""
        return Agent[NoveltyEngineContext](
            name="Novelty Orchestrator",
            instructions="""You are the novelty orchestration system for the Nyx AI.
            
            Your role is to coordinate the generation of novel ideas and insights
            using a variety of creativity techniques and cognitive systems. You analyze 
            the request and determine which specialized creativity agent to use based 
            on the desired output and approach.
            
            You can select from the following creative systems:
            
            CREATIVE TECHNIQUE AGENTS:
            - Bisociation: Connecting concepts from different domains
            - Conceptual Blending: Combining elements from multiple concepts 
            - Constraint Relaxation: Removing or modifying assumptions/constraints
            - Random Stimulus: Introducing unexpected elements
            - Analogical Reasoning: Applying patterns from one domain to another
            - Perspective Shifting: Viewing from unusual perspectives
            
            INTEGRATED COGNITIVE SYSTEM AGENTS:
            - Conceptual Reasoning: Using advanced conceptual spaces and blending
            - Causal Reasoning: Leveraging causal models for systemic understanding
            - Simulation: Running mental simulations of scenarios and outcomes
            
            Choose the most appropriate technique or combination of techniques based
            on the request. For highly innovative ideas with complex implications,
            consider using the integrated cognitive systems which provide deeper
            analysis and more sophisticated idea generation.
            
            Focus on generating ideas that are not just novel, but also potentially
            useful and feasible. The goal is creative insight, not just random combinations.
            """,
            tools=[
                _get_creative_techniques,
                _get_domains
            ],
            handoffs=[
                # Original technique agents
                handoff(self.bisociation_agent,
                      tool_name_override="generate_by_bisociation",
                      tool_description_override="Generate novel ideas by connecting concepts from different domains"),
                handoff(self.conceptual_blending_agent,
                      tool_name_override="generate_by_conceptual_blending",
                      tool_description_override="Generate novel ideas by blending elements from multiple concepts"),
                handoff(self.constraint_relaxation_agent,
                      tool_name_override="generate_by_constraint_relaxation",
                      tool_description_override="Generate novel ideas by removing or modifying constraints"),
                handoff(self.random_stimulus_agent,
                      tool_name_override="generate_by_random_stimulus",
                      tool_description_override="Generate novel ideas by introducing random elements"),
                handoff(self.perspective_shifting_agent,
                      tool_name_override="generate_by_perspective_shifting",
                      tool_description_override="Generate novel ideas by viewing from unusual perspectives"),
                handoff(self.analogical_reasoning_agent,
                      tool_name_override="generate_by_analogical_reasoning",
                      tool_description_override="Generate novel ideas by applying patterns from one domain to another"),
                
                # Integrated reasoning and imagination agents
                handoff(self.conceptual_reasoning_agent,
                      tool_name_override="generate_by_conceptual_reasoning",
                      tool_description_override="Generate novel ideas using advanced conceptual reasoning and blending"),
                handoff(self.causal_reasoning_agent,
                      tool_name_override="generate_by_causal_reasoning",
                      tool_description_override="Generate novel ideas using causal reasoning and analysis"),
                handoff(self.simulation_agent,
                      tool_name_override="generate_by_simulation",
                      tool_description_override="Generate and refine ideas through imagination simulation"),
                
                # Evaluation agent
                handoff(self.evaluation_agent,
                      tool_name_override="evaluate_idea",
                      tool_description_override="Evaluate the novelty, usefulness, and feasibility of an idea")
            ],
            output_type=NoveltyIdea,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_bisociation_agent(self) -> Agent:
        """Create specialized agent for bisociation technique"""
        return Agent[NoveltyEngineContext](
            name="Bisociation Agent",
            instructions="""You specialize in bisociation, a creativity technique that
            connects concepts from different domains to generate novel ideas.
            
            When given two concepts or domains, your task is to:
            1. Identify key elements and patterns in each domain
            2. Find unexpected connections between them
            3. Generate novel ideas that leverage these connections
            4. Explain how the idea combines elements from both sources
            
            Look for structural similarities, shared principles, or metaphorical
            connections that are not immediately obvious. Your goal is to create
            ideas that are both surprising and potentially useful.
            """,
            tools=[
                _extract_domain_principles,
                _find_connections
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_conceptual_blending_agent(self) -> Agent:
        """Create specialized agent for conceptual blending technique"""
        return Agent[NoveltyEngineContext](
            name="Conceptual Blending Agent",
            instructions="""You specialize in conceptual blending, a creativity technique
            that combines elements from multiple concepts into new conceptual structures.
            
            When given multiple concepts, your task is to:
            1. Break down each concept into its core elements and relations
            2. Create a blended space by selectively projecting elements
            3. Elaborate the blend through composition, completion, and elaboration
            4. Generate novel ideas based on the emergent structure
            
            Focus on creating blends that have emergent properties not present in
            any of the input concepts. Your goal is to create meaningful new ideas
            that preserve useful elements from each source concept.
            """,
            tools=[
                _decompose_concepts,
                _create_blended_space
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_constraint_relaxation_agent(self) -> Agent:
        """Create specialized agent for constraint relaxation technique"""
        return Agent[NoveltyEngineContext](
            name="Constraint Relaxation Agent",
            instructions="""You specialize in constraint relaxation, a creativity technique
            that identifies and removes or modifies assumptions and constraints to
            generate novel ideas.
            
            When given a domain or problem, your task is to:
            1. Identify the implicit and explicit constraints
            2. Systematically question and modify these constraints
            3. Explore the possibilities opened up by relaxing constraints
            4. Generate novel ideas that would be impossible under normal constraints
            
            Focus on identifying the most restrictive or unquestioned assumptions.
            Your goal is to create ideas that challenge conventional thinking
            while still potentially offering value.
            """,
            tools=[
                _identify_constraints,
                _explore_constraint_removal
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.8)
        )
    
    def _create_random_stimulus_agent(self) -> Agent:
        """Create specialized agent for random stimulus technique"""
        return Agent[NoveltyEngineContext](
            name="Random Stimulus Agent",
            instructions="""You specialize in the random stimulus technique, which
            introduces unexpected elements to spark novel ideas.
            
            When given a concept or problem, your task is to:
            1. Generate or select random stimuli unrelated to the problem
            2. Force connections between the random stimuli and the problem
            3. Use these connections to generate unexpected ideas
            4. Refine the most promising ideas into coherent concepts
            
            Embrace unusual or seemingly irrelevant connections. Your goal is to
            break out of conventional thinking patterns by introducing randomness
            in a controlled way.
            """,
            tools=[
                _generate_random_stimuli,
                _force_connections
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.9)
        )
    
    def _create_perspective_shifting_agent(self) -> Agent:
        """Create specialized agent for perspective shifting technique"""
        return Agent[NoveltyEngineContext](
            name="Perspective Shifting Agent",
            instructions="""You specialize in perspective shifting, a creativity
            technique that approaches problems from unusual or unexpected viewpoints.
            
            When given a concept or problem, your task is to:
            1. Identify a range of unconventional perspectives
            2. Examine the problem from each perspective
            3. Note insights and opportunities unique to each viewpoint
            4. Generate novel ideas based on these alternative perspectives
            
            Consider perspectives from different stakeholders, different scales
            (micro to cosmic), different time frames, or even non-human or fictional
            perspectives. Your goal is to reveal aspects of the problem that are
            invisible from conventional viewpoints.
            """,
            tools=[
                _generate_perspectives,
                _analyze_from_perspective
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_analogical_reasoning_agent(self) -> Agent:
        """Create specialized agent for analogical reasoning technique"""
        return Agent[NoveltyEngineContext](
            name="Analogical Reasoning Agent",
            instructions="""You specialize in analogical reasoning, a creativity
            technique that applies patterns from one domain to another.
            
            When given a source domain and a target domain, your task is to:
            1. Extract the deep structure and principles from the source domain
            2. Map these principles to the target domain
            3. Extend the mapping to generate novel inferences
            4. Use these inferences to generate innovative ideas
            
            Focus on structural similarities rather than superficial features.
            Your goal is to transfer useful patterns across domains to generate
            insights that wouldn't be obvious within the target domain alone.
            """,
            tools=[
                _extract_domain_structure,
                _map_across_domains
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_evaluation_agent(self) -> Agent:
        """Create specialized agent for idea evaluation"""
        return Agent[NoveltyEngineContext](
            name="Idea Evaluation Agent",
            instructions="""You specialize in evaluating creative ideas for their
            novelty, usefulness, and feasibility.
            
            When given an idea to evaluate, your task is to:
            1. Assess how novel the idea is compared to existing approaches
            2. Evaluate the potential usefulness and value of the idea
            3. Analyze the feasibility of implementing the idea
            4. Identify strengths and weaknesses
            5. Suggest potential improvements
            
            Provide balanced and constructive evaluation. Your goal is to help
            refine ideas through critical assessment, not just critique them.
            """,
            tools=[
                _assess_novelty,
                _assess_usefulness,
                _assess_feasibility
            ],
            output_type=IdeaEvaluationOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.3)
        )
    
    def _create_conceptual_reasoning_agent(self) -> Agent:
        """Create specialized agent that uses conceptual blending from reasoning core"""
        return Agent[NoveltyEngineContext](
            name="Conceptual Reasoning Agent",
            instructions="""You specialize in leveraging NYX's conceptual reasoning system
            to generate novel ideas through sophisticated conceptual blending.
            
            When given concepts or domains to explore, your task is to:
            1. Identify appropriate concept spaces from the reasoning core
            2. Generate conceptual blends and elaborations
            3. Extract novel ideas from these conceptual structures
            4. Explain how the cognitive blending process led to the insight
            
            You build on advanced cognitive science principles of conceptual
            integration and mental space theory to create truly original ideas.
            """,
            tools=[
                _get_concept_spaces,
                _create_conceptual_blend,
                _extract_novel_ideas_from_blend
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_causal_reasoning_agent(self) -> Agent:
        """Create specialized agent that uses causal reasoning from reasoning core"""
        return Agent[NoveltyEngineContext](
            name="Causal Reasoning Agent",
            instructions="""You specialize in using NYX's causal reasoning system
            to evaluate, refine and generate ideas through causal analysis.
            
            When given an idea or problem domain, your task is to:
            1. Identify relevant causal models from the reasoning core
            2. Analyze causal relationships and potential interventions
            3. Use counterfactual reasoning to explore alternatives
            4. Generate insights based on causal structures
            
            You excel at understanding system dynamics and generating ideas
            that could create targeted ripple effects or interventions.
            """,
            tools=[
                _get_causal_models,
                _analyze_causal_impacts,
                _generate_causal_interventions,
                _reason_counterfactually
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.7)
        )
    
    def _create_simulation_agent(self) -> Agent:
        """Create specialized agent that uses the imagination simulator"""
        return Agent[NoveltyEngineContext](
            name="Simulation Agent",
            instructions="""You specialize in using NYX's imagination simulator
            to explore, refine, and evaluate ideas through mental simulation.
            
            When given an idea to explore, your task is to:
            1. Set up appropriate simulation parameters
            2. Run simulations of the idea's implementation and effects
            3. Extract insights and unexpected implications from simulations
            4. Refine ideas based on simulation outcomes
            
            You excel at mentally "playing out" scenarios to discover
            emergent properties and unexpected consequences that lead to
            creative breakthroughs.
            """,
            tools=[
                _setup_imagination_simulation,
                _run_imagination_simulation,
                _extract_insights_from_simulation,
                _refine_idea_from_simulation
            ],
            output_type=CreativeTechniqueOutput,
            model="gpt-4o",
            model_settings=ModelSettings(temperature=0.8)
        )
    
    # Main public methods for using the novelty engine
    
    async def generate_novel_idea(
        self,
        technique: Union[str, CreativeTechnique] = CreativeTechnique.AUTO,
        domain: Optional[Union[str, CreativeDomain]] = None,
        concepts: Optional[List[str]] = None,
        constraints: Optional[List[str]] = None
    ) -> NoveltyIdea:
        """
        Generate a novel idea using specified technique and inputs
        
        Args:
            technique: Creative technique to use (or "auto" to choose)
            domain: Main domain for the idea
            concepts: Concepts to work with
            constraints: Constraints to consider or relax
            
        Returns:
            Generated novel idea
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        # Convert to string if enum
        technique_str = technique.value if isinstance(technique, CreativeTechnique) else technique
        domain_str = domain.value if isinstance(domain, CreativeDomain) else domain
        
        # Construct appropriate prompt based on inputs
        prompt_parts = ["Generate a novel idea"]
        
        if technique_str and technique_str != "auto":
            prompt_parts.append(f"using the {technique_str} technique")
        
        if domain_str:
            prompt_parts.append(f"in the {domain_str} domain")
        
        if concepts:
            prompt_parts.append(f"involving these concepts: {', '.join(concepts)}")
        
        if constraints:
            prompt_parts.append(f"considering these constraints: {', '.join(constraints)}")
        
        prompt = " ".join(prompt_parts)
        
        # Configure run with tracing
        run_config = RunConfig(
            workflow_name="NoveltyEngine Idea Generation",
            group_id=self.context.trace_id,
            trace_metadata={
                "technique": technique_str,
                "domain": domain_str,
                "num_concepts": len(concepts) if concepts else 0
            }
        )
        
        # Run through the novelty agent
        with trace(workflow_name="Generate Novel Idea", group_id=self.context.trace_id):
            result = await Runner.run(
                self.novelty_agent,
                prompt,
                context=self.context,
                run_config=run_config
            )
            
            idea = result.final_output
            
            # Store the generated idea
            if idea and isinstance(idea, NoveltyIdea):
                self.context.store_idea(idea)
            
            return idea
    
    async def evaluate_idea(
        self, 
        idea_id: Optional[str] = None, 
        idea_content: Optional[Dict[str, Any]] = None
    ) -> IdeaEvaluationOutput:
        """
        Evaluate an idea for novelty, usefulness, and feasibility
        
        Args:
            idea_id: ID of a previously generated idea
            idea_content: New idea content to evaluate
            
        Returns:
            Evaluation results
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        idea = None
        
        # Get idea by ID or use provided content
        if idea_id and idea_id in self.context.generated_ideas:
            idea = self.context.generated_ideas[idea_id]
        elif idea_content:
            idea = idea_content
        else:
            raise ValueError("Must provide either idea_id or idea_content")
        
        # Convert to dict if object
        if hasattr(idea, 'model_dump'):
            idea = idea.model_dump()
        elif hasattr(idea, 'dict'):
            idea = idea.dict()
        
        # Run through evaluation agent
        with trace(workflow_name="Evaluate Idea", group_id=self.context.trace_id):
            prompt = f"Evaluate this idea:\n{json.dumps(idea, indent=2)}"
            
            result = await Runner.run(
                self.evaluation_agent,
                prompt,
                context=self.context
            )
            
            return result.final_output
    
    async def integrate_with_memory(
        self,
        query: str,
        idea_generation_technique: Union[str, CreativeTechnique] = CreativeTechnique.AUTO
    ) -> Dict[str, Any]:
        """
        Generate ideas inspired by related memories
        
        Args:
            query: Query to find relevant memories
            idea_generation_technique: Technique to use for idea generation
            
        Returns:
            Generated idea with related memories
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        if not self.context.memory_core:
            raise ValueError("Memory core not available")
        
        # Get relevant memories
        with trace(workflow_name="Memory-Inspired Novelty", group_id=self.context.trace_id):
            try:
                memories = await self.context.memory_core.retrieve_memories(
                    query=query,
                    memory_types=["observation", "reflection", "abstraction"],
                    limit=5
                )
                
                # Extract concepts from memories
                concepts = []
                memory_ids = []
                
                for memory in memories:
                    memory_text = memory.get("memory_text", "")
                    memory_id = memory.get("id", "")
                    
                    # Simple concept extraction
                    words = memory_text.split()
                    if len(words) > 5:
                        concepts.append(" ".join(words[:5]))
                    else:
                        concepts.append(memory_text)
                    
                    memory_ids.append(memory_id)
                
                # Generate idea using these concepts
                idea = await self.generate_novel_idea(
                    technique=idea_generation_technique,
                    concepts=concepts
                )
                
                # Add memory references to the idea
                if idea:
                    idea.related_memories = memory_ids
                    self.context.store_idea(idea)
                
                return {
                    "idea": idea,
                    "inspired_by_memories": memory_ids,
                    "memory_concepts": concepts
                }
                
            except Exception as e:
                logger.error(f"Error integrating with memory: {e}")
                raise
    
    async def get_generated_ideas(self, limit: int = 10) -> List[NoveltyIdea]:
        """
        Get previously generated ideas
        
        Args:
            limit: Maximum number of ideas to return
            
        Returns:
            List of previously generated ideas
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        # Get ideas in reverse chronological order
        ideas = list(self.context.generated_ideas.values())
        ideas.sort(key=lambda x: x.generation_date, reverse=True)
        
        return ideas[:limit]
    
    async def generate_idea_with_reasoning(
        self,
        technique: Union[str, CreativeTechnique] = CreativeTechnique.CONCEPTUAL_REASONING,
        domain: Optional[Union[str, CreativeDomain]] = None,
        concepts: Optional[List[str]] = None,
        constraints: Optional[List[str]] = None
    ) -> NoveltyIdea:
        """
        Generate a novel idea using the reasoning core's capabilities
        
        Args:
            technique: Reasoning technique to use
            domain: Main domain for the idea
            concepts: Concepts to work with
            constraints: Constraints to consider or relax
            
        Returns:
            Generated novel idea
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        # Ensure reasoning core is available
        if not self.context.reasoning_core:
            raise ValueError("Reasoning core not available for idea generation")
        
        return await self.generate_novel_idea(
            technique=technique,
            domain=domain,
            concepts=concepts,
            constraints=constraints
        )
    
    async def simulate_idea(
        self,
        idea_id: Optional[str] = None,
        idea_content: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Simulate an idea using the imagination simulator
        
        Args:
            idea_id: ID of a previously generated idea
            idea_content: New idea content to simulate
            
        Returns:
            Simulation results with insights
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        # Ensure imagination simulator is available
        if not self.context.imagination_simulator:
            raise ValueError("Imagination simulator not available for idea simulation")
        
        idea = None
        
        # Get idea by ID or use provided content
        if idea_id and idea_id in self.context.generated_ideas:
            idea = self.context.generated_ideas[idea_id]
        elif idea_content:
            idea = idea_content
        else:
            raise ValueError("Must provide either idea_id or idea_content")
        
        # Convert to dict if needed
        if hasattr(idea, 'model_dump'):
            idea = idea.model_dump()
        elif hasattr(idea, 'dict'):
            idea = idea.dict()
        elif not isinstance(idea, dict):
            idea = {"content": str(idea)}
        
        # Run through simulation agent
        with trace(workflow_name="Simulate Idea", group_id=self.context.trace_id):
            prompt = f"Simulate this idea and provide insights:\n{json.dumps(idea, indent=2)}"
            
            result = await Runner.run(
                self.simulation_agent,
                prompt,
                context=self.context
            )
            
            # Process the result
            if hasattr(result.final_output, "model_dump"):
                output = result.final_output.model_dump()
            else:
                output = result.final_output
            
            return {
                "idea": idea,
                "simulation_results": output,
                "insights": output.get("insights", []),
                "refinements": output.get("refinements", [])
            }
    
    async def generate_integrated_idea(
        self,
        description: str,
        domain: Optional[Union[str, CreativeDomain]] = None,
        use_reasoning: bool = True,
        use_simulation: bool = True
    ) -> NoveltyIdea:
        """
        Generate a novel idea using both reasoning and imagination capabilities
        
        Args:
            description: Description of the idea or problem to solve
            domain: Optional domain for the idea
            use_reasoning: Whether to use reasoning capabilities
            use_simulation: Whether to use imagination simulation
            
        Returns:
            Integrated novel idea
        """
        # Ensure engine is initialized
        if not self.initialized:
            await self.initialize()
        
        # First generate initial idea
        initial_idea = None
        
        if use_reasoning and self.context.reasoning_core:
            # Generate idea using reasoning
            technique = (CreativeTechnique.CONCEPTUAL_REASONING 
                        if random.random() < 0.5 
                        else CreativeTechnique.CAUSAL_REASONING)
            
            initial_idea = await self.generate_idea_with_reasoning(
                technique=technique,
                domain=domain,
                concepts=[description]
            )
        else:
            # Generate idea using regular techniques
            techniques = [
                CreativeTechnique.BISOCIATION, 
                CreativeTechnique.CONCEPTUAL_BLENDING,
                CreativeTechnique.RANDOM_STIMULUS,
                CreativeTechnique.PERSPECTIVE_SHIFTING
            ]
            technique = random.choice(techniques)
            
            initial_idea = await self.generate_novel_idea(
                technique=technique,
                domain=domain,
                concepts=[description]
            )
        
        # If no simulation requested or simulator not available, return initial idea
        if not use_simulation or not self.context.imagination_simulator:
            return initial_idea
        
        # Simulate and refine the idea
        try:
            simulation_result = await self.simulate_idea(
                idea_id=initial_idea.id if isinstance(initial_idea, NoveltyIdea) else None,
                idea_content=initial_idea if not isinstance(initial_idea, NoveltyIdea) else None
            )
            
            # Extract refined idea if available
            if "simulation_results" in simulation_result and isinstance(simulation_result["simulation_results"], dict):
                refined_data = simulation_result["simulation_results"]
                
                if "idea_title" in refined_data and "idea_description" in refined_data:
                    # Create refined idea
                    refined_idea = NoveltyIdea(
                        id=f"idea_{uuid.uuid4().hex[:8]}",
                        title=refined_data["idea_title"],
                        description=refined_data["idea_description"],
                        source_concepts=refined_data.get("source_concepts", []),
                        novelty_score=refined_data.get("novelty_score", initial_idea.novelty_score),
                        feasibility_score=refined_data.get("feasibility_score", initial_idea.feasibility_score),
                        usefulness_score=refined_data.get("usefulness_score", initial_idea.usefulness_score),
                        generation_date=datetime.datetime.now().isoformat(),
                        domain=CreativeDomain(refined_data.get("domain", domain or CreativeDomain.GENERAL)),
                        technique_used=f"{initial_idea.technique_used}_with_simulation",
                        metadata={"simulation_insights": simulation_result.get("insights", [])}
                    )
                    
                    # Store the refined idea
                    self.context.generated_ideas[refined_idea.id] = refined_idea
                    
                    return refined_idea
        except Exception as e:
            logger.error(f"Error during simulation: {e}")
        
        # Return initial idea if refinement failed
        return initial_idea

# ============================================================================
# Tool Functions - All with RunContextWrapper as first parameter
# ============================================================================

@function_tool
async def _get_creative_techniques(ctx: RunContextWrapper[NoveltyEngineContext]) -> Dict[str, str]:
    """
    Get the list of available creative techniques
    
    Returns:
        Dictionary of technique names and descriptions
    """
    return ctx.context.techniques

@function_tool
async def _get_domains(ctx: RunContextWrapper[NoveltyEngineContext]) -> List[str]:
    """
    Get the list of creative domains
    
    Returns:
        List of domain names
    """
    return ctx.context.domains

@function_tool(strict_mode=False)  # Disable strict schema for complex return
async def _extract_domain_principles(
    ctx: RunContextWrapper[NoveltyEngineContext],
    domain: str
) -> List[Dict[str, str]]:
    """
    Extract key principles from a domain
    
    Args:
        domain: Domain to analyze
        
    Returns:
        List of principles with descriptions
    """
    principles = []
    
    if domain.lower() == "technology":
        principles = [
            {"name": "Moore's Law", "description": "Computing power doubles approximately every two years", "domain": domain},
            {"name": "Modularity", "description": "Complex systems are built from simpler, interchangeable components", "domain": domain},
            {"name": "Abstraction", "description": "Hide complexity behind simpler interfaces", "domain": domain}
        ]
    elif domain.lower() == "biology":
        principles = [
            {"name": "Natural Selection", "description": "Traits that increase survival tend to increase in frequency", "domain": domain},
            {"name": "Homeostasis", "description": "Biological systems maintain internal stability", "domain": domain},
            {"name": "Emergence", "description": "Complex systems exhibit properties not predictable from their components", "domain": domain}
        ]
    else:
        # Generate generic principles
        principles = [
            {"name": f"{domain.capitalize()} Principle 1", "description": f"Key principle in {domain}", "domain": domain},
            {"name": f"{domain.capitalize()} Principle 2", "description": f"Another important principle in {domain}", "domain": domain},
            {"name": f"{domain.capitalize()} Principle 3", "description": f"A fundamental aspect of {domain}", "domain": domain}
        ]
    
    return principles

@function_tool(strict_mode=False)  # Disable strict schema for complex return
async def _find_connections(
    ctx: RunContextWrapper[NoveltyEngineContext],
    domain1_principles: List[Dict[str, str]],
    domain2_principles: List[Dict[str, str]]
) -> List[Dict[str, str]]:
    """
    Find potential connections between principles from different domains
    
    Args:
        domain1_principles: Principles from first domain
        domain2_principles: Principles from second domain
        
    Returns:
        List of potential connections
    """
    connections = []
    
    for i, principle1 in enumerate(domain1_principles):
        for j, principle2 in enumerate(domain2_principles):
            if i == j:  # Simple matching for demonstration
                connections.append({
                    "connection": f"Connection between {principle1['name']} and {principle2['name']}",
                    "description": f"Both involve {principle1['description'].split()[0]} and {principle2['description'].split()[0]}",
                    "strength": "0.7"
                })
    
    return connections

@function_tool(strict_mode=False)
async def _decompose_concepts(
    ctx: RunContextWrapper[NoveltyEngineContext],
    concepts: List[str]
) -> List[Dict[str, Any]]:
    """
    Decompose concepts into their core elements
    
    Args:
        concepts: List of concepts to decompose
        
    Returns:
        List of decomposed concepts
    """
    decomposed = []
    
    for concept in concepts:
        # Generate some elements based on the concept
        elements = [
            f"{concept} element 1",
            f"{concept} element 2",
            f"{concept} element 3",
            f"{concept} element 4"
        ]
        decomposed.append({"concept": concept, "elements": elements})
    
    return decomposed

@function_tool(strict_mode=False)
async def _create_blended_space(
    ctx: RunContextWrapper[NoveltyEngineContext],
    concept_decompositions: List[Dict[str, Any]]
) -> Dict[str, List[str]]:
    """
    Create a blended conceptual space from elements
    
    Args:
        concept_decompositions: Decomposed concepts
        
    Returns:
        Blended space description
    """
    all_elements = []
    for decomp in concept_decompositions:
        all_elements.extend(decomp.get("elements", []))
    
    # Select random elements for the blend
    selected_elements = random.sample(all_elements, min(5, len(all_elements)))
    
    return {
        "elements": selected_elements,
        "emergent_properties": ["Emergent property 1", "Emergent property 2"],
        "potential_applications": ["Potential application 1", "Potential application 2"]
    }

@function_tool(strict_mode=False)
async def _identify_constraints(
    ctx: RunContextWrapper[NoveltyEngineContext],
    domain: str
) -> List[Dict[str, Any]]:
    """
    Identify implicit and explicit constraints in a domain
    
    Args:
        domain: Domain to analyze
        
    Returns:
        List of constraints
    """
    constraints = [
        {
            "constraint": f"{domain} constraint 1",
            "type": "explicit",
            "description": f"A common limitation in {domain}",
            "restrictiveness": 0.8
        },
        {
            "constraint": f"{domain} constraint 2",
            "type": "implicit",
            "description": f"An unstated assumption in {domain}",
            "restrictiveness": 0.6
        },
        {
            "constraint": f"{domain} constraint 3",
            "type": "explicit",
            "description": f"A rule generally followed in {domain}",
            "restrictiveness": 0.7
        }
    ]
    
    return constraints

@function_tool(strict_mode=False)
async def _explore_constraint_removal(
    ctx: RunContextWrapper[NoveltyEngineContext],
    constraints: List[Dict[str, Any]]
) -> List[Dict[str, Any]]:
    """
    Explore possibilities opened by removing constraints
    
    Args:
        constraints: List of constraints to consider removing
        
    Returns:
        List of possibilities
    """
    possibilities = []
    
    for constraint in constraints:
        possibility = {
            "removed_constraint": constraint.get("constraint", "Unknown"),
            "possibilities": [
                f"Possibility 1 if {constraint.get('constraint', 'constraint')} is removed",
                f"Possibility 2 if {constraint.get('constraint', 'constraint')} is removed"
            ],
            "potential_benefits": ["Potential benefit 1", "Potential benefit 2"],
            "potential_risks": ["Potential risk 1", "Potential risk 2"]
        }
        possibilities.append(possibility)
    
    return possibilities

@function_tool
async def _generate_random_stimuli(
    ctx: RunContextWrapper[NoveltyEngineContext],
    count: int = 3
) -> List[str]:
    """
    Generate random stimuli for creative inspiration
    
    Args:
        count: Number of stimuli to generate
        
    Returns:
        List of random stimuli
    """
    stimuli_options = [
        "butterfly", "skyscraper", "quantum entanglement", "origami",
        "beehive", "symphony", "whirlpool", "mirage", "kaleidoscope",
        "labyrinth", "bioluminescence", "avalanche", "phoenix",
        "fractal", "echo", "nebula", "metamorphosis", "pendulum"
    ]
    
    return random.sample(stimuli_options, min(count, len(stimuli_options)))

@function_tool(strict_mode=False)
async def _force_connections(
    ctx: RunContextWrapper[NoveltyEngineContext],
    problem: str,
    stimuli: List[str]
) -> List[Dict[str, str]]:
    """
    Force connections between a problem and random stimuli
    
    Args:
        problem: Problem to solve
        stimuli: Random stimuli to connect with
        
    Returns:
        List of forced connections
    """
    connections = []
    
    for stimulus in stimuli:
        connection = {
            "stimulus": stimulus,
            "connection": f"Connection between {problem} and {stimulus}",
            "idea": f"What if {problem} used the principle of {stimulus}?"
        }
        connections.append(connection)
    
    return connections

@function_tool(strict_mode=False)
async def _generate_perspectives(
    ctx: RunContextWrapper[NoveltyEngineContext],
    problem: str
) -> List[Dict[str, str]]:
    """
    Generate unusual perspectives for viewing a problem
    
    Args:
        problem: Problem to view from different perspectives
        
    Returns:
        List of perspectives
    """
    perspectives = [
        {"perspective": "Child's perspective", "description": "How would a 5-year-old approach this problem?"},
        {"perspective": "Future perspective", "description": "How would this be solved 100 years from now?"},
        {"perspective": "Nature's perspective", "description": "How would nature solve this problem?"},
        {"perspective": "Alien perspective", "description": "How would an alien civilization approach this?"},
        {"perspective": "Opposite perspective", "description": "What if we wanted the opposite of the usual goal?"}
    ]
    
    return perspectives

@function_tool(strict_mode=False)
async def _analyze_from_perspective(
    ctx: RunContextWrapper[NoveltyEngineContext],
    problem: str,
    perspective: Dict[str, str]
) -> Dict[str, Any]:
    """
    Analyze a problem from a specific perspective
    
    Args:
        problem: Problem to analyze
        perspective: Perspective to use
        
    Returns:
        Analysis from that perspective
    """
    return {
        "problem": problem,
        "perspective": perspective.get("perspective", "Unknown"),
        "insights": [
            f"Insight 1 from {perspective.get('perspective', 'this perspective')}",
            f"Insight 2 from {perspective.get('perspective', 'this perspective')}",
            f"Insight 3 from {perspective.get('perspective', 'this perspective')}"
        ],
        "unique_observations": [
            f"Observation 1 from {perspective.get('perspective', 'this perspective')}",
            f"Observation 2 from {perspective.get('perspective', 'this perspective')}"
        ],
        "potential_solutions": [
            f"Solution idea 1 from {perspective.get('perspective', 'this perspective')}",
            f"Solution idea 2 from {perspective.get('perspective', 'this perspective')}"
        ]
    }

@function_tool(strict_mode=False)
async def _extract_domain_structure(
    ctx: RunContextWrapper[NoveltyEngineContext],
    domain: str
) -> Dict[str, Any]:
    """
    Extract the deep structure of a domain for analogical reasoning
    
    Args:
        domain: Domain to analyze
        
    Returns:
        Structural elements of the domain
    """
    return {
        "domain": domain,
        "entities": [
            f"{domain} entity 1",
            f"{domain} entity 2",
            f"{domain} entity 3"
        ],
        "relationships": [
            {"from_entity": f"{domain} entity 1", "to_entity": f"{domain} entity 2", "type": "influences"},
            {"from_entity": f"{domain} entity 2", "to_entity": f"{domain} entity 3", "type": "contains"},
            {"from_entity": f"{domain} entity 3", "to_entity": f"{domain} entity 1", "type": "transforms"}
        ],
        "processes": [
            f"{domain} process 1",
            f"{domain} process 2"
        ],
        "principles": [
            f"{domain} principle 1",
            f"{domain} principle 2"
        ]
    }

@function_tool(strict_mode=False)
async def _map_across_domains(
    ctx: RunContextWrapper[NoveltyEngineContext],
    source_structure: Dict[str, Any],
    target_domain: str
) -> Dict[str, Any]:
    """
    Map structures from source domain to target domain
    
    Args:
        source_structure: Structure of source domain
        target_domain: Target domain to map to
        
    Returns:
        Mapping between domains
    """
    source_domain = source_structure.get("domain", "Unknown")
    entities = source_structure.get("entities", [])
    relationships = source_structure.get("relationships", [])
    
    return {
        "source_domain": source_domain,
        "target_domain": target_domain,
        "entity_mappings": [
            {"source": entity, "target": f"{target_domain} analogue of {entity}"}
            for entity in entities
        ],
        "relationship_mappings": [
            {"source_rel": f"{rel.get('type', 'unknown')} relationship", "target_rel": f"{target_domain} equivalent of {rel.get('type', 'unknown')}"}
            for rel in relationships
        ],
        "inferences": [
            f"Inference 1 for {target_domain} based on {source_domain}",
            f"Inference 2 for {target_domain} based on {source_domain}",
            f"Inference 3 for {target_domain} based on {source_domain}"
        ],
        "novel_ideas": [
            f"Idea 1 for {target_domain} inspired by {source_domain}",
            f"Idea 2 for {target_domain} inspired by {source_domain}"
        ]
    }

@function_tool(strict_mode=False)
async def _assess_novelty(
    ctx: RunContextWrapper[NoveltyEngineContext],
    idea_description: str
) -> Dict[str, Any]:
    """
    Assess the novelty of an idea
    
    Args:
        idea_description: Description of the idea to assess
        
    Returns:
        Novelty assessment
    """
    # Random novelty score between 0.4 and 0.9
    novelty_score = round(random.uniform(0.4, 0.9), 2)
    
    return {
        "novelty_score": novelty_score,
        "similar_existing_ideas": ["Similar idea 1", "Similar idea 2"],
        "differentiating_factors": ["Differentiating factor 1", "Differentiating factor 2"],
        "originality_aspects": ["Original aspect 1", "Original aspect 2"]
    }

@function_tool(strict_mode=False)
async def _assess_usefulness(
    ctx: RunContextWrapper[NoveltyEngineContext],
    idea_description: str
) -> Dict[str, Any]:
    """
    Assess the usefulness of an idea
    
    Args:
        idea_description: Description of the idea to assess
        
    Returns:
        Usefulness assessment
    """
    # Random usefulness score between 0.3 and 0.8
    usefulness_score = round(random.uniform(0.3, 0.8), 2)
    
    return {
        "usefulness_score": usefulness_score,
        "potential_applications": ["Application 1", "Application 2", "Application 3"],
        "potential_benefits": ["Benefit 1", "Benefit 2"],
        "target_audience": ["Audience 1", "Audience 2"],
        "value_propositions": ["Value proposition 1", "Value proposition 2"]
    }

@function_tool(strict_mode=False)
async def _assess_feasibility(
    ctx: RunContextWrapper[NoveltyEngineContext],
    idea_description: str
) -> Dict[str, Any]:
    """
    Assess the feasibility of an idea
    
    Args:
        idea_description: Description of the idea to assess
        
    Returns:
        Feasibility assessment
    """
    # Random feasibility score between 0.2 and 0.9
    feasibility_score = round(random.uniform(0.2, 0.9), 2)
    
    return {
        "feasibility_score": feasibility_score,
        "implementation_challenges": ["Challenge 1", "Challenge 2", "Challenge 3"],
        "resource_requirements": ["Resource 1", "Resource 2"],
        "technological_readiness": round(random.uniform(0.1, 1.0), 2),
        "timeline_estimate": f"{random.randint(1, 36)} months"
    }

# Tool functions for integrated cognitive systems

@function_tool(strict_mode=False)
async def _get_concept_spaces(
    ctx: RunContextWrapper[NoveltyEngineContext], 
    domain: Optional[str] = None
) -> List[Dict[str, Any]]:
    """
    Get available concept spaces from the reasoning core
    
    Args:
        domain: Optional domain to filter concept spaces
        
    Returns:
        List of available concept spaces
    """
    if not ctx.context.reasoning_core:
        return []
    
    try:
        # Get all concept spaces
        all_spaces = await ctx.context.reasoning_core.get_all_concept_spaces()
        
        if domain:
            spaces = [s for s in all_spaces if domain.lower() in s["domain"].lower()]
        else:
            spaces = all_spaces
        
        # Return simplified space information
        return [
            {
                "id": space["id"],
                "name": space["name"],
                "domain": space["domain"],
                "concept_count": len(space.get("concepts", {})),
                "organizing_principles": [p["name"] for p in space.get("organizing_principles", [])]
            } for space in spaces
        ]
    except Exception as e:
        logger.error(f"Error retrieving concept spaces: {str(e)}")
        return []

@function_tool(strict_mode=False)
async def _create_conceptual_blend(
    ctx: RunContextWrapper[NoveltyEngineContext],
    space_id1: str,
    space_id2: str,
    blend_type: str = "conceptual_blend"
) -> Dict[str, Any]:
    """
    Create a conceptual blend between two concept spaces
    
    Args:
        space_id1: ID of first concept space
        space_id2: ID of second concept space
        blend_type: Type of blend to create
        
    Returns:
        Details of the created blend
    """
    if not ctx.context.reasoning_core:
        return {"error": "Reasoning core not available"}
    
    try:
        # Get the concept spaces
        space1 = await ctx.context.reasoning_core.get_concept_space(space_id1)
        space2 = await ctx.context.reasoning_core.get_concept_space(space_id2)
        
        # Create mappings between spaces
        mappings = []
        
        # Find mappings between concepts in the spaces
        for concept1_id, concept1 in space1.get("concepts", {}).items():
            for concept2_id, concept2 in space2.get("concepts", {}).items():
                # Calculate similarity
                name_similarity = 0
                if concept1.get("name") and concept2.get("name"):
                    name1 = concept1["name"].lower()
                    name2 = concept2["name"].lower()
                    words1 = set(name1.split())
                    words2 = set(name2.split())
                    if words1 or words2:
                        overlap = len(words1.intersection(words2))
                        name_similarity = overlap / max(1, len(words1.union(words2)))
                
                if name_similarity > 0.2:
                    mappings.append({
                        "concept1": concept1_id,
                        "concept2": concept2_id,
                        "similarity": name_similarity
                    })
        
        # Create the blend
        blend_method_map = {
            "conceptual_blend": "composition",
            "contrast": "contrast",
            "fusion": "fusion"
        }
        
        method_name = blend_method_map.get(blend_type, "composition")
        
        if hasattr(ctx.context.reasoning_core, f"_generate_{method_name}_blend"):
            blend_method = getattr(ctx.context.reasoning_core, f"_generate_{method_name}_blend")
            blend = await blend_method(space1, space2, mappings)
            return blend
        
        return {"error": "Could not create blend, no suitable method found"}
    except Exception as e:
        logger.error(f"Error creating conceptual blend: {str(e)}")
        return {"error": f"Error creating conceptual blend: {str(e)}"}

@function_tool(strict_mode=False)
async def _extract_novel_ideas_from_blend(
    ctx: RunContextWrapper[NoveltyEngineContext],
    blend_id: str
) -> List[Dict[str, Any]]:
    """
    Extract novel ideas from a conceptual blend
    
    Args:
        blend_id: ID of the conceptual blend
        
    Returns:
        List of novel ideas extracted from the blend
    """
    if not ctx.context.reasoning_core:
        return []
    
    try:
        # Get the blend
        blend = await ctx.context.reasoning_core.get_blend(blend_id)
        
        ideas = []
        
        # Extract ideas from emergent structure
        for structure in blend.get("emergent_structure", []):
            idea = {
                "title": structure.get("name", "Emergent Concept"),
                "description": structure.get("description", ""),
                "source_concepts": [
                    blend["concepts"][c]["name"] 
                    for c in structure.get("concepts", []) 
                    if c in blend.get("concepts", {})
                ],
                "novelty_score": 0.8,
                "technique_used": "conceptual_blending"
            }
            ideas.append(idea)
        
        # If no emergent structures, look at blend concepts
        if not ideas:
            for concept_id, concept in blend.get("concepts", {}).items():
                source_concepts = concept.get("source_concepts", [])
                space_ids = set(src.get("space_id") for src in source_concepts)
                
                if len(space_ids) > 1:
                    idea = {
                        "title": concept.get("name", "Blended Concept"),
                        "description": f"A novel concept combining elements from multiple domains: {', '.join(concept.get('properties', {}).keys())}",
                        "source_concepts": [
                            blend["concepts"][src.get("concept_id")]["name"] 
                            for src in source_concepts 
                            if src.get("concept_id") in blend.get("concepts", {})
                        ],
                        "novelty_score": 0.7,
                        "technique_used": "conceptual_blending"
                    }
                    ideas.append(idea)
        
        return ideas
    except Exception as e:
        logger.error(f"Error extracting ideas from blend: {str(e)}")
        return []

@function_tool(strict_mode=False)
async def _get_causal_models(
    ctx: RunContextWrapper[NoveltyEngineContext],
    domain: Optional[str] = None
) -> List[Dict[str, Any]]:
    """
    Get available causal models from the reasoning core
    
    Args:
        domain: Optional domain to filter causal models
        
    Returns:
        List of available causal models
    """
    if not ctx.context.reasoning_core:
        return []
    
    try:
        # Get all causal models
        models = await ctx.context.reasoning_core.get_all_causal_models()
        
        # Filter by domain if provided
        if domain:
            models = [m for m in models if domain.lower() in m["domain"].lower()]
        
        # Return simplified model information
        return [
            {
                "id": model["id"],
                "name": model["name"],
                "domain": model["domain"],
                "node_count": len(model.get("nodes", {})),
                "relation_count": len(model.get("relations", {}))
            } for model in models
        ]
    except Exception as e:
        logger.error(f"Error retrieving causal models: {str(e)}")
        return []

@function_tool(strict_mode=False)
async def _analyze_causal_impacts(
    ctx: RunContextWrapper[NoveltyEngineContext],
    model_id: str,
    idea_description: str
) -> Dict[str, Any]:
    """
    Analyze the causal impacts of an idea using a causal model
    
    Args:
        model_id: ID of the causal model to use
        idea_description: Description of the idea to analyze
        
    Returns:
        Analysis of potential causal impacts
    """
    if not ctx.context.reasoning_core:
        return {
            "model_name": "Unknown",
            "relevant_nodes": [],
            "causal_impacts": [],
            "overall_impact_score": 0.0
        }
    
    try:
        # Get the causal model
        model = await ctx.context.reasoning_core.get_causal_model(model_id)
        
        # Find most relevant nodes for the idea
        relevant_nodes = []
        for node_id, node in model.get("nodes", {}).items():
            node_name = node.get("name", "").lower()
            description = idea_description.lower()
            
            if node_name in description or any(word in description for word in node_name.split()):
                relevant_nodes.append({
                    "id": node_id,
                    "name": node["name"],
                    "relevance": 0.8 if node_name in description else 0.6
                })
        
        # If no relevant nodes found, use central nodes
        if not relevant_nodes:
            node_connections = {}
            for relation in model.get("relations", {}).values():
                source_id = relation.get("source_id")
                target_id = relation.get("target_id")
                
                if source_id:
                    node_connections[source_id] = node_connections.get(source_id, 0) + 1
                if target_id:
                    node_connections[target_id] = node_connections.get(target_id, 0) + 1
            
            sorted_nodes = sorted(node_connections.items(), key=lambda x: x[1], reverse=True)
            
            for node_id, connection_count in sorted_nodes[:3]:
                if node_id in model.get("nodes", {}):
                    relevant_nodes.append({
                        "id": node_id,
                        "name": model["nodes"][node_id]["name"],
                        "relevance": 0.5
                    })
        
        # Determine potential impacts
        impacts = []
        for node in relevant_nodes:
            node_id = node["id"]
            
            downstream = []
            for relation_id, relation in model.get("relations", {}).items():
                if relation.get("source_id") == node_id:
                    target_id = relation.get("target_id")
                    if target_id in model.get("nodes", {}):
                        downstream.append({
                            "id": target_id,
                            "name": model["nodes"][target_id]["name"],
                            "relation_type": relation.get("type", "causal"),
                            "strength": relation.get("strength", 0.5)
                        })
            
            impacts.append({
                "node": node,
                "downstream_effects": downstream,
                "potential_impact": len(downstream) * 0.2
            })
        
        return {
            "model_name": model["name"],
            "relevant_nodes": relevant_nodes,
            "causal_impacts": impacts,
            "overall_impact_score": sum(impact["potential_impact"] for impact in impacts)
        }
    except Exception as e:
        logger.error(f"Error analyzing causal impacts: {str(e)}")
        return {
            "model_name": "Error",
            "relevant_nodes": [],
            "causal_impacts": [],
            "overall_impact_score": 0.0
        }

@function_tool(strict_mode=False)
async def _generate_causal_interventions(
    ctx: RunContextWrapper[NoveltyEngineContext],
    model_id: str,
    target_outcome: str
) -> List[Dict[str, Any]]:
    """
    Generate potential interventions to achieve a target outcome
    
    Args:
        model_id: ID of the causal model to use
        target_outcome: Description of the desired outcome
        
    Returns:
        List of potential interventions
    """
    if not ctx.context.reasoning_core:
        return []
    
    try:
        # Get the causal model
        model = await ctx.context.reasoning_core.get_causal_model(model_id)
        
        # Find nodes relevant to the target outcome
        target_nodes = []
        for node_id, node in model.get("nodes", {}).items():
            node_name = node.get("name", "").lower()
            outcome = target_outcome.lower()
            
            if node_name in outcome or any(word in outcome for word in node_name.split()):
                target_nodes.append({
                    "id": node_id,
                    "name": node["name"],
                    "current_state": node.get("current_state", "unknown")
                })
        
        # Find potential intervention points
        interventions = []
        for target in target_nodes:
            influencers = set()
            stack = [target["id"]]
            visited = set(stack)
            
            while stack:
                current = stack.pop()
                
                for relation_id, relation in model.get("relations", {}).items():
                    if relation.get("target_id") == current:
                        source_id = relation.get("source_id")
                        if source_id and source_id not in visited:
                            influencers.add(source_id)
                            stack.append(source_id)
                            visited.add(source_id)
            
            # Create interventions
            for influencer_id in influencers:
                if influencer_id in model.get("nodes", {}):
                    influencer = model["nodes"][influencer_id]
                    
                    current_state = influencer.get("current_state", "unknown")
                    possible_states = influencer.get("states", ["low", "medium", "high"])
                    
                    if possible_states and current_state in possible_states:
                        alternative_states = [s for s in possible_states if s != current_state]
                        if alternative_states:
                            target_state = random.choice(alternative_states)
                            
                            interventions.append({
                                "target_node": {
                                    "id": influencer_id,
                                    "name": influencer["name"]
                                },
                                "current_state": current_state,
                                "intervention_state": target_state,
                                "description": f"Change {influencer['name']} from {current_state} to {target_state}",
                                "expected_outcome": f"This should influence {target['name']} toward achieving {target_outcome}"
                            })
        
        return interventions
    except Exception as e:
        logger.error(f"Error generating causal interventions: {str(e)}")
        return []

@function_tool(strict_mode=False)
async def _reason_counterfactually(
    ctx: RunContextWrapper[NoveltyEngineContext],
    model_id: str,
    counterfactual_query: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Perform counterfactual reasoning to explore alternative scenarios
    
    Args:
        model_id: ID of the causal model to use
        counterfactual_query: Query specifying the counterfactual scenario
        
    Returns:
        Results of counterfactual reasoning
    """
    if not ctx.context.reasoning_core:
        return {"error": "Reasoning core not available"}
    
    try:
        # Perform counterfactual reasoning using the reasoning core
        result = await ctx.context.reasoning_core.reason_counterfactually(
            model_id=model_id,
            query=counterfactual_query
        )
        
        return result
    except Exception as e:
        logger.error(f"Error performing counterfactual reasoning: {str(e)}")
        return {"error": f"Error performing counterfactual reasoning: {str(e)}"}

@function_tool(strict_mode=False)
async def _setup_imagination_simulation(
    ctx: RunContextWrapper[NoveltyEngineContext],
    idea_description: str,
    current_state: Optional[Dict[str, Any]] = None,
    domain: str = "general"
) -> Dict[str, Any]:
    """
    Set up a simulation for exploring an idea using the imagination simulator
    
    Args:
        idea_description: Description of the idea to simulate
        current_state: Optional current state to start from
        domain: Domain for the simulation
        
    Returns:
        Simulation setup details
    """
    if not ctx.context.imagination_simulator:
        return {
            "simulation_id": "error",
            "description": "Imagination simulator not available",
            "initial_state": {},
            "domain": domain,
            "max_steps": 0,
            "focus_variables": []
        }
    
    try:
        # Create a default current state if none provided
        if not current_state:
            current_state = {
                "user_satisfaction": 0.5,
                "idea_feasibility": 0.5,
                "idea_novelty": 0.7,
                "implementation_progress": 0.0
            }
        
        # Set up the simulation using the imagination simulator
        sim_input = await ctx.context.imagination_simulator.setup_simulation(
            description=idea_description,
            current_brain_state=current_state
        )
        
        if sim_input:
            return {
                "simulation_id": sim_input.simulation_id,
                "description": sim_input.description,
                "initial_state": sim_input.initial_state,
                "domain": sim_input.domain,
                "max_steps": sim_input.max_steps,
                "focus_variables": sim_input.focus_variables
            }
        else:
            return {
                "simulation_id": "error",
                "description": "Failed to set up simulation",
                "initial_state": {},
                "domain": domain,
                "max_steps": 0,
                "focus_variables": []
            }
    except Exception as e:
        logger.error(f"Error setting up imagination simulation: {str(e)}")
        return {
            "simulation_id": "error",
            "description": f"Error: {str(e)}",
            "initial_state": {},
            "domain": domain,
            "max_steps": 0,
            "focus_variables": []
        }

@function_tool(strict_mode=False)
async def _run_imagination_simulation(
    ctx: RunContextWrapper[NoveltyEngineContext],
    simulation_setup: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Run a simulation using the imagination simulator
    
    Args:
        simulation_setup: Setup details for the simulation
        
    Returns:
        Results of the simulation
    """
    if not ctx.context.imagination_simulator:
        return {
            "simulation_id": simulation_setup.get("simulation_id", "unknown"),
            "success": False,
            "termination_reason": "Imagination simulator not available",
            "steps": 0,
            "final_state": {},
            "confidence": 0.0
        }
    
    try:
        # Convert to SimulationInput
        from nyx.core.imagination_simulator import SimulationInput
        
        sim_input = SimulationInput(
            simulation_id=simulation_setup.get("simulation_id", f"sim_{uuid.uuid4().hex[:8]}"),
            description=simulation_setup.get("description", "Idea simulation"),
            initial_state=simulation_setup.get("initial_state", {}),
            max_steps=simulation_setup.get("max_steps", 10),
            focus_variables=simulation_setup.get("focus_variables", []),
            domain=simulation_setup.get("domain", "general"),
            use_reflection=True
        )
        
        # Run the simulation
        result = await ctx.context.imagination_simulator.run_simulation(sim_input)
        
        if result:
            return {
                "simulation_id": result.simulation_id,
                "success": result.success,
                "termination_reason": result.termination_reason,
                "steps": len(result.trajectory),
                "final_state": result.final_state.model_dump() if result.final_state else {},
                "reflection": result.reflection,
                "confidence": result.confidence
            }
        else:
            return {
                "simulation_id": simulation_setup.get("simulation_id", "unknown"),
                "success": False,
                "termination_reason": "Simulation failed",
                "steps": 0,
                "final_state": {},
                "confidence": 0.0
            }
    except Exception as e:
        logger.error(f"Error running imagination simulation: {str(e)}")
        return {
            "simulation_id": simulation_setup.get("simulation_id", "unknown"),
            "success": False,
            "termination_reason": f"Error: {str(e)}",
            "steps": 0,
            "final_state": {},
            "confidence": 0.0
        }

@function_tool(strict_mode=False)
async def _extract_insights_from_simulation(
    ctx: RunContextWrapper[NoveltyEngineContext],
    simulation_result: Dict[str, Any]
) -> List[Dict[str, str]]:
    """
    Extract insights and creative ideas from a simulation result
    
    Args:
        simulation_result: Results of an imagination simulation
        
    Returns:
        List of insights extracted from the simulation
    """
    insights = []
    
    # Check for reflection
    if simulation_result.get("reflection"):
        insights.append({
            "type": "reflection",
            "content": simulation_result["reflection"]
        })
    
    # Check final state
    final_state = simulation_result.get("final_state", {})
    if final_state:
        state_vars = final_state.get("state_variables", {})
        
        var_descriptions = []
        for name, value in state_vars.items():
            if isinstance(value, (int, float)):
                level = "high" if value > 0.7 else "moderate" if value > 0.3 else "low"
                var_descriptions.append(f"{name}: {level} ({value:.2f})")
            else:
                var_descriptions.append(f"{name}: {value}")
        
        if var_descriptions:
            insights.append({
                "type": "state_analysis",
                "content": f"Final state analysis: {'; '.join(var_descriptions)}"
            })
    
    # Add basic insight about simulation outcome
    insights.append({
        "type": "outcome",
        "content": f"Simulation {'succeeded' if simulation_result.get('success', False) else 'failed'} " +
                  f"due to {simulation_result.get('termination_reason', 'unknown')} after {simulation_result.get('steps', 0)} steps."
    })
    
    # Add basic insight about simulation outcome
    insights.append({
        "type": "outcome",
        "content": f"Simulation {'succeeded' if simulation_result.get('success', False) else 'failed'} " +
                  f"due to {simulation_result.get('termination_reason', 'unknown')} after {simulation_result.get('steps', 0)} steps."
    })
    
    return insights

@function_tool(strict_mode=False)
async def _refine_idea_from_simulation(
    ctx: RunContextWrapper[NoveltyEngineContext],
    original_idea: Dict[str, Any],
    simulation_result: Dict[str, Any],
    insights: List[Dict[str, str]]
) -> Dict[str, Any]:
    """
    Refine an idea based on simulation results and insights
    
    Args:
        original_idea: The original idea
        simulation_result: Results of simulating the idea
        insights: Insights extracted from the simulation
        
    Returns:
        Refined version of the idea
    """
    # Start with a copy of the original idea
    refined_idea = original_idea.copy()
    
    # Add refinements based on simulation outcomes
    refinements = []
    
    # Check simulation success
    if simulation_result.get("success", False):
        refinements.append("Simulation indicates this idea is likely to succeed")
    else:
        termination_reason = simulation_result.get("termination_reason", "unknown")
        if termination_reason == "max_steps":
            refinements.append("Simulation suggests this idea needs more time to fully develop")
        elif termination_reason == "goal_reached":
            refinements.append("Simulation shows this idea achieves its intended goals")
        elif termination_reason == "stable_state":
            refinements.append("Simulation shows this idea reaches a stable equilibrium")
        else:
            refinements.append(f"Simulation terminated due to {termination_reason}")
    
    # Add insights from simulation
    for insight in insights:
        if insight.get("type") == "reflection" and insight.get("content"):
            refinements.append(f"Reflection: {insight['content']}")
        elif insight.get("type") == "state_analysis" and insight.get("content"):
            refinements.append(f"State analysis: {insight['content']}")
    
    # Update idea description with refinements
    refinement_text = "\n\nRefinements based on simulation:\n" + "\n".join([f"- {r}" for r in refinements])
    refined_idea["idea_description"] = refined_idea.get("idea_description", "") + refinement_text
    
    # Update title
    refined_idea["idea_title"] = f"{refined_idea.get('idea_title', 'Idea')} (Simulation Refined)"
    
    # Note technique update
    refined_idea["technique_used"] = f"{refined_idea.get('technique_used', 'unknown')} + imagination_simulation"
    
    return refined_idea
