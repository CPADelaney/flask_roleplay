<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Roleplay Chat</title>
  <style>
    /* Simple flex layout: side panel for convos, main panel for chat */
    #chatContainer {
      display: flex;
      flex-direction: row;
      width: 100%;
      height: 80vh;
    }
    #convPanel {
      width: 250px;
      border-right: 1px solid #ccc;
      padding: 10px;
      overflow-y: auto;
    }
    #chatPanel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    #chatWindow {
      flex: 1;
      border: 1px solid #ccc;
      margin: 10px;
      padding: 10px;
      overflow-y: auto;
    }
    #inputRow {
      margin: 10px;
      display: flex;
    }
    #userMsg {
      flex: 1;
      margin-right: 10px;
    }
  </style>
</head>
<body>

<h1>Roleplay Chat</h1>

<div id="chatContainer">
  <!-- Left: Conversation List + "New Chat" Button -->
  <div id="convPanel">
    <button onclick="createNewChat()">+ New Chat</button>
    <h3>My Conversations</h3>
    <div id="convList"></div>
  </div>

  <!-- Right: Chat window + input -->
  <div id="chatPanel">
    <div id="chatWindow"></div>
    <div id="inputRow">
      <input type="text" id="userMsg" placeholder="Type your message"/>
      <button onclick="sendMessage()">Send</button>
    </div>
  </div>
</div>

<script>
  let currentConvId = null;

  // On page load, fetch existing conversations
  window.onload = async function() {
    await loadConversations();
  };

  // 1. Load the user's existing conversations
  async function loadConversations() {
    try {
      const res = await fetch("/multiuser/conversations");
      if (!res.ok) {
        console.error("Failed to get conversations:", res.status);
        return;
      }
      const convoData = await res.json(); // array of {id, name, created_at}
      renderConvoList(convoData);
    } catch (err) {
      console.error("Error loading conversations:", err);
    }
  }

  function renderConvoList(conversations) {
    const convListDiv = document.getElementById("convList");
    convListDiv.innerHTML = ""; // clear old

    conversations.forEach(conv => {
      // Create a button or clickable element
      const btn = document.createElement("button");
      btn.textContent = conv.name;
      btn.style.display = "block";
      btn.style.marginBottom = "5px";
      btn.onclick = () => selectConversation(conv.id);
      convListDiv.appendChild(btn);
    });
  }

  // 2. Select an existing conversation, load its messages
  async function selectConversation(convId) {
    currentConvId = convId;
    try {
      const res = await fetch(`/multiuser/conversations/${convId}/messages`);
      if (!res.ok) {
        console.error("Failed to load messages for convo:", convId);
        return;
      }
      const data = await res.json(); // {messages: [...]}
      renderChat(data.messages);
    } catch (err) {
      console.error("Error selecting conversation:", err);
    }
  }

  // 3. Create a brand-new conversation
  //    We won't actually create it in /multiuser/conversations here:
  //    Instead, we let the backend auto-create on first message.
  //    If you prefer to name your chat or do something else, you can do it here.
  function createNewChat() {
    currentConvId = null;  // We'll let the next user message auto-create it
    renderChat([]);        // Clear chat window
  }

  // 4. Send a message to /story/next_storybeat
  async function sendMessage() {
    const userInputElem = document.getElementById("userMsg");
    const userText = userInputElem.value.trim();
    userInputElem.value = "";
    if (!userText) return;

    // We'll pass conversation_id if we have one, else server will create a new one
    const payload = {
      user_input: userText,
      conversation_id: currentConvId, 
      player_name: "Chase" // or dynamic
    };

    try {
      const res = await fetch("/story/next_storybeat", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload)
      });
      const data = await res.json();

      if (!res.ok) {
        console.error("Server error:", data);
        return;
      }

      // Server always returns updated conversation_id + messages
      currentConvId = data.conversation_id; 
      const messages = data.messages || [];
      renderChat(messages);

      // If it's a brand-new conversation, let's refresh the list
      // so we see a new "New Chat" item appear if the server
      // named it that or if you have logic for conversation_name
      await loadConversations();

    } catch (err) {
      console.error("sendMessage error:", err);
    }
  }

  // 5. Render entire chat from the 'messages' array
  function renderChat(messages) {
    const chatWindow = document.getElementById("chatWindow");
    chatWindow.innerHTML = ""; // clear old

    messages.forEach(m => {
      const p = document.createElement("p");
      let senderName = (m.sender === "user") ? "You" : m.sender;
      p.innerHTML = `<strong>${senderName}:</strong> ${m.content}`;
      chatWindow.appendChild(p);
    });
    chatWindow.scrollTop = chatWindow.scrollHeight;
  }

</script>
</body>
</html>
