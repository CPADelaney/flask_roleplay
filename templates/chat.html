<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Roleplay Chat - Comprehensive</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      transition: background-color 0.3s, color 0.3s;
    }
    .dark-mode {
      background-color: #2c2c2c;
      color: #f0f0f0;
    }
    
    #topBar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid #ccc;
    }
    #topBar button {
      margin-right: 10px;
    }

    #chatContainer {
      display: flex;
      width: 100%;
      height: calc(100vh - 50px);
    }
    #leftPanel {
      width: 280px;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
    }
    #leftPanelInner {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
    }
    #convList button {
      width: 100%;
      text-align: left;
      margin-bottom: 5px;
      padding: 5px;
      cursor: pointer;
    }
    .inline-input {
      width: 65%;
      margin-right: 5px;
    }
    #chatPanel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    #chatWindow {
      flex: 1;
      border: 1px solid #ccc;
      margin: 10px;
      padding: 10px;
      overflow-y: auto;
      background-color: #fefefe;
      position: relative;
    }
    .message-bubble {
      max-width: 60%;
      margin-bottom: 10px;
      padding: 8px 12px;
      border-radius: 8px;
      display: inline-block;
      line-height: 1.4em;
      word-wrap: break-word;
    }
    .message-user {
      background-color: #007bff;
      color: white;
      align-self: flex-end;
      margin-left: 40%;
      text-align: right;
    }
    .message-gpt {
      background-color: #e5e5e5;
      color: #333;
      margin-right: 40%;
      text-align: left;
    }
    #loadMore {
      display: block;
      text-align: center;
      margin: 10px 0;
      cursor: pointer;
      color: #007bff;
    }
    #inputRow {
      margin: 10px;
      display: flex;
    }
    #userMsg {
      flex: 1;
      margin-right: 10px;
      padding: 8px;
    }
    #sendBtn {
      padding: 8px 16px;
      cursor: pointer;
    }
    .dark-mode #chatWindow {
      background-color: #3b3b3b;
    }
    .dark-mode .message-user {
      background-color: #375a7f;
    }
    .dark-mode .message-gpt {
      background-color: #666666;
      color: #f0f0f0;
    }
  </style>
</head>
<body>
<div id="topBar">
  <div>
    <button id="logoutBtn" onclick="logout()" style="display:none;">Logout</button>
  </div>
  <div>
    <button onclick="toggleDarkMode()">Toggle Dark Mode</button>
  </div>
</div>

<div id="chatContainer">
  <!-- LEFT PANEL: Conversation List & Controls -->
  <div id="leftPanel">
    <div id="leftPanelInner">
      <h3>Conversations</h3>
      <div>
        <input type="text" id="newConvName" class="inline-input" placeholder="Conversation name..."/>
        <button onclick="createConversation()">Create</button>
      </div>
      <div id="convList" style="margin-top:10px;"></div>
    </div>
  </div>

  <!-- MAIN CHAT PANEL -->
  <div id="chatPanel">
    <div id="chatWindow">
      <span id="loadMore" onclick="loadPreviousMessages()" style="display:none;">Load older messages...</span>
    </div>
    <div id="inputRow">
      <input type="text" id="userMsg" placeholder="Type your message"/>
      <button id="sendBtn" onclick="sendMessage()">Send</button>
    </div>
  </div>
</div>

<script>
  /*
    Global State
  */
  let currentConvId = null;
  let messagesOffset = 0;
  const MESSAGES_PER_LOAD = 20;

  // Dark mode flag
  let isDarkMode = false;

  window.onload = async function() {
    // 1) Check if user is logged in, else redirect
    await checkLoggedIn();

    // 2) Attach "Enter" key to send message
    attachEnterKey();

    // 3) Load dark mode from localStorage
    loadDarkModeFromStorage();

    // 4) Load conversation list
    await loadConversations();
  };

  /*
    1) Check if user is logged in by calling /whoami
  */
  async function checkLoggedIn() {
    try {
      const res = await fetch("/whoami");
      if (res.ok) {
        const data = await res.json();
        if (!data.logged_in) {
          window.location.href = "/login_page";
        } else {
          // Show logout button
          document.getElementById("logoutBtn").style.display = "inline-block";
        }
      } else {
        // Not logged in
        window.location.href = "/login_page";
      }
    } catch (err) {
      console.error("Check login error:", err);
      window.location.href = "/login_page";
    }
  }

  /*
    2) Attach "Enter" Key
  */
  function attachEnterKey() {
    const input = document.getElementById("userMsg");
    input.addEventListener("keydown", function(e) {
      if (e.key === "Enter") {
        e.preventDefault();
        sendMessage();
      }
    });
  }

  /*
    3) Dark Mode with localStorage
  */
  function loadDarkModeFromStorage() {
    const val = localStorage.getItem("dark_mode_enabled");
    if (val === "true") {
      isDarkMode = true;
      document.body.classList.add("dark-mode");
    } else {
      isDarkMode = false;
      document.body.classList.remove("dark-mode");
    }
  }

  function toggleDarkMode() {
    isDarkMode = !isDarkMode;
    localStorage.setItem("dark_mode_enabled", isDarkMode);
    if (isDarkMode) {
      document.body.classList.add("dark-mode");
    } else {
      document.body.classList.remove("dark-mode");
    }
  }

  /*
    4) Logout
  */
  async function logout() {
    try {
      const res = await fetch("/logout", { method: "POST" });
      if (res.ok) {
        window.location.href = "/login_page";
      } else {
        alert("Logout failed!");
      }
    } catch (err) {
      console.error("Logout error:", err);
    }
  }

  /*
    Conversation Management
  */
  async function loadConversations() {
    try {
      const res = await fetch("/multiuser/conversations");
      if (!res.ok) {
        console.error("Failed to get conversations:", res.status);
        return;
      }
      const convoData = await res.json(); // array of {id, name, created_at}
      renderConvoList(convoData);
    } catch (err) {
      console.error("Error loading conversations:", err);
    }
  }

  async function createConversation() {
    const convNameInput = document.getElementById("newConvName");
    const convName = convNameInput.value.trim();
    if (!convName) {
      alert("Please enter a conversation name!");
      return;
    }
    try {
      const res = await fetch("/multiuser/conversations", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ conversation_name: convName })
      });
      const data = await res.json();
      if (!res.ok) {
        alert("Error creating conversation: " + (data.error || res.status));
        return;
      }
      convNameInput.value = "";
      await loadConversations();
    } catch (err) {
      console.error("createConversation error:", err);
    }
  }

  function renderConvoList(conversations) {
    const convListDiv = document.getElementById("convList");
    convListDiv.innerHTML = "";

    conversations.forEach(conv => {
      const wrapper = document.createElement("div");
      wrapper.style.display = "flex";
      wrapper.style.marginBottom = "5px";

      // main button
      const btn = document.createElement("button");
      btn.textContent = conv.name;
      btn.onclick = () => selectConversation(conv.id);
      btn.style.flex = "1";

      // If you want rename/delete, add buttons here

      wrapper.appendChild(btn);
      convListDiv.appendChild(wrapper);
    });
  }

  async function selectConversation(convId) {
    currentConvId = convId;
    messagesOffset = 0; // reset pagination
    await loadMessages(convId, true);
  }

  async function loadMessages(convId, replace = false) {
    let url = `/multiuser/conversations/${convId}/messages?offset=${messagesOffset}&limit=${MESSAGES_PER_LOAD}`;
    try {
      const res = await fetch(url);
      if (!res.ok) {
        console.error("Failed to load messages for convo:", convId);
        return;
      }
      const data = await res.json(); // {messages: [...]}
      if (replace) {
        renderChat(data.messages);
      } else {
        prependMessages(data.messages);
      }
      document.getElementById("loadMore").style.display =
        data.messages.length < MESSAGES_PER_LOAD ? "none" : "block";
    } catch (err) {
      console.error("Error loading messages:", err);
    }
  }

  function renderChat(messages) {
    const chatWindow = document.getElementById("chatWindow");
    chatWindow.innerHTML = `<span id="loadMore" onclick="loadPreviousMessages()" style="display:none;">Load older messages...</span>`;
    messages.slice().reverse().forEach(msg => {
      appendMessage(msg, false);
    });
    chatWindow.scrollTop = chatWindow.scrollHeight;
  }

  function prependMessages(messages) {
    const chatWindow = document.getElementById("chatWindow");
    const loadMoreElem = document.getElementById("loadMore");
    messages.slice().reverse().forEach(msg => {
      const bubble = createBubble(msg);
      chatWindow.insertBefore(bubble, loadMoreElem.nextSibling);
    });
  }

  function loadPreviousMessages() {
    messagesOffset += MESSAGES_PER_LOAD;
    loadMessages(currentConvId, false);
  }

  function appendMessage(m, autoScroll = true) {
    const chatWindow = document.getElementById("chatWindow");
    const loadMoreElem = document.getElementById("loadMore");
    const bubble = createBubble(m);
    chatWindow.insertBefore(bubble, loadMoreElem.nextSibling);
    if (autoScroll) {
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }
  }

  function createBubble(m) {
    const bubble = document.createElement("div");
    bubble.classList.add("message-bubble");
    if (m.sender === "user") {
      bubble.classList.add("message-user");
    } else {
      bubble.classList.add("message-gpt");
    }
    bubble.innerHTML = `<strong>${m.sender}:</strong> ${m.content}`;
    return bubble;
  }

  /*
    Sending a new message
  */
  async function sendMessage() {
    const userInputElem = document.getElementById("userMsg");
    const userText = userInputElem.value.trim();
    userInputElem.value = "";
    if (!userText) return;
  
    // Combine the user’s typed text + our pending updates
    const payload = {
      user_input: userText,
      conversation_id: currentConvId,
      player_name: "Chase",
      // Optionally, if the user clicked “advance time”
      // advance_time: true,
      // Now pass our “pendingUniversalUpdates” object
      universal_update: pendingUniversalUpdates
    };
  
    try {
      const res = await fetch("/story/next_storybeat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const data = await res.json();
  
      if (!res.ok) {
        console.error("Server error:", data);
        alert("Message send failed!");
        return;
      }
  
      // If successful, clear or partially clear pending updates
      resetPendingUniversalUpdates();
  
      // Render the new chat state, etc.
      currentConvId = data.conversation_id;
      renderChat(data.messages);
    } catch (err) {
      console.error("sendMessage error:", err);
    }
  }
  
  function resetPendingUniversalUpdates() {
    // Maybe you want to clear everything after each send,
    // or only certain fields. It depends on your design.
    pendingUniversalUpdates = {
      npc_creations: [],
      npc_updates: [],
      // ...
    };
  }
      try {
        const res = await fetch("/story/next_storybeat", {
          method: "POST",
          headers: {"Content-Type": "application/json"},
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        if (!res.ok) {
          console.error("Server error:", data);
          alert("Message send failed!");
          return;
        }
        currentConvId = data.conversation_id;
        renderChat(data.messages);  // entire conversation
        await loadConversations();
      } catch (err) {
        console.error("sendMessage error:", err);
      }
    }
</script>
</body>
</html>
