<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Roleplay Chat - Comprehensive</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      transition: background-color 0.3s, color 0.3s;
    }
    .dark-mode {
      background-color: #2c2c2c;
      color: #f0f0f0;
    }
    
    #topBar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid #ccc;
    }
    #topBar button {
      margin-right: 10px;
    }

    #chatContainer {
      display: flex;
      width: 100%;
      height: calc(100vh - 50px);
    }
    #leftPanel {
      width: 280px;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
    }
    #leftPanelInner {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
    }
    #convList button {
      width: 100%;
      text-align: left;
      margin-bottom: 5px;
      padding: 5px;
      cursor: pointer;
    }
    .inline-input {
      width: 65%;
      margin-right: 5px;
    }
    #chatPanel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    #chatWindow {
      flex: 1;
      border: 1px solid #ccc;
      margin: 10px;
      padding: 10px;
      overflow-y: auto;
      background-color: #fefefe;
      position: relative;
    }
    .message-bubble {
      max-width: 60%;
      margin-bottom: 10px;
      padding: 8px 12px;
      border-radius: 8px;
      display: inline-block;
      line-height: 1.4em;
      word-wrap: break-word;
    }
    .message-user {
      background-color: #007bff;
      color: white;
      align-self: flex-end;
      margin-left: 40%;
      text-align: right;
    }
    .message-gpt {
      background-color: #e5e5e5;
      color: #333;
      margin-right: 40%;
      text-align: left;
    }
    #loadMore {
      display: block;
      text-align: center;
      margin: 10px 0;
      cursor: pointer;
      color: #007bff;
    }
    #inputRow {
      margin: 10px;
      display: flex;
    }
    #userMsg {
      flex: 1;
      margin-right: 10px;
      padding: 8px;
    }
    #sendBtn {
      padding: 8px 16px;
      cursor: pointer;
    }
    .dark-mode #chatWindow {
      background-color: #3b3b3b;
    }
    .dark-mode .message-user {
      background-color: #375a7f;
    }
    .dark-mode .message-gpt {
      background-color: #666666;
      color: #f0f0f0;
    }
  </style>
</head>
<body>
<div id="topBar">
  <div>
    <button id="logoutBtn" onclick="logout()" style="display:none;">Logout</button>
  </div>
  <div>
    <button onclick="toggleDarkMode()">Toggle Dark Mode</button>
  </div>
</div>

<div id="chatContainer">
  <!-- LEFT PANEL: Conversation List & Controls -->
  <div id="leftPanel">
    <div id="leftPanelInner">
      <h3>Conversations</h3>
      <div>
        <input type="text" id="newConvName" class="inline-input" placeholder="Conversation name..."/>
        <button onclick="createConversation()">Create</button>
      </div>
      <div id="convList" style="margin-top:10px;"></div>
    </div>
  </div>

  <!-- MAIN CHAT PANEL -->
  <div id="chatPanel">
    <div id="chatWindow">
      <span id="loadMore" onclick="loadPreviousMessages()" style="display:none;">Load older messages...</span>
    </div>
    <div id="inputRow">
      <input type="text" id="userMsg" placeholder="Type your message"/>
      <button id="sendBtn" onclick="sendMessage()">Send</button>
    </div>
  </div>
</div>

<script>
  /*
    Global State
  */
  let currentConvId = null;
  let messagesOffset = 0;
  const MESSAGES_PER_LOAD = 20;

  // Dark mode flag
  let isDarkMode = false;

  // ===============================
  // 1) "pendingUniversalUpdates"
  // This object includes ALL fields your universal_updater might expect.
  // You can fill them dynamically before sending a message.
  // ===============================
  let pendingUniversalUpdates = {
    // 1) Roleplay/Environment
    roleplay_updates: {},
    // 2) NPC Creations
    npc_creations: [],
    // 3) NPC Updates
    npc_updates: [],
    // 4) Character Stat Updates
    character_stat_updates: {
      player_name: "Chase",  // or dynamic
      stats: {}
    },
    // 5) Relationship Updates
    relationship_updates: [],
    // 6) NPC Introductions
    npc_introductions: [],
    // 7) Location Creations
    location_creations: [],
    // 8) event_list_updates
    event_list_updates: [],
    // 9) inventory_updates
    inventory_updates: {
      player_name: "Chase",  // or dynamic
      added_items: [],
      removed_items: []
    },
    // 10) quest_updates
    quest_updates: [],
    // 11) social_links
    social_links: [],
    // 12) perk_unlocks
    perk_unlocks: []
  };

  // Called after we successfully send a message
  function resetPendingUniversalUpdates() {
    // Resets all fields to empty arrays/objects so each new message starts fresh
    pendingUniversalUpdates = {
      roleplay_updates: {},
      npc_creations: [],
      npc_updates: [],
      character_stat_updates: {
        player_name: "Chase",
        stats: {}
      },
      relationship_updates: [],
      npc_introductions: [],
      location_creations: [],
      event_list_updates: [],
      inventory_updates: {
        player_name: "Chase",
        added_items: [],
        removed_items: []
      },
      quest_updates: [],
      social_links: [],
      perk_unlocks: []
    };
  }

  // On load
  window.onload = async function() {
    // 1) Check if user is logged in, else redirect
    await checkLoggedIn();

    // 2) Attach "Enter" key to send message
    attachEnterKey();

    // 3) Load dark mode from localStorage
    loadDarkModeFromStorage();

    // 4) Load conversation list
    await loadConversations();
  };

  // 1) Check if user is logged in by calling /whoami
  async function checkLoggedIn() {
    try {
      const res = await fetch("/whoami", {
        method: "GET",
        credentials: "include"  // <-- Ensures cookies are included
      });
      if (res.ok) {
        const data = await res.json();
        if (!data.logged_in) {
          window.location.href = "/login_page";
        } else {
          // Show logout button if we have one
          document.getElementById("logoutBtn").style.display = "inline-block";
        }
      } else {
        // If the response is not OK, e.g. 401 or 500, redirect to login
        window.location.href = "/login_page";
      }
    } catch (err) {
      console.error("Check login error:", err);
      // If there's an error fetching /whoami, assume not logged in
      window.location.href = "/login_page";
    }
  }

  // 2) Attach "Enter" Key
  function attachEnterKey() {
    const input = document.getElementById("userMsg");
    input.addEventListener("keydown", function(e) {
      if (e.key === "Enter") {
        e.preventDefault();
        sendMessage();
      }
    });
  }

  // 3) Dark Mode with localStorage
  function loadDarkModeFromStorage() {
    const val = localStorage.getItem("dark_mode_enabled");
    if (val === "true") {
      isDarkMode = true;
      document.body.classList.add("dark-mode");
    } else {
      isDarkMode = false;
      document.body.classList.remove("dark-mode");
    }
  }

  function toggleDarkMode() {
    isDarkMode = !isDarkMode;
    localStorage.setItem("dark_mode_enabled", isDarkMode);
    if (isDarkMode) {
      document.body.classList.add("dark-mode");
    } else {
      document.body.classList.remove("dark-mode");
    }
  }

  // 4) Logout
  async function logout() {
    try {
      const res = await fetch("/logout", { method: "POST" });
      if (res.ok) {
        window.location.href = "/login_page";
      } else {
        alert("Logout failed!");
      }
    } catch (err) {
      console.error("Logout error:", err);
    }
  }

  // Conversation Management
  async function loadConversations() {
    try {
      const res = await fetch("/multiuser/conversations");
      if (!res.ok) {
        console.error("Failed to get conversations:", res.status);
        return;
      }
      const convoData = await res.json(); // array of {id, name, created_at}
      renderConvoList(convoData);
    } catch (err) {
      console.error("Error loading conversations:", err);
    }
  }

  async function createConversation() {
    const convNameInput = document.getElementById("newConvName");
    const convName = convNameInput.value.trim();
    if (!convName) {
      alert("Please enter a conversation name!");
      return;
    }
    try {
      const res = await fetch("/multiuser/conversations", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ conversation_name: convName })
      });
      const data = await res.json();
      if (!res.ok) {
        alert("Error creating conversation: " + (data.error || res.status));
        return;
      }
      convNameInput.value = "";
      await loadConversations();
    } catch (err) {
      console.error("createConversation error:", err);
    }
  }

  function renderConvoList(conversations) {
    const convListDiv = document.getElementById("convList");
    convListDiv.innerHTML = "";

    conversations.forEach(conv => {
      const wrapper = document.createElement("div");
      wrapper.style.display = "flex";
      wrapper.style.marginBottom = "5px";

      // main button
      const btn = document.createElement("button");
      btn.textContent = conv.name;
      btn.onclick = () => selectConversation(conv.id);
      btn.style.flex = "1";

      wrapper.appendChild(btn);
      convListDiv.appendChild(wrapper);
    });
  }

  async function selectConversation(convId) {
    currentConvId = convId;
    messagesOffset = 0; // reset pagination
    await loadMessages(convId, true);
  }

  async function loadMessages(convId, replace = false) {
    let url = `/multiuser/conversations/${convId}/messages?offset=${messagesOffset}&limit=${MESSAGES_PER_LOAD}`;
    try {
      const res = await fetch(url);
      if (!res.ok) {
        console.error("Failed to load messages for convo:", convId);
        return;
      }
      const data = await res.json(); // {messages: [...]}
      if (replace) {
        renderChat(data.messages);
      } else {
        prependMessages(data.messages);
      }
      document.getElementById("loadMore").style.display =
        data.messages.length < MESSAGES_PER_LOAD ? "none" : "block";
    } catch (err) {
      console.error("Error loading messages:", err);
    }
  }

  function renderChat(messages) {
    const chatWindow = document.getElementById("chatWindow");
    chatWindow.innerHTML = `<span id="loadMore" onclick="loadPreviousMessages()" style="display:none;">Load older messages...</span>`;
    messages.slice().reverse().forEach(msg => {
      appendMessage(msg, false);
    });
    chatWindow.scrollTop = chatWindow.scrollHeight;
  }

  function prependMessages(messages) {
    const chatWindow = document.getElementById("chatWindow");
    const loadMoreElem = document.getElementById("loadMore");
    messages.slice().reverse().forEach(msg => {
      const bubble = createBubble(msg);
      chatWindow.insertBefore(bubble, loadMoreElem.nextSibling);
    });
  }

  function loadPreviousMessages() {
    messagesOffset += MESSAGES_PER_LOAD;
    loadMessages(currentConvId, false);
  }

  function appendMessage(m, autoScroll = true) {
    const chatWindow = document.getElementById("chatWindow");
    const loadMoreElem = document.getElementById("loadMore");
    const bubble = createBubble(m);
    chatWindow.insertBefore(bubble, loadMoreElem.nextSibling);
    if (autoScroll) {
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }
  }

  function createBubble(m) {
    const bubble = document.createElement("div");
    bubble.classList.add("message-bubble");
    if (m.sender === "user") {
      bubble.classList.add("message-user");
    } else {
      bubble.classList.add("message-gpt");
    }
    bubble.innerHTML = `<strong>${m.sender}:</strong> ${m.content}`;
    return bubble;
  }

  /*
    Sending a new message
  */
  async function sendMessage() {
    const userInputElem = document.getElementById("userMsg");
    const userText = userInputElem.value.trim();
    userInputElem.value = "";
    if (!userText) return;

    // For demonstration, let's say we forcibly set Obedience=80 each time,
    // or add a new item to the inventory, just to show usage:
    pendingUniversalUpdates.character_stat_updates.stats.obedience = 80;
    pendingUniversalUpdates.inventory_updates.added_items.push("Chains of Submission");
    
    // Build the final payload
    const payload = {
      user_input: userText,
      conversation_id: currentConvId,
      player_name: "Chase",
      // e.g. if a user clicked “advance time” somewhere:
      // advance_time: true,
      // The important part:
      universal_update: pendingUniversalUpdates
    };
  
    try {
      const res = await fetch("/story/next_storybeat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const data = await res.json();
  
      if (!res.ok) {
        console.error("Server error:", data);
        alert("Message send failed!");
        return;
      }

      // Clear or partially clear the pending updates
      resetPendingUniversalUpdates();
  
      // Refresh chat
      currentConvId = data.conversation_id;
      renderChat(data.messages);

      // Optionally refresh conv list in case it changed
      await loadConversations();

    } catch (err) {
      console.error("sendMessage error:", err);
    }
  }
</script>
</body>
</html>
