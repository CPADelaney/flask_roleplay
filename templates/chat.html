<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Roleplay Chat - Comprehensive</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      transition: background-color 0.3s, color 0.3s;
    }
    .dark-mode {
      background-color: #2c2c2c;
      color: #f0f0f0;
    }
    #topBar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid #ccc;
    }
    #topBar button {
      margin-right: 10px;
    }
    #chatContainer {
      display: flex;
      width: 100%;
      height: calc(100vh - 50px);
    }
    #leftPanel {
      width: 280px;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
    }
    #leftPanelInner {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
    }
    #convList button {
      width: 100%;
      text-align: left;
      margin-bottom: 5px;
      padding: 5px;
      cursor: pointer;
    }
    .inline-input {
      width: 65%;
      margin-right: 5px;
    }
    #chatPanel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    #chatWindow {
      flex: 1;
      border: 1px solid #ccc;
      margin: 10px;
      padding: 10px;
      overflow-y: auto;
      background-color: #fefefe;
      position: relative;
      scroll-behavior: smooth;
    }
    .message-row {
      display: flex;
      margin-bottom: 10px;
    }
    .message-bubble {
      max-width: 60%;
      padding: 8px 12px;
      border-radius: 8px;
      line-height: 1.4em;
      word-wrap: break-word;
      position: relative;
    }
    .timestamp {
      font-size: 0.7em;
      color: #666;
      margin-top: 4px;
      text-align: right;
    }
    /* User message alignment */
    .user-row {
      justify-content: flex-end;
    }
    .user-row .message-bubble {
      background-color: #007bff;
      color: #ffffff;
    }
    /* GPT message alignment */
    .gpt-row {
      justify-content: flex-start;
    }
    .gpt-row .message-bubble {
      background-color: #e5e5e5;
      color: #333333;
    }
    /* Spinner for typing indicator */
    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(0,0,0,0.3);
      border-top-color: #000;
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
      vertical-align: middle;
      margin-left: 5px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #loadMore {
      display: block;
      text-align: center;
      margin: 10px 0;
      cursor: pointer;
      color: #007bff;
    }
    #inputRow {
      margin: 10px;
      display: flex;
    }
    #userMsg {
      flex: 1;
      margin-right: 10px;
      padding: 8px;
    }
    #sendBtn {
      padding: 8px 16px;
      cursor: pointer;
    }
    .dark-mode #chatWindow {
      background-color: #3b3b3b;
    }
    .dark-mode .message-user {
      background-color: #375a7f;
    }
    .dark-mode .message-gpt {
      background-color: #666666;
      color: #f0f0f0;
    }
    /* Context Menu styling */
    #contextMenu {
      position: absolute;
      display: none;
      border: 1px solid #ccc;
      background: #fff;
      z-index: 999;
    }
    #contextMenu div {
      padding: 5px;
      cursor: pointer;
    }
    #contextMenu div:hover {
      background-color: #eee;
    }
    .dark-mode #contextMenu {
      background-color: #333;
      color: #fff;
      border: 1px solid #999;
    }
    .dark-mode #contextMenu div:hover {
      background-color: #444;
    }
  </style>

  <!-- MARKDOWN + DOMPurify Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>

</head>
<body>
<div id="topBar">
  <div>
    <button id="logoutBtn" onclick="logout()" style="display:none;">Logout</button>
  </div>
  <div>
    <button onclick="toggleDarkMode()">Toggle Dark Mode</button>
  </div>
</div>

<div id="chatContainer">
  <!-- LEFT PANEL: Conversation List & Controls -->
  <div id="leftPanel">
    <div id="leftPanelInner">
      <h3>Conversations</h3>
      <div>
        <button type="button" onclick="startNewGame()">New Game</button>
      </div>
      <div id="convList" style="margin-top:10px;"></div>
    </div>
  </div>

  <!-- MAIN CHAT PANEL -->
  <div id="chatPanel">
    <div id="chatWindow" role="log" aria-live="polite">
      <span id="loadMore" onclick="loadPreviousMessages()" style="display:none;">Load older messages...</span>
    </div>
    <div id="inputRow">
      <input type="text" id="userMsg" placeholder="Type your message" aria-label="Chat message"/>
      <button id="sendBtn" onclick="sendMessage()">Send</button>
    </div>
  </div>
</div>

<!-- Custom context menu -->
<div id="contextMenu"></div>

<script>
  function sanitizeAndRenderMarkdown(markdownText) {
    const renderedHTML = marked.parse(markdownText);
    return DOMPurify.sanitize(renderedHTML);
  }

  let currentConvId = null;
  let messagesOffset = 0;
  const MESSAGES_PER_LOAD = 20;
  let isDarkMode = false;

  let pendingUniversalUpdates = {
    roleplay_updates: {},
    npc_creations: [],
    npc_updates: [],
    character_stat_updates: {
      player_name: "Chase",
      stats: {}
    },
    relationship_updates: [],
    npc_introductions: [],
    location_creations: [],
    event_list_updates: [],
    inventory_updates: {
      player_name: "Chase",
      added_items: [],
      removed_items: []
    },
    quest_updates: [],
    social_links: [],
    perk_unlocks: []
  };

  function resetPendingUniversalUpdates() {
    pendingUniversalUpdates = {
      roleplay_updates: {},
      npc_creations: [],
      npc_updates: [],
      character_stat_updates: {
        player_name: "Chase",
        stats: {}
      },
      relationship_updates: [],
      npc_introductions: [],
      location_creations: [],
      event_list_updates: [],
      inventory_updates: {
        player_name: "Chase",
        added_items: [],
        removed_items: []
      },
      quest_updates: [],
      social_links: [],
      perk_unlocks: []
    };
  }

  window.onload = async function() {
    await checkLoggedIn();
    attachEnterKey();
    loadDarkModeFromStorage();
    await loadConversations();
  };

  async function pollConversationStatus(convId) {
    const POLL_INTERVAL = 5000;
    const MAX_POLL_ATTEMPTS = 30;
    let attempts = 0;
  
    const intervalId = setInterval(() => {
      (async () => {
        try {
          const res = await fetch(`/conversation_status?conversation_id=${convId}`, {
            method: "GET",
            credentials: "include"
          });
          if (!res.ok) {
            console.error("Failed to fetch conversation status:", res.status);
            return;
          }
          const data = await res.json();
          console.log("Polled conversation status:", data);
  
          if (data.status === "ready") {
            clearInterval(intervalId);
            console.log("Conversation is ready. Refreshing messages...");
            await loadMessages(convId, true);
          } else {
            attempts++;
            if (attempts >= MAX_POLL_ATTEMPTS) {
              clearInterval(intervalId);
              console.warn("Polling timed out; conversation is still not ready.");
            }
          }
        } catch (err) {
          console.error("Error polling conversation status:", err);
        }
      })();
    }, POLL_INTERVAL);
  }

  async function checkLoggedIn() {
    try {
      const res = await fetch("/whoami", {
        method: "GET",
        credentials: "include"
      });
      if (res.ok) {
        const data = await res.json();
        if (!data.logged_in) {
          window.location.href = "/login_page";
        } else {
          document.getElementById("logoutBtn").style.display = "inline-block";
        }
      } else {
        window.location.href = "/login_page";
      }
    } catch (err) {
      console.error("Check login error:", err);
      window.location.href = "/login_page";
    }
  }

  function attachEnterKey() {
    const input = document.getElementById("userMsg");
    input.addEventListener("keydown", function(e) {
      if (e.key === "Enter") {
        e.preventDefault();
        sendMessage();
      }
    });
  }

  function loadDarkModeFromStorage() {
    const val = localStorage.getItem("dark_mode_enabled");
    if (val === "true") {
      isDarkMode = true;
      document.body.classList.add("dark-mode");
    } else {
      isDarkMode = false;
      document.body.classList.remove("dark-mode");
    }
  }

  function toggleDarkMode() {
    isDarkMode = !isDarkMode;
    localStorage.setItem("dark_mode_enabled", isDarkMode);
    if (isDarkMode) {
      document.body.classList.add("dark-mode");
    } else {
      document.body.classList.remove("dark-mode");
    }
  }

  async function logout() {
    try {
      const res = await fetch("/logout", {
        method: "POST",
        credentials: "include"
      });
      if (res.ok) {
        window.location.href = "/login_page";
      } else {
        alert("Logout failed!");
      }
    } catch (err) {
      console.error("Logout error:", err);
    }
  }

  async function loadConversations() {
    try {
      const res = await fetch("/multiuser/conversations", {
        method: "GET",
        credentials: "include"
      });
      if (!res.ok) {
        console.error("Failed to get conversations:", res.status);
        return;
      }
      const convoData = await res.json();
      renderConvoList(convoData);
    } catch (err) {
      console.error("Error loading conversations:", err);
    }
  }

  async function startNewGame() {
    try {
      const res = await fetch("/start_new_game", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({})
      });
      const data = await res.json();
  
      if (!res.ok) {
        alert("Error starting new game: " + (data.error || res.status));
        return;
      }
  
      currentConvId = data.conversation_id;
      alert("New game started! conversation_id=" + currentConvId);
  
      await loadConversations();
      selectConversation(currentConvId);
  
      pollConversationStatus(currentConvId);
      
    } catch (err) {
      console.error("startNewGame error:", err);
      alert("Failed to start new game!");
    }
  }

  function renderConvoList(conversations) {
    const convListDiv = document.getElementById("convList");
    convListDiv.innerHTML = "";

    conversations.forEach(conv => {
      const wrapper = document.createElement("div");
      wrapper.style.display = "flex";
      wrapper.style.marginBottom = "5px";

      const btn = document.createElement("button");
      btn.textContent = conv.name || "New Chat";
      btn.style.flex = "1";

      btn.onclick = () => selectConversation(conv.id);
      btn.oncontextmenu = (e) => {
        e.preventDefault();
        showContextMenu(e.clientX, e.clientY, conv.id);
      };

      wrapper.appendChild(btn);
      convListDiv.appendChild(wrapper);
    });
  }

  async function selectConversation(convId) {
    currentConvId = convId;
    messagesOffset = 0;
    await loadMessages(convId, true);
  }

  async function loadMessages(convId, replace = false) {
    const url = `/multiuser/conversations/${convId}/messages?offset=${messagesOffset}&limit=${MESSAGES_PER_LOAD}`;
    try {
      const res = await fetch(url, {
        method: "GET",
        credentials: "include"
      });
      if (!res.ok) {
        console.error("Failed to load messages for convo:", convId, res.status);
        return;
      }
      const data = await res.json();
      console.log("Loaded messages data:", data);
      
      // Adjust: if the endpoint returns an array directly, use that; otherwise, assume it's under data.messages.
      let messages;
      if (Array.isArray(data)) {
          messages = data;
      } else if (Array.isArray(data.messages)) {
          messages = data.messages;
      } else {
          console.error("Unexpected message format:", data);
          messages = [];
      }
      
      if (replace) {
          renderChat(messages);
      } else {
          prependMessages(messages);
      }
      
      document.getElementById("loadMore").style.display =
          messages.length < MESSAGES_PER_LOAD ? "none" : "block";
    } catch (err) {
      console.error("Error loading messages:", err);
    }
  }

  function renderChat(messages) {
    const chatWindow = document.getElementById("chatWindow");
    chatWindow.innerHTML = `<span id="loadMore" onclick="loadPreviousMessages()" style="display:none;">Load older messages...</span>`;
    messages.slice().forEach(msg => {
      appendMessage(msg, false);
    });
    chatWindow.scrollTop = chatWindow.scrollHeight;
  }

  function prependMessages(messages) {
    const chatWindow = document.getElementById("chatWindow");
    const loadMoreElem = document.getElementById("loadMore");
    messages.forEach(msg => {
      const bubble = createBubble(msg);
      chatWindow.insertBefore(bubble, loadMoreElem.nextSibling);
    });
  }

  function loadPreviousMessages() {
    messagesOffset += MESSAGES_PER_LOAD;
    loadMessages(currentConvId, false);
  }

  function createBubble(m) {
    const row = document.createElement("div");
    row.classList.add("message-row");
    row.classList.add(m.sender === "user" ? "user-row" : "gpt-row");

    const bubble = document.createElement("div");
    bubble.classList.add("message-bubble");
    const safeContent = sanitizeAndRenderMarkdown(m.content);
    bubble.innerHTML = `<strong>${m.sender}:</strong> ${safeContent}`;

    // Add timestamp (if not provided, use current time)
    const timestamp = document.createElement("div");
    timestamp.classList.add("timestamp");
    const time = m.created_at ? new Date(m.created_at) : new Date();
    timestamp.textContent = time.toLocaleTimeString();
    bubble.appendChild(timestamp);

    row.appendChild(bubble);
    return row;
  }

  async function sendMessage() {
    const userInputElem = document.getElementById("userMsg");
    const userText = userInputElem.value.trim();
    userInputElem.value = "";
    if (!userText) return;

    appendMessage({ sender: "user", content: userText }, true);

    // Disable send button while waiting
    const sendBtn = document.getElementById("sendBtn");
    sendBtn.disabled = true;

    // Show an animated spinner for GPT response
    const tempGptMsgObj = { sender: "Nyx", content: "Typing" };
    const gptTypingBubble = appendMessage(tempGptMsgObj, true);
    // Append a spinner element into the bubble
    const spinner = document.createElement("span");
    spinner.classList.add("spinner");
    gptTypingBubble.querySelector(".message-bubble").appendChild(spinner);

    const payload = {
      user_input: userText,
      conversation_id: currentConvId,
      player_name: "Chase",
      universal_update: pendingUniversalUpdates,
    };

    try {
      const res = await fetch("/story/next_storybeat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify(payload),
      });
      const data = await res.json();

      if (!res.ok) {
        console.error("Server error:", data);
        alert("Message send failed!");
        gptTypingBubble.innerHTML = `<strong>Nyx:</strong> [Error retrieving response]`;
        sendBtn.disabled = false;
        return;
      }

      resetPendingUniversalUpdates();
      currentConvId = data.conversation_id;

      // Remove the temporary typing bubble and spinner
      gptTypingBubble.remove();

      const realGptMsgObj = {
        sender: "Nyx",
        content: data.response || "(No response?)",
      };
      appendMessage(realGptMsgObj, true);
      await loadConversations();
    } catch (err) {
      console.error("sendMessage error:", err);
      gptTypingBubble.innerHTML = `<strong>Nyx:</strong> [Error retrieving response]`;
    } finally {
      sendBtn.disabled = false;
    }
  }

  // Context menu functionality
  const menuDiv = document.getElementById("contextMenu");
  function showContextMenu(x, y, convId) {
    menuDiv.innerHTML = `
      <div onclick="renameConversation(${convId})">Rename</div>
      <div onclick="moveConversationToFolder(${convId})">Move to Folder</div>
      <div onclick="deleteConversation(${convId})">Delete</div>
    `;
    menuDiv.style.left = x + "px";
    menuDiv.style.top = y + "px";
    menuDiv.style.display = "block";
  }
  document.addEventListener("click", () => { menuDiv.style.display = "none"; });

  async function renameConversation(convId) {
    const newName = prompt("Enter new conversation name:");
    if (!newName) return;
    try {
      const res = await fetch("/multiuser/conversations/" + convId, {
        method: "PUT",
        headers: {"Content-Type": "application/json"},
        credentials: "include",
        body: JSON.stringify({ conversation_name: newName })
      });
      if (res.ok) {
        await loadConversations();
      } else {
        alert("Error renaming conversation");
      }
    } catch (err) {
      console.error(err);
    }
  }

  async function moveConversationToFolder(convId) {
    const folderName = prompt("Which folder name? (It will be created if it doesn't exist)");
    if (!folderName) return;
    try {
      const res = await fetch(`/multiuser/conversations/${convId}/move_folder`, {
        method: "POST",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ folder_name: folderName })
      });
      if (res.ok) {
        await loadConversations();
      } else {
        alert("Error moving conversation");
      }
    } catch (err) {
      console.error(err);
    }
  }

  async function deleteConversation(convId) {
    if (!confirm("Really delete this conversation?")) return;
    try {
      const res = await fetch("/multiuser/conversations/" + convId, {
        method: "DELETE",
        credentials: "include"
      });
      if (res.ok) {
        await loadConversations();
      } else {
        alert("Error deleting conversation");
      }
    } catch (err) {
      console.error(err);
    }
  }
</script>
</body>
</html>
