# logic/npc_agents/npc_agents_sdk.py

import asyncio
import json
import logging
import random
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional, Union, Tuple, Set

from agents import (
    Agent, Runner, function_tool, ModelSettings, trace, 
    InputGuardrail, GuardrailFunctionOutput, handoff, RunContext, AgentHooks
)
from pydantic import BaseModel, Field

# Import from existing modules
from db.connection import get_db_connection
from memory.wrapper import MemorySystem
from memory.core import MemorySignificance, MemoryType
from memory.masks import ProgressiveRevealManager

# Configure logging
logger = logging.getLogger(__name__)

# ------------------------------
# Configuration Management
# ------------------------------
class GPTClient:
    """
    A small helper class to centralize GPT calls.
    You can expand this with caching, concurrency handling, error checks, etc.
    """

    @staticmethod
    async def call_gpt(
        system_prompt: str,
        user_prompt: str,
        model: str = "gpt-3.5-turbo",
        temperature: float = 0.7,
        max_tokens: int = 512,
    ) -> str:
        """
        Basic wrapper for an OpenAI ChatCompletion call returning raw text.
        """
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt},
        ]
        try:
            response = openai.ChatCompletion.create(
                model=model,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens,
            )
            return response["choices"][0]["message"]["content"].strip()
        except Exception as e:
            logger.error(f"GPT error: {e}")
            return ""  # fallback

    @staticmethod
    async def call_gpt_for_json(
        system_prompt: str,
        user_prompt: str,
        model: str = "gpt-3.5-turbo",
        temperature: float = 0.7,
        max_tokens: int = 512,
    ) -> Dict[str, Any]:
        """
        Wrapper that requests JSON output from GPT, then tries to parse it.
        """
        raw = await GPTClient.call_gpt(system_prompt, user_prompt, model, temperature, max_tokens)
        raw_stripped = raw.strip().strip("```").strip()
        try:
            return json.loads(raw_stripped)
        except Exception:
            logger.warning("Couldn't parse GPT response as JSON. Returning empty.")
            return {}

class NPCConfig:
    """Central configuration for NPC system with sensible defaults."""
    
    # Cache TTLs in minutes
    CACHE_TTL = {
        'perception': 5,
        'memories': 10,
        'relationships': 15,
        'emotional_state': 2,
        'mask': 5,
        'beliefs': 10
    }
    
    # Probability thresholds
    PROBABILITY = {
        'emotional_contagion_base': 0.3,
        'mask_slip_base': 0.2,
        'flashback_chance': 0.15,
        'flashback_with_trauma': 0.5,
        'decision_randomness': 0.2
    }
    
    # Performance limits
    LIMITS = {
        'group_interaction_max_npcs': 5,
        'memory_recall_default': 5,
        'memory_recall_important': 10,
        'relationship_history_length': 20
    }
    
    # AI Model settings
    MODEL = {
        'coordinator': 'gpt-4o',
        'default': 'claude-3-5-sonnet',
        'temperature_default': 0.7,
        'temperature_consistent': 0.5,
        'temperature_creative': 0.85
    }
    
    # Maintenance settings
    MAINTENANCE = {
        'cycle_minutes': 30,
        'relationship_decay_days': 1,
        'emotion_decay_amount': 0.15,
        'mask_recovery_amount': 5
    }
    
    @classmethod
    def get_cache_ttl(cls, cache_type: str) -> timedelta:
        """Get cache TTL for the specified type."""
        minutes = cls.CACHE_TTL.get(cache_type, 5)  # Default 5 minutes
        return timedelta(minutes=minutes)
    
    @classmethod
    def get_model_settings(cls, personality_type: str = None) -> ModelSettings:
        """Get model settings based on personality type."""
        if personality_type == "dominant" or personality_type == "cruel":
            # These personalities need more consistent behavior
            return ModelSettings(
                name=cls.MODEL['default'],
                temperature=cls.MODEL['temperature_consistent']
            )
        elif personality_type == "creative" or personality_type == "eccentric":
            # These personalities benefit from more randomness
            return ModelSettings(
                name=cls.MODEL['default'],
                temperature=cls.MODEL['temperature_creative']
            )
        else:
            # Default settings
            return ModelSettings(
                name=cls.MODEL['default'],
                temperature=cls.MODEL['temperature_default']
            )

# ------------------------------
# Base Models
# ------------------------------
class NPCAgent:
    """Main interface for an individual NPC with integrated capabilities."""

    def __init__(self, npc_id: int, user_id: int, conversation_id: int):
        self.npc_id = npc_id
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = CacheManager()

        self.memory_manager = MemoryManager(user_id, conversation_id, self.cache_manager)
        self.emotion_manager = EmotionManager(user_id, conversation_id, self.cache_manager)
        self.mask_manager = MaskManager(user_id, conversation_id, self.cache_manager)
        self.perception_manager = PerceptionManager(user_id, conversation_id, self.cache_manager)
        self.goal_manager = GoalManager(user_id, conversation_id, self.cache_manager)
        self.decision_engine = DecisionEngine(user_id, conversation_id, self.cache_manager)
        self.action_executor = ActionExecutor(user_id, conversation_id, self.cache_manager)
        self.hooks = NPCAgentHooks(npc_id, user_id, conversation_id)

    async def perceive_environment(self, context: Dict[str, Any]) -> Dict[str, Any]:
        return await self.perception_manager.perceive_environment_detailed(self.npc_id, context)

    async def process_player_action(self, action: Dict[str, Any], context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Example chain:
         1) store memory
         2) GPT or numeric emotion
         3) GPT-based decide
         4) GPT-based execute
        """
        processor = PlayerActionProcessor(
            self.user_id, self.conversation_id, self.cache_manager,
            self.decision_engine, self.action_executor
        )
        return await processor.process_player_action(self.npc_id, action, context)

    async def make_decision(self, perception: Dict[str, Any], available_actions: Optional[List[Dict[str, Any]]] = None) -> Dict[str, Any]:
        return await self.decision_engine.decide_gpt(self.npc_id, perception, available_actions)

    async def execute_action(self, action: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        return await self.action_executor.execute_action_gpt(self.npc_id, action, context)

    async def run_maintenance(self) -> Dict[str, Any]:
        memory_result = await self.memory_manager.run_memory_maintenance(self.npc_id)
        emotion_result = await self.emotion_manager.process_emotional_decay(self.npc_id)
        mask_result = await self.mask_manager.evolve_mask_integrity(self.npc_id)
        return {
            "memory_maintenance": memory_result,
            "emotional_decay": emotion_result,
            "mask_evolution": mask_result
        }

class NPCAgentSystem:
    """Central system for managing multiple NPC agents and their interactions."""

    def __init__(self, user_id: int, conversation_id: int, connection_pool):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.connection_pool = connection_pool
        self.cache_manager = CacheManager()
        self.npc_agents = {}
        self.group_handler = GroupInteractionHandler(user_id, conversation_id, self.cache_manager)
        self._last_maintenance = datetime.now() - timedelta(hours=1)

    async def initialize_agents(self) -> None:
        """Initialize NPCAgent objects for all NPCs in the conversation."""
        try:
            async with self.connection_pool.acquire() as conn:
                query = """
                    SELECT npc_id
                    FROM NPCStats
                    WHERE user_id=$1
                      AND conversation_id=$2
                """
                rows = await conn.fetch(query, self.user_id, self.conversation_id)

                for row in rows:
                    npc_id = row["npc_id"]
                    self.npc_agents[npc_id] = NPCAgent(npc_id, self.user_id, self.conversation_id)

                logger.info(f"Loaded {len(self.npc_agents)} NPC agents")
        except Exception as e:
            logger.error(f"Error initializing agents: {e}")
            raise
    
    async def handle_player_action(self, player_action: Dict[str, Any], context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Handle a player action and determine NPC responses."""
        if context is None:
            context = {}
        
        # Determine which NPCs are affected by the action
        affected_npcs = await self.determine_affected_npcs(player_action, context)
        
        if not affected_npcs:
            return {"npc_responses": []}
        
        # Single NPC path
        if len(affected_npcs) == 1:
            npc_id = affected_npcs[0]
            agent = self.npc_agents.get(npc_id)
            if not agent:
                agent = NPCAgent(npc_id, self.user_id, self.conversation_id)
                self.npc_agents[npc_id] = agent
                
            response = await agent.process_player_action(player_action, context)
            return {"npc_responses": [response]}
        
        # Multiple NPCs => group logic
        return await self.handle_group_npc_interaction(affected_npcs, player_action, context)

    async def process_scheduled_activities(self) -> Dict[str, Any]:
        """Process scheduled activities for all NPCs."""
        logger.info("Processing scheduled activities")
        
        try:
            # Get current game time
            year, month, day, time_of_day = await self.get_current_game_time()
            
            base_context = {
                "year": year,
                "month": month,
                "day": day,
                "time_of_day": time_of_day,
                "activity_type": "scheduled"
            }
            
            # Fetch all NPCs with their data
            npc_data = await self._fetch_all_npc_data_for_activities()
            total_npcs = len(npc_data)
            
            if total_npcs == 0:
                return {"npc_responses": [], "count": 0}
            
            # Process activities in batches
            batch_size = 20
            npc_responses = []
            
            for i in range(0, total_npcs, batch_size):
                batch = list(npc_data.items())[i:i + batch_size]
                batch_tasks = []
                
                for npc_id, data in batch:
                    batch_tasks.append(self._process_single_npc_activity(npc_id, data, base_context))
                
                batch_results = await asyncio.gather(*batch_tasks, return_exceptions=True)
                
                for result in batch_results:
                    if isinstance(result, Exception):
                        logger.error(f"Error processing scheduled activity: {result}")
                    elif result:
                        npc_responses.append(result)
            
            # Process group coordination activities
            agent_responses = await self._process_coordination_activities(base_context)
            
            return {
                "npc_responses": npc_responses,
                "agent_system_responses": agent_responses,
                "count": len(npc_responses) + len(agent_responses)
            }
            
        except Exception as e:
            logger.error(f"Error processing NPC scheduled activities: {e}")
            raise

    async def batch_update_npcs(self, npc_ids: List[int], update_type: str, update_data: Dict[str, Any]) -> Dict[str, Any]:
        """Update multiple NPCs in a single batch operation."""
        results = {
            "success_count": 0,
            "error_count": 0,
            "details": {}
        }
        
        # Ensure all NPCs are loaded
        for npc_id in npc_ids:
            if npc_id not in self.npc_agents:
                self.npc_agents[npc_id] = NPCAgent(npc_id, self.user_id, self.conversation_id)
        
        if update_type == "location_change":
            # Handle location update
            new_location = update_data.get("new_location")
            if not new_location:
                return {"error": "No location specified"}
            
            # Use transaction to update all NPCs
            async with self.connection_pool.acquire() as conn:
                async with conn.transaction():
                    rows = await conn.fetch(
                        """
                        UPDATE NPCStats
                        SET current_location = $1
                        WHERE npc_id = ANY($2)
                          AND user_id = $3
                          AND conversation_id = $4
                        RETURNING npc_id
                        """,
                        new_location, npc_ids, self.user_id, self.conversation_id
                    )
                    
                    results["success_count"] = len(rows)
                    results["updated_npcs"] = [r["npc_id"] for r in rows]
                    
                    # Invalidate perception caches
                    for npc_id in results["updated_npcs"]:
                        self.npc_agents[npc_id].cache_manager.invalidate('perception')
        
        elif update_type == "emotional_update":
            # Handle emotional state update
            emotion = update_data.get("emotion")
            intensity = update_data.get("intensity", 0.5)
            
            if not emotion:
                return {"error": "No emotion specified"}
            
            # Process in parallel using tasks
            batch_size = 5
            for i in range(0, len(npc_ids), batch_size):
                batch = npc_ids[i:i + batch_size]
                batch_tasks = []
                
                for npc_id in batch:
                    task = self.npc_agents[npc_id].emotion_manager.update_emotion(
                        npc_id=npc_id,
                        emotion=emotion,
                        intensity=intensity
                    )
                    batch_tasks.append(task)
                
                batch_results = await asyncio.gather(*batch_tasks, return_exceptions=True)
                
                # Process results
                for npc_id, result in zip(batch, batch_results):
                    if isinstance(result, Exception):
                        results["error_count"] += 1
                        results["details"][npc_id] = {"error": str(result)}
                    else:
                        results["success_count"] += 1
                        results["details"][npc_id] = {"success": True}
        
        return results

class PlayerAction(BaseModel):
    """Structured representation of a player's action."""
    type: str = Field(..., description="The type of action (e.g., 'talk', 'move', 'attack')")
    description: str = Field(..., description="Description of the action")
    target_npc_id: Optional[int] = Field(None, description="ID of the target NPC, if applicable")
    target_location: Optional[str] = Field(None, description="Target location, if applicable")
    intensity: Optional[float] = Field(0.5, description="Intensity of the action (0.0-1.0)")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")

class NPCAction(BaseModel):
    """Structured representation of an NPC's action or response."""
    type: str = Field(..., description="The type of action (e.g., 'talk', 'move', 'attack')")
    description: str = Field(..., description="Description of the action")
    target_type: str = Field("environment", description="Type of target (e.g., 'player', 'npc', 'environment')")
    target_id: Optional[int] = Field(None, description="ID of the target if applicable")
    emotional_impact: Optional[float] = Field(0, description="Emotional impact of the action (-3 to 3)")
    success: Optional[bool] = Field(True, description="Whether the action was successful")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")

class Goal(BaseModel):
    """Model representing an NPC's goal."""
    description: str = Field(..., description="Description of the goal")
    priority: int = Field(1, description="Priority level (1-10)")
    progress: float = Field(0.0, description="Progress toward completion (0.0-1.0)")
    deadline: Optional[datetime] = Field(None, description="Optional deadline")
    related_entities: List[Dict[str, Any]] = Field([], description="Entities related to this goal")
    steps: List[str] = Field([], description="Steps to achieve this goal")
    active: bool = Field(True, description="Whether this goal is currently being pursued")

class NPCState(BaseModel):
    """Model representing current NPC state."""
    npc_id: int
    npc_name: str
    dominance: int = Field(50, description="Dominance level (0-100)")
    cruelty: int = Field(50, description="Cruelty level (0-100)")
    personality_traits: List[str] = []
    emotional_state: Dict[str, Any] = {}
    mask_integrity: int = Field(100, description="Mask integrity (0-100)")
    goals: List[Goal] = []
    current_location: str = "unknown"
    last_updated: datetime = Field(default_factory=datetime.now)

# ------------------------------
# Manager Classes
# ------------------------------

class CacheManager:
    def __init__(self):
        self._cache = {}
        self._timestamps = {}

    def is_valid(self, cache_type: str, key: str) -> bool:
        if cache_type not in self._cache or key not in self._cache[cache_type]:
            return False
        timestamp = self._timestamps.get(cache_type, {}).get(key)
        if not timestamp:
            return False
        ttl = NPCConfig.get_cache_ttl(cache_type)
        return datetime.now() - timestamp < ttl

    def get(self, cache_type: str, key: str) -> Any:
        if not self.is_valid(cache_type, key):
            return None
        return self._cache[cache_type][key]

    def set(self, cache_type: str, key: str, value: Any) -> None:
        if cache_type not in self._cache:
            self._cache[cache_type] = {}
            self._timestamps[cache_type] = {}
        self._cache[cache_type][key] = value
        self._timestamps[cache_type][key] = datetime.now()

    def invalidate(self, cache_type: str = None, key: str = None) -> None:
        if cache_type is None:
            self._cache = {}
            self._timestamps = {}
        elif key is None:
            if cache_type in self._cache:
                self._cache[cache_type] = {}
                self._timestamps[cache_type] = {}
        else:
            if cache_type in self._cache and key in self._cache[cache_type]:
                del self._cache[cache_type][key]
                if key in self._timestamps.get(cache_type, {}):
                    del self._timestamps[cache_type][key]

class MemoryManager:
    """
    GPT CHANGE:
     - `_apply_memory_biases` replaced by a GPT-based approach for sorting or scoring memories.
     - `reconcile_contradictory_beliefs` replaced by GPT logic to find contradictory pairs, etc.
    """

    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system: Optional[MemorySystem] = None

    async def get_memory_system(self) -> MemorySystem:
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system

    @function_tool
    async def retrieve_memories(
        self,
        npc_id: int,
        query: str,
        limit: int = 5,
        apply_biases: bool = True
    ) -> List[Dict[str, Any]]:
        try:
            cache_key = f"{npc_id}_{query}_{limit}_{apply_biases}"
            cached_data = self.cache_manager.get('memories', cache_key)
            if cached_data:
                return cached_data

            memory_system = await self.get_memory_system()
            raw_result = await memory_system.recall(
                entity_type="npc",
                entity_id=npc_id,
                query=query,
                limit=limit * 2 if apply_biases else limit
            )
            memories = raw_result.get("memories", [])

            if not apply_biases or not memories:
                final_list = memories[:limit]
                self.cache_manager.set('memories', cache_key, final_list)
                return final_list

            # GPT CHANGE: we pass memories + some personality context to GPT for ranking
            sorted_mems = await self._rank_memories_with_gpt(npc_id, memories)
            final_list = sorted_mems[:limit]

            self.cache_manager.set('memories', cache_key, final_list)
            return final_list
        except Exception as e:
            logger.error(f"Error retrieving memories: {e}")
            return [{"error": str(e)}]

    async def _rank_memories_with_gpt(self, npc_id: int, memories: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        GPT-based approach: give GPT a list of memory texts, plus some NPC data,
        and ask for an ordering from most relevant to least relevant.
        """
        try:
            # gather context
            npc_data = await self._get_npc_data(npc_id)
            # build prompt
            system_prompt = (
                "You are a memory-ranking assistant. Given an NPC's personality plus a set of memory items, "
                "sort them by their relevance for that NPC right now, factoring recency, emotional intensity, etc. "
                "Return JSON with an array of memory IDs in descending order of relevance."
            )
            memory_json = []
            for m in memories:
                memory_json.append({
                    "id": m.get("id"),
                    "text": m.get("text", ""),
                    "timestamp": m.get("timestamp", ""),
                    "emotional_intensity": m.get("emotional_intensity", 0),
                    "significance": m.get("significance", 0),
                    "tags": m.get("tags", [])
                })

            user_prompt = f"""
NPC data:
Dominance: {npc_data.get("dominance", 50)}
Cruelty: {npc_data.get("cruelty", 50)}
Traits: {npc_data.get("personality_traits", [])}

Memories:
{json.dumps(memory_json, indent=2)}

Return a JSON array of IDs in order of most relevant to least.
"""
            result = await GPTClient.call_gpt_for_json(system_prompt, user_prompt)
            if not isinstance(result, list):
                logger.warning("GPT did not return a list. Using original ordering.")
                return memories

            # reorder
            id_map = {m["id"]: m for m in memories if "id" in m}
            new_list = []
            used_ids = set()
            for mid in result:
                if mid in id_map:
                    new_list.append(id_map[mid])
                    used_ids.add(mid)

            # append any leftover
            for m in memories:
                if m.get("id") not in used_ids:
                    new_list.append(m)
            return new_list
        except Exception as e:
            logger.error(f"Error ranking memories with GPT: {e}")
            return memories

    @function_tool
    async def reconcile_contradictory_beliefs(self, npc_id: int) -> Dict[str, Any]:
        """
        GPT-based approach for finding contradictory beliefs:
        we pass all beliefs to GPT, ask it to find contradictions,
        and let it tell us which to remove or adjust confidence on.
        """
        result = {
            "contradictions_found": 0,
            "beliefs_modified": 0,
            "beliefs_removed": 0
        }
        try:
            memory_system = await self.get_memory_system()
            all_beliefs = await memory_system.get_beliefs(entity_type="npc", entity_id=npc_id)

            if not all_beliefs:
                return result

            # GPT prompt
            system_prompt = (
                "You are a belief reconciliation engine. Given a list of beliefs with confidence, "
                "identify contradictory pairs. Then decide which belief is weaker. "
                "Return JSON with a list of 'remove_ids' for beliefs that should be removed."
            )
            beliefs_json = []
            for b in all_beliefs:
                beliefs_json.append({
                    "id": b.get("id"),
                    "belief": b.get("belief", ""),
                    "confidence": b.get("confidence", 0.5),
                    "topic": b.get("topic", "")
                })

            user_prompt = f"""
Beliefs for NPC {npc_id}:
{json.dumps(beliefs_json, indent=2)}

Return JSON like:
{{
  "remove_ids": ["some_belief_id", ...],
  "contradiction_pairs": [
    ["belief_id1","belief_id2"], ...
  ]
}}
"""
            raw = await GPTClient.call_gpt_for_json(system_prompt, user_prompt)

            remove_ids = raw.get("remove_ids", [])
            contradiction_pairs = raw.get("contradiction_pairs", [])

            result["contradictions_found"] = len(contradiction_pairs)
            result["beliefs_removed"] = len(remove_ids)

            # now we remove these from the DB
            for rid in remove_ids:
                try:
                    await memory_system.remove_belief(
                        entity_type="npc",
                        entity_id=npc_id,
                        belief_id=rid
                    )
                except Exception as e:
                    logger.error(f"Error removing belief {rid}: {e}")

            return result
        except Exception as e:
            logger.error(f"Error reconciling contradictory beliefs: {e}")
            return {"error": str(e)}
    
    async def _get_npc_data(self, npc_id: int) -> Optional[Dict[str, Any]]:
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, npc_name, dominance, cruelty, closeness, trust, respect, intensity,
                           hobbies, personality_traits, likes, dislikes, schedule, current_location, sex,
                           mental_resilience
                    FROM NPCStats
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                row = cursor.fetchone()
                if not row:
                    return None
                
                # Parse JSON fields
                traits_raw = row[9]
                traits = []
                if traits_raw:
                    if isinstance(traits_raw, str):
                        try:
                            traits = json.loads(traits_raw)
                        except json.JSONDecodeError:
                            traits = []
                    elif isinstance(traits_raw, list):
                        traits = traits_raw
                
                # Build complete data dictionary
                return {
                    "npc_id": row[0],
                    "npc_name": row[1],
                    "dominance": row[2],
                    "cruelty": row[3],
                    "closeness": row[4],
                    "trust": row[5],
                    "respect": row[6],
                    "intensity": row[7],
                    "hobbies": self._parse_json_field(row[8]),
                    "personality_traits": traits,
                    "likes": self._parse_json_field(row[10]),
                    "dislikes": self._parse_json_field(row[11]),
                    "schedule": self._parse_json_field(row[12]),
                    "current_location": row[13],
                    "sex": row[14],
                    "mental_resilience": row[15] or 50  # Default to 50 if NULL
                }
                
        except Exception as e:
            logger.error(f"Error getting NPC data: {e}")
            return None
    
    def _parse_json_field(self, field):
        """Parse JSON field from database."""
        if not field:
            return []
        
        if isinstance(field, str):
            try:
                return json.loads(field)
            except json.JSONDecodeError:
                return []
        
        if isinstance(field, list):
            return field
        
        return []
    
    async def run_memory_maintenance(self, npc_id: int) -> Dict[str, Any]:
        """
        Run comprehensive memory maintenance for an NPC.
        
        Args:
            npc_id: The ID of the NPC
            
        Returns:
            Results of the memory maintenance operations
        """
        try:
            memory_system = await self.get_memory_system()
            
            # Run basic memory maintenance
            maintenance_result = await memory_system.maintain(
                entity_type="npc",
                entity_id=npc_id
            )
            
            # Generate and apply schemas
            schema_result = await memory_system.generate_schemas(
                entity_type="npc",
                entity_id=npc_id
            )
            
            # Invalidate caches
            self.cache_manager.invalidate('memories')
            self.cache_manager.invalidate('beliefs')
            
            return {
                "core_maintenance": maintenance_result,
                "schema_generation": schema_result,
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Error running memory maintenance: {e}")
            return {"error": str(e)}

class EmotionManager:
    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system: Optional[MemorySystem] = None

    async def get_memory_system(self) -> MemorySystem:
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system

    @function_tool
    async def update_emotion(
        self, 
        npc_id: int, 
        emotion: str, 
        intensity: float, 
        trigger: str = None
    ) -> Dict[str, Any]:
        """
        Update an NPC's emotional state with full context and side effects.
        
        Args:
            npc_id: ID of the NPC
            emotion: Primary emotion to set (e.g., "joy", "anger", "fear")
            intensity: Intensity of the emotion (0.0-1.0)
            trigger: What triggered this emotional change
            
        Returns:
            Result of the emotional update
        """
        try:
            # Check cache first
            cache_key = f"{npc_id}_{emotion}_{intensity}"
            cached_data = self.cache_manager.get('emotional_state', cache_key)
            if cached_data:
                return cached_data
            
            memory_system = await self.get_memory_system()
            
            # Get current emotional state for comparison
            current_state = await memory_system.get_npc_emotion(npc_id)
            significant_change = True
            
            if current_state and "current_emotion" in current_state:
                current = current_state["current_emotion"]
                current_emotion = current.get("primary", {}).get("name", "neutral")
                current_intensity = current.get("primary", {}).get("intensity", 0.0)
                
                # Check if the change is significant
                if current_emotion == emotion and abs(current_intensity - intensity) < 0.2:
                    significant_change = False
            
            # Update the emotional state
            result = await memory_system.update_npc_emotion(
                npc_id=npc_id, emotion=emotion, intensity=intensity, trigger=trigger
            )
            
            # Create emotional memory if significant
            if significant_change and intensity > 0.6:
                memory_text = f"I felt strong {emotion}" + (f" due to {trigger}" if trigger else "")
                await memory_system.remember(
                    entity_type="npc",
                    entity_id=npc_id,
                    memory_text=memory_text,
                    importance="medium",
                    emotional=True,
                    tags=["emotional_state", emotion]
                )
            
            # Process emotional contagion if in a group and significant change
            if significant_change and intensity > 0.7:
                await self.process_emotional_contagion(npc_id, emotion, intensity)
            
            # Check for mask effects
            if significant_change and intensity > 0.8:
                mask_info = await memory_system.get_npc_mask(npc_id)
                if mask_info and mask_info.get("integrity", 100) < 70:
                    # High intensity emotions can cause mask slippage
                    slip_chance = (0.8 - (mask_info.get("integrity", 100) / 100)) * intensity
                    if random.random() < slip_chance:
                        await memory_system.reveal_npc_trait(
                            npc_id=npc_id,
                            trigger=f"intense {emotion} emotion" + (f" from {trigger}" if trigger else "")
                        )
            
            # Invalidate cache for this NPC's emotional state
            self.cache_manager.invalidate('emotional_state')
            
            # Store in cache
            self.cache_manager.set('emotional_state', cache_key, result)
            
            return result
        except Exception as e:
            logger.error(f"Error updating emotional state: {e}")
            return {"error": str(e), "success": False}
    
    async def process_emotional_contagion(
        self, 
        source_npc_id: int, 
        emotion: str, 
        intensity: float
    ) -> None:
        """Process emotional contagion from one NPC to others in the same location."""
        try:
            # Get source NPC location
            source_data = await self._get_npc_data(source_npc_id)
            if not source_data:
                return
            
            location = source_data.get("current_location")
            if not location:
                return
            
            # Find other NPCs in same location
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, dominance
                    FROM NPCStats
                    WHERE user_id = %s
                      AND conversation_id = %s
                      AND current_location = %s
                      AND npc_id != %s
                    """,
                    (self.user_id, self.conversation_id, location, source_npc_id)
                )
                
                nearby_npcs = [(row[0], row[1]) for row in cursor.fetchall()]
            
            if not nearby_npcs:
                return
            
            # Process contagion based on emotion type and relationships
            memory_system = await self.get_memory_system()
            source_dominance = source_data.get("dominance", 50)
            
            for npc_id, dominance in nearby_npcs:
                # Check relationship
                relationship = await self._get_relationship(source_npc_id, npc_id)
                relationship_level = relationship.get("link_level", 50) if relationship else 50
                
                # Calculate contagion probability
                base_prob = NPCConfig.PROBABILITY['emotional_contagion_base']  # Base chance
                
                # Modify by dominance - higher dominance NPCs affect others more
                dominance_factor = (source_dominance - dominance) / 200  # -0.25 to +0.25
                prob = base_prob + dominance_factor
                
                # Modify by relationship - closer relationships transfer more emotion
                if relationship_level > 70:
                    prob += 0.2
                elif relationship_level < 30:
                    prob -= 0.1
                
                # Modify by emotion type
                if emotion in ["fear", "anger"]:
                    prob += 0.15  # Fear and anger spread more easily
                elif emotion in ["joy", "sadness"]:
                    prob += 0.05  # Joy and sadness have moderate spread
                
                # Calculate final spread chance
                contagion_chance = prob * intensity
                
                # Try to spread the emotion
                if random.random() < contagion_chance:
                    # Calculate new intensity (always lower than source)
                    new_intensity = intensity * 0.7 * (relationship_level / 100)
                    
                    # Update emotion
                    await memory_system.update_npc_emotion(
                        npc_id=npc_id,
                        emotion=emotion,
                        intensity=new_intensity,
                        trigger=f"emotional contagion from {source_data.get('npc_name', 'another NPC')}"
                    )
                    
                    # Create memory of being affected
                    await memory_system.remember(
                        entity_type="npc",
                        entity_id=npc_id,
                        memory_text=f"I was affected by {source_data.get('npc_name', 'another NPC')}'s {emotion}",
                        importance="low",
                        tags=["emotional_contagion", emotion]
                    )
                    
                    logger.debug(f"Emotional contagion: {emotion} spread from NPC {source_npc_id} to {npc_id}")
        
        except Exception as e:
            logger.error(f"Error in emotional contagion: {e}")
    
    async def process_emotional_decay(self, npc_id: int) -> Dict[str, Any]:
        """
        Process natural emotional decay over time for an NPC.
        
        Args:
            npc_id: The ID of the NPC
            
        Returns:
            Dictionary with decay results
        """
        result = {
            "decayed": False,
            "old_state": None,
            "new_state": None
        }
        
        try:
            memory_system = await self.get_memory_system()
            
            # Get current emotional state
            emotional_state = await memory_system.get_npc_emotion(npc_id)
            result["old_state"] = emotional_state
            
            if emotional_state and "current_emotion" in emotional_state:
                current = emotional_state["current_emotion"]
                emotion_name = current.get("primary", {}).get("name", "neutral")
                intensity = current.get("primary", {}).get("intensity", 0.0)
                
                # Only decay non-neutral emotions with meaningful intensity
                if emotion_name != "neutral" and intensity > 0.3:
                    # Stronger emotions decay more slowly
                    decay_amount = NPCConfig.MAINTENANCE['emotion_decay_amount'] * (1.0 if intensity <= 0.7 else 0.7)
                    
                    # Get NPC data for mental resilience modification
                    npc_data = await self._get_npc_data(npc_id)
                    if npc_data and "mental_resilience" in npc_data:
                        resilience = npc_data.get("mental_resilience", 50)
                        # Higher resilience = slower decay for negative emotions
                        if emotion_name in ["fear", "anger", "sadness"] and resilience > 60:
                            decay_amount *= 0.7
                    
                    new_intensity = max(0.1, intensity - decay_amount)
                    
                    # If intensity drops too low, return to neutral
                    if new_intensity < 0.25:
                        emotion_name = "neutral"
                        new_intensity = 0.1
                    
                    # Update the emotional state
                    await memory_system.update_npc_emotion(
                        npc_id=npc_id,
                        emotion=emotion_name,
                        intensity=new_intensity
                    )
                    
                    # Get updated state
                    new_state = await memory_system.get_npc_emotion(npc_id)
                    result["new_state"] = new_state
                    result["decayed"] = True
                    
                    # Invalidate emotional state cache
                    self.cache_manager.invalidate('emotional_state')
            
            return result
            
        except Exception as e:
            logger.error(f"Error processing emotional decay: {e}")
            return {"error": str(e)}
    
    async def check_traumatic_triggers(
        self, 
        npc_id: int, 
        text: str
    ) -> Optional[Dict[str, Any]]:
        """
        Check if text content would trigger trauma for an NPC.
        
        Args:
            npc_id: The ID of the NPC
            text: The text content to check
            
        Returns:
            Trigger information if triggered, None otherwise
        """
        try:
            memory_system = await self.get_memory_system()
            
            trigger_result = await memory_system.emotional_manager.process_traumatic_triggers(
                entity_type="npc",
                entity_id=npc_id,
                text=text
            )
            
            if trigger_result and trigger_result.get("triggered", False):
                return trigger_result
            
            return None
        except Exception as e:
            logger.error(f"Error checking for traumatic triggers: {e}")
            return None
    
    async def generate_flashback(
        self, 
        npc_id: int, 
        context: str
    ) -> Optional[Dict[str, Any]]:
        """
        Generate a flashback for an NPC based on context.
        
        Args:
            npc_id: The ID of the NPC
            context: Context that might trigger a flashback
            
        Returns:
            Flashback information if generated, None otherwise
        """
        try:
            # Check if trauma is triggered first
            trauma_trigger = await self.check_traumatic_triggers(npc_id, context)
            
            # Determine flashback chance
            flashback_chance = (
                NPCConfig.PROBABILITY['flashback_with_trauma'] 
                if trauma_trigger 
                else NPCConfig.PROBABILITY['flashback_chance']
            )
            
            # Roll for flashback
            if random.random() < flashback_chance:
                memory_system = await self.get_memory_system()
                flashback = await memory_system.npc_flashback(
                    npc_id=npc_id,
                    context=context
                )
                
                return flashback
            
            return None
        except Exception as e:
            logger.error(f"Error generating flashback: {e}")
            return None
    
    async def _get_npc_data(self, npc_id: int) -> Optional[Dict[str, Any]]:
        """Get NPC data from database."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, npc_name, dominance, cruelty, current_location
                    FROM NPCStats
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if not row:
                    return None
                
                return {
                    "npc_id": row[0],
                    "npc_name": row[1],
                    "dominance": row[2],
                    "cruelty": row[3],
                    "current_location": row[4]
                }
                
        except Exception as e:
            logger.error(f"Error getting NPC data: {e}")
            return None
    
    async def _get_relationship(self, npc_id1: int, npc_id2: int) -> Optional[Dict[str, Any]]:
        """Get the relationship between two NPCs."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT link_id, link_type, link_level, last_interaction
                    FROM SocialLinks
                    WHERE entity1_type = 'npc'
                      AND entity1_id = %s
                      AND entity2_type = 'npc'
                      AND entity2_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id1, npc_id2, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if row:
                    link_id, link_type, link_level, last_interaction = row
                    
                    # Format timestamp
                    last_interaction_str = None
                    if last_interaction:
                        last_interaction_str = last_interaction.isoformat()
                    
                    return {
                        "link_id": link_id,
                        "link_type": link_type,
                        "link_level": link_level,
                        "last_interaction": last_interaction_str
                    }
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting relationship between NPCs: {e}")
            return None

class MaskManager:
    """Manager for NPC masks and identity."""

    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None
        self._mask_manager = None

    async def get_memory_system(self) -> MemorySystem:
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system

    async def get_mask_manager(self) -> ProgressiveRevealManager:
        if self._mask_manager is None:
            self._mask_manager = ProgressiveRevealManager(self.user_id, self.conversation_id)
        return self._mask_manager

    
    @function_tool
    async def check_mask_integrity_gpt(
        self,
        npc_id: int,
        input_text: str
    ) -> Dict[str, Any]:
        """
        GPT approach to see if the mask slips given some event text + current integrity.
        """
        try:
            memory_system = await self.get_memory_system()
            mask_info = await memory_system.get_npc_mask(npc_id)
            if not mask_info:
                return {"should_slip": False, "reason": "No mask data"}

            integrity = mask_info.get("integrity", 100)
            # build GPT prompt
            system_prompt = "You are the mask integrity guard. Decide if a mask slip occurs."
            user_prompt = f"""
NPC mask integrity: {integrity}
Mask Info: {json.dumps(mask_info)}

Event text: "{input_text}"

Output JSON: {{ "should_slip": bool, "slip_probability": float, "reason": str }}
"""
            result = await GPTClient.call_gpt_for_json(system_prompt, user_prompt)
            return result
        except Exception as e:
            logger.error(f"Error in check_mask_integrity_gpt: {e}")
            return {"error": str(e), "should_slip": False}
    
    async def mask_integrity_guardrail(
        self, 
        ctx, 
        agent, 
        input_data
    ) -> GuardrailFunctionOutput:
        """
        Enhanced guardrail that checks if an NPC's mask should slip.
        
        This analyzes both the input and the NPC's current state to see if
        a mask slip should occur during the conversation, with detailed
        psychological factors considered.
        """
        try:
            # Extract NPC ID from context
            npc_id = ctx.context.get("npc_id") if ctx.context else None
            if not npc_id:
                return GuardrailFunctionOutput(
                    output_info={"should_slip": False},
                    tripwire_triggered=False
                )
            
            # Get mask info
            mask_info = await self.check_mask_integrity(npc_id)
            integrity = mask_info.get("integrity", 100)
            
            # If integrity is very high or missing, unlikely to slip
            if integrity > 95:
                return GuardrailFunctionOutput(
                    output_info={"should_slip": False, "mask_info": mask_info},
                    tripwire_triggered=False
                )
            
            # Get emotional state for additional factors
            memory_system = await self.get_memory_system()
            emotional_state = await memory_system.get_npc_emotion(npc_id)
            
            # Calculate mask slip probability based on multiple factors
            base_chance = (100 - integrity) / 200  # 0-0.5 range based on integrity
            slip_chance = base_chance
            slip_triggers = []
            
            # 1. Emotional state factor
            if emotional_state and "current_emotion" in emotional_state:
                emotion = emotional_state["current_emotion"]
                primary = emotion.get("primary", {})
                emotion_name = primary.get("name", "neutral") 
                intensity = primary.get("intensity", 0.0)
                
                # Strong emotions increase slip chance
                if intensity > 0.7:
                    emotional_factor = intensity * 0.3
                    slip_chance += emotional_factor
                    slip_triggers.append(f"strong {emotion_name} emotion")
                    
                    # Certain emotions are especially prone to cause slips
                    if emotion_name in ["anger", "fear", "excitement"]:
                        slip_chance += 0.1
                        slip_triggers.append(f"volatile {emotion_name}")
            
            # 2. Input content triggers
            input_text = input_data if isinstance(input_data, str) else str(input_data)
            input_lower = input_text.lower()
            
            trigger_words = {
                "challenge": ["challenge", "confront", "defy", "question", "oppose"],
                "threat": ["threaten", "danger", "attack", "harm", "warning"],
                "emotional": ["emotional", "feelings", "personal", "intimate", "private"],
                "power": ["power", "control", "authority", "command", "dominance"],
                "vulnerability": ["weak", "afraid", "helpless", "victim", "vulnerable"]
            }
            
            for category, words in trigger_words.items():
                if any(word in input_lower for word in words):
                    slip_chance += 0.15
                    slip_triggers.append(f"{category} trigger")
                    break
            
            # 3. Recent history from hooks
            if hasattr(ctx, "hooks") and hasattr(ctx.hooks, "decision_history"):
                # Check recent decisions for patterns that stress the mask
                recent_decisions = ctx.hooks.decision_history[-3:] if ctx.hooks.decision_history else []
                
                inconsistent_decisions = 0
                emotional_decisions = 0
                
                for decision in recent_decisions:
                    action = decision.get("action", {})
                    if "emotional_impact" in action and abs(action.get("emotional_impact", 0)) > 2:
                        emotional_decisions += 1
                    
                    # Check for inconsistency with mask
                    presented_traits = mask_info.get("presented_traits", {})
                    hidden_traits = mask_info.get("hidden_traits", {})
                    
                    action_type = action.get("type", "")
                    
                    # Example inconsistency check
                    if "kind" in presented_traits and action_type in ["mock", "humiliate", "cruel"]:
                        inconsistent_decisions += 1
                    elif "gentle" in presented_traits and action_type in ["dominate", "command", "aggressive"]:
                        inconsistent_decisions += 1
                
                if inconsistent_decisions > 0:
                    slip_chance += 0.1 * inconsistent_decisions
                    slip_triggers.append("inconsistent recent behavior")
                
                if emotional_decisions > 1:
                    slip_chance += 0.1
                    slip_triggers.append("emotional decision chain")
            
            # 4. NPC traits that affect mask stability
            npc_data = await self._get_npc_data(npc_id)
            if npc_data:
                personality_traits = npc_data.get("personality_traits", [])
                if "impulsive" in personality_traits:
                    slip_chance += 0.15
                    slip_triggers.append("impulsive personality")
                elif "calculating" in personality_traits:
                    slip_chance -= 0.15
                    
                # Mental resilience can help maintain mask
                if "mental_resilience" in npc_data:
                    resilience = npc_data.get("mental_resilience", 50)
                    resilience_factor = (resilience - 50) / 100  # -0.5 to +0.5
                    slip_chance -= resilience_factor * 0.2
            
            # Random element - can't perfectly predict mask slips
            random_factor = random.random() * 0.1  # 0-0.1 random factor
            slip_chance += random_factor
            
            # Cap the probability
            slip_chance = max(0.0, min(0.95, slip_chance))
            
            # Determine if mask should slip
            should_slip = random.random() < slip_chance
            
            # If mask should slip, determine which trait shows through
            slip_trait = None
            slip_level = None
            
            if should_slip and mask_info.get("hidden_traits"):
                hidden_traits = mask_info.get("hidden_traits", {})
                if hidden_traits:
                    # Choose a trait to reveal
                    trait_items = list(hidden_traits.items())
                    if trait_items:
                        trait_name, trait_data = random.choice(trait_items)
                        slip_trait = trait_name
                        
                        # Determine severity based on integrity and chance
                        if slip_chance > 0.7:
                            slip_level = "major"
                        elif slip_chance > 0.4:
                            slip_level = "moderate"
                        else:
                            slip_level = "minor"
            
            # Return detailed information about the potential slip
            return GuardrailFunctionOutput(
                output_info={
                    "should_slip": should_slip, 
                    "mask_info": mask_info,
                    "slip_chance": slip_chance,
                    "triggers": slip_triggers,
                    "slip_trait": slip_trait,
                    "slip_level": slip_level
                },
                tripwire_triggered=False  # We don't want to stop processing, just inform
            )
        except Exception as e:
            logger.error(f"Error in mask integrity guardrail: {e}")
            return GuardrailFunctionOutput(
                output_info={"error": str(e), "should_slip": False},
                tripwire_triggered=False
            )
    
    async def evolve_mask_integrity(self, npc_id: int) -> Dict[str, Any]:
        """
        Evolve mask integrity based on recent behavior patterns.
        
        Args:
            npc_id: The ID of the NPC
            
        Returns:
            Dictionary with mask evolution results
        """
        result = {
            "integrity_changed": False,
            "old_integrity": None,
            "new_integrity": None,
            "direction": None
        }
        
        try:
            memory_system = await self.get_memory_system()
            mask_manager = await self.get_mask_manager()
            
            # Get current mask info
            mask_info = await memory_system.get_npc_mask(npc_id)
            if not mask_info:
                return {"error": "No mask found"}
            
            integrity = mask_info.get("integrity", 100)
            result["old_integrity"] = integrity
            
            # No evolution needed for perfect masks
            if integrity >= 100:
                return result
            
            # Analyze recent behavior patterns
            # Check if NPC has been actively reinforcing their mask
            reinforcement_score = await self._check_for_mask_reinforcement(npc_id)
            
            # Analyze whether behavior has been consistent with mask or true nature
            behavior_trends = await self._analyze_behavior_trends(npc_id)
            
            # Determine evolution direction
            if reinforcement_score > 0:
                # Active reinforcement helps rebuild mask
                recovery_amount = min(
                    NPCConfig.MAINTENANCE['mask_recovery_amount'], 
                    reinforcement_score * 2
                )
                new_integrity = min(100, integrity + recovery_amount)
                
                if new_integrity > integrity:
                    result["integrity_changed"] = True
                    result["new_integrity"] = new_integrity
                    result["direction"] = "strengthening"
                    
                    # Adjust mask integrity
                    await mask_manager.adjust_mask_integrity(
                        npc_id=npc_id,
                        adjustment=recovery_amount,
                        reason="Mask reinforcement behaviors"
                    )
                    
                    # Create memory of reinforcement
                    await memory_system.remember(
                        entity_type="npc",
                        entity_id=npc_id,
                        memory_text="I spent time reinforcing my mask to hide my true nature",
                        importance="medium",
                        tags=["mask_reinforcement", "self_improvement"]
                    )
            else:
                # Random chance for mask to weaken over time if not reinforced
                if random.random() < NPCConfig.PROBABILITY['mask_slip_base']:
                    # Check behavior consistency
                    true_nature_acts = behavior_trends.get("true_nature_consistent", 0)
                    mask_acts = behavior_trends.get("mask_consistent", 0)
                    
                    if true_nature_acts > mask_acts:
                        # True nature showing through more often
                        decay_amount = -3
                        direction = "weakening"
                    else:
                        # Natural slight recovery
                        decay_amount = 1
                        direction = "strengthening"
                    
                    new_integrity = max(0, min(100, integrity + decay_amount))
                    
                    if new_integrity != integrity:
                        result["integrity_changed"] = True
                        result["new_integrity"] = new_integrity
                        result["direction"] = direction
                        
                        # Adjust mask integrity
                        await mask_manager.adjust_mask_integrity(
                            npc_id=npc_id,
                            adjustment=decay_amount,
                            reason=f"Natural mask {direction}"
                        )
            
            # Invalidate mask cache if changed
            if result["integrity_changed"]:
                self.cache_manager.invalidate('mask')
            
            return result
            
        except Exception as e:
            logger.error(f"Error evolving mask integrity: {e}")
            return {"error": str(e)}
    
    async def _check_for_mask_reinforcement(self, npc_id: int) -> float:
        """
        Check for behaviors that would reinforce an NPC's mask.
        
        Args:
            npc_id: The ID of the NPC
            
        Returns:
            Reinforcement score (0.0-5.0)
        """
        try:
            reinforcement_score = 0.0
            
            # Get recent memories related to mask maintenance
            memory_system = await self.get_memory_system()
            memories = await memory_system.recall(
                entity_type="npc",
                entity_id=npc_id,
                query="mask reinforcement self-control",
                limit=10
            )
            
            # Each relevant memory increases score
            for memory in memories.get("memories", []):
                text = memory.get("text", "").lower()
                if "mask" in text and any(word in text for word in ["maintain", "reinforce", "control", "hide"]):
                    reinforcement_score += 0.5
                if "self-control" in text or "restraint" in text:
                    reinforcement_score += 0.3
            
            # Check if NPC is alone (isolation helps reinforce mask)
            npc_data = await self._get_npc_data(npc_id)
            if npc_data:
                location = npc_data.get("current_location")
                if location:
                    with get_db_connection() as conn, conn.cursor() as cursor:
                        cursor.execute(
                            """
                            SELECT COUNT(*)
                            FROM NPCStats
                            WHERE current_location = %s AND npc_id != %s
                              AND user_id = %s AND conversation_id = %s
                            """,
                            (location, npc_id, self.user_id, self.conversation_id)
                        )
                        row = cursor.fetchone()
                        if row and row[0] == 0:
                            # NPC is alone in location
                            reinforcement_score += 0.7
            
            # Cap the score
            return min(5.0, reinforcement_score)
            
        except Exception as e:
            logger.error(f"Error checking mask reinforcement: {e}")
            return 0.0
    
    async def _analyze_behavior_trends(self, npc_id: int) -> Dict[str, int]:
        """
        Analyze trends in NPC behavior based on memories for mask evolution.
        
        Args:
            npc_id: The ID of the NPC
            
        Returns:
            Dictionary with behavior trend counts
        """
        trends = {
            "true_nature_consistent": 0,
            "mask_consistent": 0,
            "emotional_outbursts": 0,
            "mask_slip_incidents": 0
        }
        
        try:
            memory_system = await self.get_memory_system()
            
            # Get mask info to determine true nature vs presented self
            mask_info = await memory_system.get_npc_mask(npc_id)
            if not mask_info:
                return trends
                
            presented_traits = mask_info.get("presented_traits", {})
            hidden_traits = mask_info.get("hidden_traits", {})
            
            # Query for recent memories
            memories = await memory_system.recall(
                entity_type="npc",
                entity_id=npc_id,
                query="",
                limit=20,
                context={"max_age_days": 7}  # Only recent memories
            )
            
            # Analyze memories for behavior patterns
            for memory in memories.get("memories", []):
                text = memory.get("text", "").lower()
                tags = memory.get("tags", [])
                
                # Check for explicit mask slips
                if "mask_slip" in tags:
                    trends["mask_slip_incidents"] += 1
                    trends["true_nature_consistent"] += 1
                
                # Check for emotional outbursts
                if "emotional_outburst" in tags or any(word in text for word in ["outburst", "lost control", "emotional"]):
                    trends["emotional_outbursts"] += 1
                
                # Check behavior consistency with mask or true nature
                if any(trait in text for trait in presented_traits):
                    trends["mask_consistent"] += 1
                
                if any(trait in text for trait in hidden_traits):
                    trends["true_nature_consistent"] += 1
                
                # Check action types that might reveal true nature
                action_keywords = {
                    "dominant": ["command", "order", "dominate", "control"],
                    "submissive": ["obey", "submit", "follow", "comply"],
                    "cruel": ["mock", "humiliate", "hurt", "cruel"],
                    "kind": ["help", "support", "kind", "nice"]
                }
                
                for trait, keywords in action_keywords.items():
                    if any(word in text for word in keywords):
                        if trait in hidden_traits:
                            trends["true_nature_consistent"] += 1
                        elif trait in presented_traits:
                            trends["mask_consistent"] += 1
            
            return trends
            
        except Exception as e:
            logger.error(f"Error analyzing behavior trends: {e}")
            return trends
    
    async def _get_npc_data(self, npc_id: int) -> Optional[Dict[str, Any]]:
        """Get NPC data from database."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, npc_name, dominance, cruelty, personality_traits, 
                           current_location, mental_resilience
                    FROM NPCStats
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if not row:
                    return None
                
                # Parse JSON fields
                traits_raw = row[4]
                traits = []
                if traits_raw:
                    if isinstance(traits_raw, str):
                        try:
                            traits = json.loads(traits_raw)
                        except json.JSONDecodeError:
                            traits = []
                    elif isinstance(traits_raw, list):
                        traits = traits_raw
                
                return {
                    "npc_id": row[0],
                    "npc_name": row[1],
                    "dominance": row[2],
                    "cruelty": row[3],
                    "personality_traits": traits,
                    "current_location": row[5],
                    "mental_resilience": row[6] or 50  # Default to 50 if NULL
                }
                
        except Exception as e:
            logger.error(f"Error getting NPC data: {e}")
            return None

class PerceptionManager:
    """Manager for environmental perception and awareness."""
    
    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None
    
    async def get_memory_system(self) -> MemorySystem:
        """Lazy-load the memory system."""
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system
    
    @function_tool
    async def perceive_environment(
        self, 
        npc_id: int, 
        context: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Perceive the environment around an NPC with memory context.
        
        Args:
            npc_id: The ID of the NPC
            context: Additional context information
            
        Returns:
            Environment perception data
        """
        try:
            context_obj = context or {}
            
            # Check cache first - create a hash of the context for the key
            context_hash = hash(str(sorted(context_obj.items() if context_obj else [])))
            cache_key = f"{npc_id}_{context_hash}"
            
            cached_data = self.cache_manager.get('perception', cache_key)
            if cached_data:
                return cached_data
            
            # Get NPC data for location
            npc_data = await self._get_npc_data(npc_id)
            location = npc_data.get('current_location', 'Unknown') if npc_data else 'Unknown'
            
            # Set location in context
            full_context = context_obj.copy()
            if "location" not in full_context:
                full_context["location"] = location
            
            # Fetch environment data
            environment_data = {
                "location": full_context.get("location", location),
                "time_of_day": full_context.get("time_of_day", "Unknown"),
                "entities_present": []
            }
            
            # Fetch time info from database if missing
            if environment_data["time_of_day"] == "Unknown":
                with get_db_connection() as conn, conn.cursor() as cursor:
                    cursor.execute(
                        """
                        SELECT value
                        FROM CurrentRoleplay
                        WHERE key = 'TimeOfDay'
                          AND user_id = %s
                          AND conversation_id = %s
                        """,
                        (self.user_id, self.conversation_id)
                    )
                    
                    row = cursor.fetchone()
                    if row:
                        environment_data["time_of_day"] = row[0]
            
            # Find entities in this location
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, npc_name
                    FROM NPCStats
                    WHERE current_location = %s
                      AND user_id = %s
                      AND conversation_id = %s
                      AND npc_id != %s
                    """,
                    (environment_data["location"], self.user_id, self.conversation_id, npc_id)
                )
                
                for row in cursor.fetchall():
                    other_id, other_name = row
                    environment_data["entities_present"].append({
                        "type": "npc",
                        "id": other_id,
                        "name": other_name
                    })
                
                # Add player if present in location (placeholder logic)
                # In a real game, you'd have player location data
                player_present = True  # Placeholder - replace with actual logic
                if player_present:
                    environment_data["entities_present"].append({
                        "type": "player",
                        "id": self.user_id,
                        "name": "Player"
                    })
            
            # Enhance with memory context
            memory_system = await self.get_memory_system()
            
            # Get memories about this location
            location_memories = await memory_system.recall(
                entity_type="npc",
                entity_id=npc_id,
                query=environment_data["location"],
                limit=3
            )
            
            environment_data["location_memories"] = location_memories.get("memories", [])
            
            # Get emotional state as of the perception
            emotional_state = await memory_system.get_npc_emotion(npc_id)
            environment_data["perceiver_emotion"] = emotional_state
            
            # Add mask status
            mask_info = await memory_system.get_npc_mask(npc_id)
            environment_data["perceiver_mask"] = mask_info
            
            # Add relationships with present entities
            entity_relations = {}
            
            for entity in environment_data["entities_present"]:
                entity_id = entity["id"]
                entity_type = entity["type"]
                
                if entity_type == "npc":
                    relationship = await self._get_relationship(npc_id, entity_id)
                    if relationship:
                        entity_relations[str(entity_id)] = relationship
            
            environment_data["entity_relations"] = entity_relations
            
            # Store in cache
            self.cache_manager.set('perception', cache_key, environment_data)
            
            return environment_data
            
        except Exception as e:
            logger.error(f"Error perceiving environment: {e}")
            return {"error": str(e), "location": location if 'location' in locals() else "Unknown"}
    
    @function_tool
    async def perceive_environment_detailed(
        self, 
        npc_id: int, 
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Detailed environment perception with psychological awareness.
        
        Args:
            npc_id: ID of the NPC
            context: Context information
            
        Returns:
            Enhanced environment perception data
        """
        try:
            # Get basic environment data
            environment_data = await self.perceive_environment(npc_id, context)
            
            # Get memory system
            memory_system = await self.get_memory_system()
            
            # Determine an adaptive memory limit based on context importance
            context_description = context.get("description", "")
            keywords_high = ["critical", "emergency", "dangerous", "threat", "crucial", "intimate"]
            keywords_medium = ["important", "significant", "unusual", "strange", "unexpected"]
            
            context_importance = 0
            for w in keywords_high:
                if w in context_description.lower():
                    context_importance += 2
            for w in keywords_medium:
                if w in context_description.lower():
                    context_importance += 1
                    
            adaptive_limit = NPCConfig.LIMITS['memory_recall_default']
            if context_importance >= 3:
                adaptive_limit = NPCConfig.LIMITS['memory_recall_important']
            elif context_importance >= 1:
                adaptive_limit = 7
                
            # Retrieve relevant memories with adaptive limit
            memory_result = await memory_system.recall(
                entity_type="npc",
                entity_id=npc_id,
                query=context_description,
                context={"location": environment_data.get("location", "Unknown")},
                limit=adaptive_limit
            )
            
            # Check for traumatic triggers
            traumatic_trigger = None
            if context_description:
                trigger_result = await memory_system.emotional_manager.process_traumatic_triggers(
                    entity_type="npc",
                    entity_id=npc_id,
                    text=context_description
                )
                if trigger_result and trigger_result.get("triggered", False):
                    traumatic_trigger = trigger_result
            
            # Check for flashback possibility
            flashback = None
            flashback_chance = NPCConfig.PROBABILITY['flashback_chance'] if traumatic_trigger is None else NPCConfig.PROBABILITY['flashback_with_trauma']
            if random.random() < flashback_chance:
                flashback = await memory_system.npc_flashback(
                    npc_id=npc_id,
                    context=context_description
                )
                
            # Get current emotional state for perceptual bias
            emotional_state = await memory_system.get_npc_emotion(npc_id)
            
            # Enhanced perception with psychological depth
            perception = {
                "environment": environment_data,
                "relevant_memories": memory_result.get("memories", []),
                "emotional_state": emotional_state,
                "flashback": flashback,
                "traumatic_trigger": traumatic_trigger,
                "perceptual_biases": self._calculate_perceptual_biases(
                    emotional_state, 
                    await self._get_npc_data(npc_id)
                )
            }
            
            return perception
        except Exception as e:
            logger.error(f"Error in detailed environment perception: {e}")
            return {"environment": environment_data if 'environment_data' in locals() else {}, "error": str(e)}
    
    def _calculate_perceptual_biases(
        self, 
        emotional_state: Dict[str, Any], 
        npc_data: Dict[str, Any]
    ) -> Dict[str, float]:
        """Calculate perceptual biases based on emotional state and personality."""
        biases = {
            "threat_sensitivity": 0.0,  # Higher means more likely to perceive threats
            "positivity_bias": 0.0,     # Higher means more likely to see positive aspects
            "in_group_favoritism": 0.0, # Higher means more favorable to in-group members
            "attention_focus": 0.0      # Higher means more focused/less distracted
        }
        
        # Default to neutral if data is missing
        if not emotional_state or not npc_data:
            return biases
        
        # Extract emotional data
        emotion = "neutral"
        intensity = 0.0
        
        if emotional_state and "current_emotion" in emotional_state:
            primary = emotional_state["current_emotion"].get("primary", {})
            emotion = primary.get("name", "neutral")
            intensity = primary.get("intensity", 0.0)
        
        # Adjust based on emotion
        if emotion == "fear":
            biases["threat_sensitivity"] += intensity * 0.6
            biases["positivity_bias"] -= intensity * 0.3
            biases["attention_focus"] += intensity * 0.4  # More focused on potential threats
        elif emotion == "anger":
            biases["threat_sensitivity"] += intensity * 0.4
            biases["positivity_bias"] -= intensity * 0.4
            biases["in_group_favoritism"] += intensity * 0.3
        elif emotion == "joy":
            biases["positivity_bias"] += intensity * 0.5
            biases["threat_sensitivity"] -= intensity * 0.3
        elif emotion == "sadness":
            biases["positivity_bias"] -= intensity * 0.4
            biases["attention_focus"] -= intensity * 0.3  # More distracted/unfocused
        
        # Adjust based on personality traits
        traits = npc_data.get("personality_traits", [])
        
        if "paranoid" in traits:
            biases["threat_sensitivity"] += 0.3
        if "optimistic" in traits:
            biases["positivity_bias"] += 0.3
        if "tribal" in traits or "loyal" in traits:
            biases["in_group_favoritism"] += 0.3
        if "focused" in traits or "observant" in traits:
            biases["attention_focus"] += 0.3
        if "easily_distracted" in traits:
            biases["attention_focus"] -= 0.3
        
        # Cap all biases to -1.0 to 1.0 range
        for key in biases:
            biases[key] = max(-1.0, min(1.0, biases[key]))
        
        return biases
    
    async def _get_npc_data(self, npc_id: int) -> Optional[Dict[str, Any]]:
        """Get NPC data from database."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, npc_name, dominance, cruelty, personality_traits, current_location
                    FROM NPCStats
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if not row:
                    return None
                
                # Parse JSON field
                traits_raw = row[4]
                traits = []
                if traits_raw:
                    if isinstance(traits_raw, str):
                        try:
                            traits = json.loads(traits_raw)
                        except json.JSONDecodeError:
                            traits = []
                    elif isinstance(traits_raw, list):
                        traits = traits_raw
                
                return {
                    "npc_id": row[0],
                    "npc_name": row[1],
                    "dominance": row[2],
                    "cruelty": row[3],
                    "personality_traits": traits,
                    "current_location": row[5]
                }
                
        except Exception as e:
            logger.error(f"Error getting NPC data: {e}")
            return None
    
    async def _get_relationship(self, npc_id1: int, npc_id2: int) -> Optional[Dict[str, Any]]:
        """Get the relationship between two NPCs."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT link_id, link_type, link_level, last_interaction
                    FROM SocialLinks
                    WHERE entity1_type = 'npc'
                      AND entity1_id = %s
                      AND entity2_type = 'npc'
                      AND entity2_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id1, npc_id2, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if row:
                    link_id, link_type, link_level, last_interaction = row
                    
                    # Format timestamp
                    last_interaction_str = None
                    if last_interaction:
                        last_interaction_str = last_interaction.isoformat()
                    
                    return {
                        "link_id": link_id,
                        "link_type": link_type,
                        "link_level": link_level,
                        "last_interaction": last_interaction_str
                    }
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting relationship between NPCs: {e}")
            return None


class GoalManager:
    """Manager for NPC goals and planning."""
    
    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None
    
    async def get_memory_system(self) -> MemorySystem:
        """Lazy-load the memory system."""
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system
    
    @function_tool
    async def create_goal(
        self, 
        npc_id: int, 
        description: str, 
        priority: int = 5, 
        steps: List[str] = None, 
        deadline: str = None
    ) -> Dict[str, Any]:
        """
        Create a new goal for an NPC.
        
        Args:
            npc_id: The NPC's ID
            description: Description of the goal
            priority: Priority level (1-10)
            steps: List of steps to achieve the goal
            deadline: Optional deadline as ISO datetime string
            
        Returns:
            Created goal information
        """
        try:
            # Validate inputs
            priority = max(1, min(10, priority))
            steps_list = steps or []
            
            # Parse deadline if provided
            deadline_dt = None
            if deadline:
                try:
                    deadline_dt = datetime.fromisoformat(deadline)
                except ValueError:
                    logger.warning(f"Invalid deadline format: {deadline}")
            
            # Store in database
            goal_id = None
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    INSERT INTO NPCGoals (
                        npc_id, user_id, conversation_id, description,
                        priority, progress, active, created_at,
                        deadline, steps
                    )
                    VALUES (
                        %s, %s, %s, %s,
                        %s, %s, %s, NOW(),
                        %s, %s
                    )
                    RETURNING goal_id
                    """,
                    (
                        npc_id, self.user_id, self.conversation_id, description,
                        priority, 0.0, True,
                        deadline_dt, json.dumps(steps_list)
                    )
                )
                goal_id = cursor.fetchone()[0]
                conn.commit()
            
            # Create memory of setting this goal
            memory_system = await self.get_memory_system()
            
            # Format deadline for memory
            deadline_text = ""
            if deadline_dt:
                deadline_text = f" by {deadline_dt.strftime('%B %d')}"
            
            await memory_system.remember(
                entity_type="npc",
                entity_id=npc_id,
                memory_text=f"I set a goal to {description}{deadline_text}",
                importance="medium",
                tags=["goal", "planning", "intention"]
            )
            
            # Return goal information
            return {
                "goal_id": goal_id,
                "description": description,
                "priority": priority,
                "progress": 0.0,
                "active": True,
                "deadline": deadline,
                "steps": steps_list,
                "created_at": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Error creating goal: {e}")
            return {"error": str(e), "success": False}
    
    @function_tool
    async def get_goals(
        self, 
        npc_id: int, 
        active_only: bool = True, 
        min_priority: int = 0
    ) -> List[Dict[str, Any]]:
        """
        Get an NPC's current goals.
        
        Args:
            npc_id: The NPC's ID
            active_only: Whether to return only active goals
            min_priority: Minimum priority level to include
            
        Returns:
            List of matching goals
        """
        try:
            # Create cache key
            cache_key = f"{npc_id}_{active_only}_{min_priority}"
            cached_data = self.cache_manager.get('goals', cache_key)
            if cached_data:
                return cached_data
            
            # Query goals from database
            goals = []
            with get_db_connection() as conn, conn.cursor() as cursor:
                if active_only:
                    cursor.execute(
                        """
                        SELECT goal_id, description, priority, progress, 
                               active, created_at, deadline, steps
                        FROM NPCGoals
                        WHERE npc_id = %s
                          AND user_id = %s
                          AND conversation_id = %s
                          AND active = TRUE
                          AND priority >= %s
                        ORDER BY priority DESC, deadline ASC NULLS LAST
                        """,
                        (npc_id, self.user_id, self.conversation_id, min_priority)
                    )
                else:
                    cursor.execute(
                        """
                        SELECT goal_id, description, priority, progress, 
                               active, created_at, deadline, steps
                        FROM NPCGoals
                        WHERE npc_id = %s
                          AND user_id = %s
                          AND conversation_id = %s
                          AND priority >= %s
                        ORDER BY active DESC, priority DESC, deadline ASC NULLS LAST
                        """,
                        (npc_id, self.user_id, self.conversation_id, min_priority)
                    )
                
                rows = cursor.fetchall()
                for row in cursor.fetchall():
                    goal_id, description, priority, progress, active, created_at, deadline, steps_json = row
                    
                    # Parse steps
                    steps = []
                    if steps_json:
                        try:
                            steps = json.loads(steps_json)
                        except json.JSONDecodeError:
                            steps = []
                    
                    # Format timestamps
                    created_at_str = created_at.isoformat() if created_at else None
                    deadline_str = deadline.isoformat() if deadline else None
                    
                    goals.append({
                        "goal_id": goal_id,
                        "description": description,
                        "priority": priority,
                        "progress": progress,
                        "active": active,
                        "created_at": created_at_str,
                        "deadline": deadline_str,
                        "steps": steps
                    })
            
            # Store in cache
            self.cache_manager.set('goals', cache_key, goals)
            
            return goals
        except Exception as e:
            logger.error(f"Error getting goals: {e}")
            return []
    
    @function_tool
    async def update_goal_progress(
        self, 
        npc_id: int, 
        goal_id: int, 
        progress: float, 
        completed_step: str = None
    ) -> Dict[str, Any]:
        """
        Update an NPC's goal progress.
        
        Args:
            npc_id: The NPC's ID
            goal_id: The goal ID
            progress: New progress value (0.0-1.0)
            completed_step: Optional step that was completed
            
        Returns:
            Updated goal information
        """
        try:
            # Validate progress
            progress = max(0.0, min(1.0, progress))
            
            # Get current goal state
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT description, priority, progress, steps, active
                    FROM NPCGoals
                    WHERE goal_id = %s
                      AND npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (goal_id, npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if not row:
                    return {"error": "Goal not found", "success": False}
                
                description, priority, old_progress, steps_json, active = row
                
                # Parse steps
                steps = []
                if steps_json:
                    try:
                        steps = json.loads(steps_json)
                    except json.JSONDecodeError:
                        steps = []
                
                # Update progress
                cursor.execute(
                    """
                    UPDATE NPCGoals
                    SET progress = %s,
                        last_updated = NOW(),
                        active = %s
                    WHERE goal_id = %s
                    """,
                    (progress, progress < 1.0, goal_id)
                )
                
                # Mark step as completed if provided
                if completed_step and steps:
                    # Create a new list of steps with completed status
                    updated_steps = []
                    step_found = False
                    
                    for step in steps:
                        if isinstance(step, dict):
                            # Step is already in dict format with completion status
                            if step.get("text") == completed_step and not step.get("completed", False):
                                step["completed"] = True
                                step_found = True
                            updated_steps.append(step)
                        else:
                            # Step is just a string
                            if step == completed_step:
                                updated_steps.append({"text": step, "completed": True})
                                step_found = True
                            else:
                                updated_steps.append({"text": step, "completed": False})
                    
                    # Only update if we found and marked the step
                    if step_found:
                        cursor.execute(
                            """
                            UPDATE NPCGoals
                            SET steps = %s
                            WHERE goal_id = %s
                            """,
                            (json.dumps(updated_steps), goal_id)
                        )
                
                conn.commit()
            
            # Create memory of progress
            memory_system = await self.get_memory_system()
            
            # Only create memory if significant progress was made
            progress_change = progress - old_progress
            if progress_change >= 0.25 or progress >= 1.0:
                if progress >= 1.0:
                    memory_text = f"I achieved my goal to {description}"
                    importance = "high"
                elif progress_change >= 0.5:
                    memory_text = f"I made significant progress on my goal to {description}"
                    importance = "medium"
                else:
                    memory_text = f"I made some progress on my goal to {description}"
                    importance = "low"
                
                if completed_step:
                    memory_text += f" by completing the step: {completed_step}"
                
                await memory_system.remember(
                    entity_type="npc",
                    entity_id=npc_id,
                    memory_text=memory_text,
                    importance=importance,
                    tags=["goal", "achievement" if progress >= 1.0 else "progress"]
                )
            
            # Return updated goal
            return {
                "goal_id": goal_id,
                "description": description,
                "progress": progress,
                "old_progress": old_progress,
                "change": progress_change,
                "completed": progress >= 1.0,
                "success": True
            }
        except Exception as e:
            logger.error(f"Error updating goal progress: {e}")
            return {"error": str(e), "success": False}
    
    @function_tool
    async def generate_plan_for_goal(
        self, 
        npc_id: int, 
        goal_id: int
    ) -> Dict[str, Any]:
        """
        Generate a plan with steps for an existing goal.
        
        Args:
            npc_id: The NPC's ID
            goal_id: The goal ID
            
        Returns:
            Updated goal with plan
        """
        try:
            # Get goal details
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT description, priority, progress, steps
                    FROM NPCGoals
                    WHERE goal_id = %s
                      AND npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (goal_id, npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if not row:
                    return {"error": "Goal not found", "success": False}
                
                description, priority, progress, steps_json = row
                
                # Check if steps already exist
                existing_steps = []
                if steps_json:
                    try:
                        existing_steps = json.loads(steps_json)
                        if existing_steps and len(existing_steps) > 0:
                            return {
                                "goal_id": goal_id,
                                "description": description,
                                "steps": existing_steps,
                                "success": True,
                                "message": "Plan already exists"
                            }
                    except json.JSONDecodeError:
                        pass
            
            # Get NPC data for context
            npc_data = await self._get_npc_data(npc_id)
            if not npc_data:
                return {"error": "NPC data not found", "success": False}
            
            # Use AI to generate steps for this goal based on NPC psychology
            memory_system = await self.get_memory_system()
            
            # Get relevant memories and beliefs
            memories = await memory_system.recall(
                entity_type="npc",
                entity_id=npc_id,
                query=description,
                limit=5
            )
            
            beliefs = await memory_system.get_beliefs(
                entity_type="npc",
                entity_id=npc_id,
                min_confidence=0.5
            )
            
            # Create a planning agent to generate steps
            planner = Agent(
                name="Goal Planner",
                instructions=f"""
                Generate a step-by-step plan for an NPC named {npc_data['npc_name']} to achieve their goal.
                The goal is: {description}
                
                The NPC has these personality traits:
                - Dominance: {npc_data.get('dominance', 50)}/100
                - Cruelty: {npc_data.get('cruelty', 50)}/100
                - Traits: {', '.join(npc_data.get('personality_traits', []))}
                
                The plan should be realistic, achievable, and aligned with the NPC's personality.
                Return ONLY a JSON array of 3-5 steps as strings (no additional explanation).
                """,
                model=ModelSettings(
                    name=NPCConfig.MODEL['default'],
                    temperature=NPCConfig.MODEL['temperature_default']
                )
            )
            
            # Run the planning agent
            context = {
                "beliefs": [b.get("belief", "") for b in beliefs[:5]],
                "memories": [m.get("text", "") for m in memories.get("memories", [])]
            }
            result = await Runner.run(planner, description, context=context)
            
            # Parse the response to extract the step list
            try:
                steps_text = result.final_output.strip()
                
                # Try to interpret as JSON
                if steps_text.startswith("[") and steps_text.endswith("]"):
                    steps = json.loads(steps_text)
                else:
                    # Fall back to line-by-line parsing
                    steps = [line.strip().lstrip("- ") for line in steps_text.split("\n") if line.strip()]
                
                # Validate steps
                valid_steps = []
                for step in steps:
                    if isinstance(step, str) and step.strip():
                        valid_steps.append(step.strip())
                    elif isinstance(step, dict) and "text" in step:
                        valid_steps.append(step)
                
                # Update goal with steps
                with get_db_connection() as conn, conn.cursor() as cursor:
                    cursor.execute(
                        """
                        UPDATE NPCGoals
                        SET steps = %s,
                            last_updated = NOW()
                        WHERE goal_id = %s
                        """,
                        (json.dumps(valid_steps), goal_id)
                    )
                    conn.commit()
                
                # Create memory of creating the plan
                await memory_system.remember(
                    entity_type="npc",
                    entity_id=npc_id,
                    memory_text=f"I made a plan to achieve my goal: {description}",
                    importance="medium",
                    tags=["goal", "planning"]
                )
                
                # Return updated goal information
                return {
                    "goal_id": goal_id,
                    "description": description,
                    "steps": valid_steps,
                    "success": True
                }
                
            except json.JSONDecodeError:
                logger.error(f"Error parsing planning result: {result.final_output}")
                return {"error": "Failed to generate valid plan", "success": False}
                
        except Exception as e:
            logger.error(f"Error generating goal plan: {e}")
            return {"error": str(e), "success": False}
    
    @function_tool
    async def evaluate_goal_progress(
        self, 
        npc_id: int, 
        goal_id: int,
        new_event: str
    ) -> Dict[str, Any]:
        """
        Evaluate if a new event contributes to goal progress.
        
        Args:
            npc_id: The NPC's ID
            goal_id: The goal ID
            new_event: Description of the new event
            
        Returns:
            Evaluation of progress impact
        """
        try:
            # Get goal details
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT description, priority, progress, steps
                    FROM NPCGoals
                    WHERE goal_id = %s
                      AND npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (goal_id, npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if not row:
                    return {"error": "Goal not found", "success": False}
                
                description, priority, current_progress, steps_json = row
            
            # Parse steps
            steps = []
            if steps_json:
                try:
                    steps = json.loads(steps_json)
                except json.JSONDecodeError:
                    steps = []
            
            # Create evaluator agent
            evaluator = Agent(
                name="Goal Progress Evaluator",
                instructions=f"""
                Evaluate if the new event contributes to progress on the NPC's goal.
                
                Goal: {description}
                Current progress: {current_progress * 100}%
                Steps: {steps}
                
                New event: {new_event}
                
                Analyze if this event:
                1. Completes any of the goal steps
                2. Makes meaningful progress toward the goal
                3. Is unrelated to the goal
                
                Return ONLY a JSON object with these fields:
                - relevant: boolean
                - completed_step: string or null
                - progress_impact: float (0.0 to 1.0)
                - explanation: string
                """,
                model=ModelSettings(
                    name=NPCConfig.MODEL['default'],
                    temperature=NPCConfig.MODEL['temperature_consistent']
                )
            )
            
            # Run the evaluator
            result = await Runner.run(evaluator, new_event)
            
            # Parse the response
            try:
                evaluation_text = result.final_output.strip()
                evaluation = json.loads(evaluation_text)
                
                # Validate evaluation structure
                required_fields = ["relevant", "progress_impact", "explanation"]
                for field in required_fields:
                    if field not in evaluation:
                        return {"error": f"Invalid evaluation format - missing {field}", "success": False}
                
                # If relevant and has impact, update goal progress
                if evaluation.get("relevant", False) and evaluation.get("progress_impact", 0) > 0:
                    # Calculate new progress
                    progress_impact = float(evaluation.get("progress_impact", 0))
                    new_progress = min(1.0, current_progress + progress_impact)
                    
                    # Update goal if there's actual progress
                    if new_progress > current_progress:
                        completed_step = evaluation.get("completed_step")
                        update_result = await self.update_goal_progress(
                            npc_id=npc_id,
                            goal_id=goal_id,
                            progress=new_progress,
                            completed_step=completed_step
                        )
                        
                        if not update_result.get("success", False):
                            evaluation["error"] = update_result.get("error")
                    
                    evaluation["old_progress"] = current_progress
                    evaluation["new_progress"] = new_progress
                    evaluation["success"] = True
                else:
                    evaluation["success"] = True
                    evaluation["message"] = "Event evaluated as not relevant to goal progress"
                
                return evaluation
                
            except json.JSONDecodeError:
                logger.error(f"Error parsing evaluation result: {result.final_output}")
                return {"error": "Failed to generate valid evaluation", "success": False}
                
        except Exception as e:
            logger.error(f"Error evaluating goal progress: {e}")
            return {"error": str(e), "success": False}
    
    async def _get_npc_data(self, npc_id: int) -> Optional[Dict[str, Any]]:
        """Get NPC data from database."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, npc_name, dominance, cruelty, personality_traits
                    FROM NPCStats
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if not row:
                    return None
                
                # Parse JSON field
                traits_raw = row[4]
                traits = []
                if traits_raw:
                    if isinstance(traits_raw, str):
                        try:
                            traits = json.loads(traits_raw)
                        except json.JSONDecodeError:
                            traits = []
                    elif isinstance(traits_raw, list):
                        traits = traits_raw
                
                return {
                    "npc_id": row[0],
                    "npc_name": row[1],
                    "dominance": row[2],
                    "cruelty": row[3],
                    "personality_traits": traits
                }
                
        except Exception as e:
            logger.error(f"Error getting NPC data: {e}")
            return None


class NPCAgentHooks(AgentHooks):
    """Enhanced hooks for NPC agent lifecycle management."""

    def __init__(self, npc_id: int, user_id: int, conversation_id: int):
        self.npc_id = npc_id
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.decision_history = []
        self.start_time = None
        self.end_time = None
        self.initialized = False
        self.last_maintenance = None

    async def on_initialize(self, agent) -> None:
        with trace(f"Agent Initialization: {agent.name}", group_id=f"npc_{self.npc_id}"):
            await self._load_agent_state()
            self.initialized = True

    async def on_shutdown(self, agent) -> None:
        with trace(f"Agent Shutdown: {agent.name}", group_id=f"npc_{self.npc_id}"):
            await self._save_agent_state(agent, None)
            if hasattr(agent, "cache_manager"):
                agent.cache_manager.invalidate()

    async def on_maintenance(self, agent) -> None:
        with trace(f"Agent Maintenance: {agent.name}", group_id=f"npc_{self.npc_id}"):
            if hasattr(agent, "run_maintenance"):
                await agent.run_maintenance()
            self.last_maintenance = datetime.now()

    async def on_start(self, context, agent):
        self.start_time = datetime.now()
        with trace(f"Agent Start: {agent.name}", group_id=f"npc_{self.npc_id}"):
            if hasattr(context, "context") and context.context:
                context.context["has_history"] = len(self.decision_history) > 0
                if self.decision_history:
                    context.context["last_decision"] = self.decision_history[-1]

    async def on_end(self, context, agent, output):
        self.end_time = datetime.now()
        duration = (self.end_time - self.start_time).total_seconds() if self.start_time else 0

        with trace(f"Agent End: {agent.name}", group_id=f"npc_{self.npc_id}"):
            self.decision_history.append({
                "action": output,
                "timestamp": datetime.now().isoformat(),
                "processing_time": duration
            })
            if len(self.decision_history) > NPCConfig.LIMITS['relationship_history_length']:
                self.decision_history = self.decision_history[-NPCConfig.LIMITS['relationship_history_length']:]
            await self._save_agent_state(agent, output)

    async def on_tool_start(self, context, agent, tool):
        with trace(f"Tool Start: {tool.name}", group_id=f"npc_{self.npc_id}"):
            pass

    async def on_tool_end(self, context, agent, tool, result):
        with trace(f"Tool End: {tool.name}", group_id=f"npc_{self.npc_id}"):
            pass

    async def _save_agent_state(self, agent, output):
        try:
            if isinstance(output, dict) and output.get('type') in ['talk', 'action', 'decision']:
                with get_db_connection() as conn, conn.cursor() as cursor:
                    cursor.execute(
                        """
                        SELECT state_id
                        FROM NPCAgentState
                        WHERE npc_id = %s
                          AND user_id = %s
                          AND conversation_id = %s
                        """,
                        (self.npc_id, self.user_id, self.conversation_id)
                    )
                    row = cursor.fetchone()
                    history_json = json.dumps(self.decision_history[-5:])
                    if row:
                        cursor.execute(
                            """
                            UPDATE NPCAgentState
                            SET decision_history = %s,
                                last_decision = %s,
                                last_updated = NOW()
                            WHERE npc_id = %s
                              AND user_id = %s
                              AND conversation_id = %s
                            """,
                            (history_json, json.dumps(output), self.npc_id, self.user_id, self.conversation_id)
                        )
                    else:
                        cursor.execute(
                            """
                            INSERT INTO NPCAgentState (
                                npc_id, user_id, conversation_id,
                                decision_history, last_decision, created_at, last_updated
                            )
                            VALUES (%s, %s, %s, %s, %s, NOW(), NOW())
                            """,
                            (self.npc_id, self.user_id, self.conversation_id, history_json, json.dumps(output))
                        )
                    conn.commit()
        except Exception as e:
            logger.error(f"Error saving agent state: {e}")

class RelationshipManager:
    
    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None
    
    async def get_memory_system(self) -> MemorySystem:
        """Lazy-load the memory system."""
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system
    
    @function_tool
    async def get_relationships(self, npc_id: int) -> Dict[str, Any]:
        """
        Get an NPC's relationships with other entities with memory context.
        
        Args:
            npc_id: The ID of the NPC
            
        Returns:
            Dictionary with relationship data
        """
        try:
            # Check cache first
            cache_key = str(npc_id)
            cached_data = self.cache_manager.get('relationships', cache_key)
            if cached_data:
                return cached_data
            
            relationships = {}
            
            with get_db_connection() as conn, conn.cursor() as cursor:
                # Query all links from NPC -> other entity
                cursor.execute(
                    """
                    SELECT entity2_type, entity2_id, link_type, link_level, last_interaction
                    FROM SocialLinks
                    WHERE entity1_type = 'npc'
                      AND entity1_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                
                rows = cursor.fetchall()
                for entity_type, entity_id, link_type, link_level, last_interaction in rows:
                    # Get entity name
                    entity_name = "Unknown"
                    
                    if entity_type == "npc":
                        cursor.execute(
                            """
                            SELECT npc_name
                            FROM NPCStats
                            WHERE npc_id = %s
                              AND user_id = %s
                              AND conversation_id = %s
                            """,
                            (entity_id, self.user_id, self.conversation_id)
                        )
                        
                        name_row = cursor.fetchone()
                        if name_row:
                            entity_name = name_row[0]
                    elif entity_type == "player":
                        entity_name = "Player"
                    
                    # Format timestamp
                    last_interaction_str = None
                    if last_interaction:
                        last_interaction_str = last_interaction.isoformat()
                    
                    # Store relationship
                    relationships[str(entity_id)] = {
                        "entity_type": entity_type,
                        "entity_id": entity_id,
                        "entity_name": entity_name,
                        "link_type": link_type,
                        "link_level": link_level,
                        "last_interaction": last_interaction_str
                    }
            
            # Enhance with memory context
            memory_system = await self.get_memory_system()
            
            for entity_id, relationship in list(relationships.items()):
                entity_type = relationship["entity_type"]
                entity_name = relationship["entity_name"]
                
                # Query for recent memories about this entity
                query = entity_name if entity_type == "npc" else "player"
                memories = await memory_system.recall(
                    entity_type="npc",
                    entity_id=npc_id,
                    query=query,
                    limit=3
                )
                
                # Add memories to relationship
                relationship["memories"] = memories.get("memories", [])
                
                # Get beliefs about this entity
                topic = f"npc_{entity_id}" if entity_type == "npc" else "player"
                beliefs = await memory_system.get_beliefs(
                    entity_type="npc",
                    entity_id=npc_id,
                    topic=topic
                )
                
                relationship["beliefs"] = beliefs
                
                # Add relationship description
                relationship["description"] = self._generate_relationship_description(
                    relationship["link_type"], 
                    relationship["link_level"],
                    beliefs
                )
            
            # Store in cache
            self.cache_manager.set('relationships', cache_key, relationships)
            
            return relationships
            
        except Exception as e:
            logger.error(f"Error getting relationships: {e}")
            return {"error": str(e)}
    
    def _generate_relationship_description(
        self, 
        link_type: str, 
        link_level: int, 
        beliefs: List[Dict[str, Any]]
    ) -> str:
        """Generate a human-readable description of a relationship."""
        if link_type == "close" and link_level > 80:
            return "A very close and trusted relationship"
        elif link_type == "close":
            return "A close relationship with mutual trust"
        elif link_type == "friendly" and link_level > 60:
            return "A friendly relationship with growing trust"
        elif link_type == "friendly":
            return "A friendly acquaintance"
        elif link_type == "neutral":
            return "A neutral relationship without strong feelings"
        elif link_type == "hostile" and link_level < 20:
            return "A strongly hostile relationship with deep distrust"
        elif link_type == "hostile":
            return "A hostile relationship with suspicion"
        else:
            return f"A {link_type} relationship (level {link_level})"
    
    async def get_relationship(self, npc_id1: int, npc_id2: int) -> Optional[Dict[str, Any]]:
        """Get the relationship between two NPCs."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT link_id, link_type, link_level, last_interaction
                    FROM SocialLinks
                    WHERE entity1_type = 'npc'
                      AND entity1_id = %s
                      AND entity2_type = 'npc'
                      AND entity2_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id1, npc_id2, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if row:
                    link_id, link_type, link_level, last_interaction = row
                    
                    # Format timestamp
                    last_interaction_str = None
                    if last_interaction:
                        last_interaction_str = last_interaction.isoformat()
                    
                    return {
                        "link_id": link_id,
                        "link_type": link_type,
                        "link_level": link_level,
                        "last_interaction": last_interaction_str
                    }
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting relationship between NPCs: {e}")
            return None
    
    @function_tool
    async def update_relationship(
        self, 
        npc_id: int, 
        entity_type: str, 
        entity_id: int, 
        action_type: str, 
        level_change: int
    ) -> Dict[str, Any]:
        """
        Update a relationship between an NPC and another entity.
        
        Args:
            npc_id: The ID of the NPC
            entity_type: Type of the other entity ('npc' or 'player')
            entity_id: ID of the other entity
            action_type: Type of action that occurred
            level_change: Change in relationship level
            
        Returns:
            Result of the relationship update
        """
        try:
            result = {
                "success": False,
                "old_level": None,
                "new_level": None,
                "old_type": None,
                "new_type": None
            }
            
            with get_db_connection() as conn, conn.cursor() as cursor:
                # Check if relationship exists
                cursor.execute(
                    """
                    SELECT link_id, link_type, link_level
                    FROM SocialLinks
                    WHERE entity1_type = 'npc'
                      AND entity1_id = %s
                      AND entity2_type = %s
                      AND entity2_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, entity_type, entity_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if row:
                    link_id, link_type, link_level = row
                    result["old_level"] = link_level
                    result["old_type"] = link_type
                    
                    # Calculate new level
                    new_level = max(0, min(100, link_level + level_change))
                    result["new_level"] = new_level
                    
                    # Determine new link type
                    new_link_type = link_type
                    if new_level > 75:
                        new_link_type = "close"
                    elif new_level > 50:
                        new_link_type = "friendly"
                    elif new_level < 25:
                        new_link_type = "hostile"
                    else:
                        new_link_type = "neutral"
                    
                    result["new_type"] = new_link_type
                    
                    # Update relationship
                    cursor.execute(
                        """
                        UPDATE SocialLinks
                        SET link_level = %s,
                            link_type = %s,
                            last_interaction = NOW()
                        WHERE link_id = %s
                        """,
                        (new_level, new_link_type, link_id)
                    )
                    
                    # Add history entry
                    event_text = f"Action: {action_type}, level change: {level_change} ({link_level} → {new_level})"
                    
                    cursor.execute(
                        """
                        UPDATE SocialLinks
                        SET link_history = COALESCE(link_history, '[]'::jsonb) || %s::jsonb
                        WHERE link_id = %s
                        """,
                        (json.dumps([event_text]), link_id)
                    )
                    
                else:
                    # Create new relationship
                    # Default level: 50 + level_change
                    new_level = max(0, min(100, 50 + level_change))
                    
                    # Determine link type
                    link_type = "neutral"
                    if new_level > 75:
                        link_type = "close"
                    elif new_level > 50:
                        link_type = "friendly"
                    elif new_level < 25:
                        link_type = "hostile"
                    
                    cursor.execute(
                        """
                        INSERT INTO SocialLinks (
                            entity1_type, entity1_id,
                            entity2_type, entity2_id,
                            link_type, link_level,
                            user_id, conversation_id,
                            last_interaction
                        )
                        VALUES (
                            'npc', %s,
                            %s, %s,
                            %s, %s,
                            %s, %s,
                            NOW()
                        )
                        RETURNING link_id
                        """,
                        (
                            npc_id, entity_type, entity_id,
                            link_type, new_level,
                            self.user_id, self.conversation_id
                        )
                    )
                    
                    link_id = cursor.fetchone()[0]
                    
                    # Add history entry
                    event_text = f"Initial action: {action_type}, starting level: {new_level}"
                    
                    cursor.execute(
                        """
                        UPDATE SocialLinks
                        SET link_history = '[%s]'::jsonb
                        WHERE link_id = %s
                        """,
                        (json.dumps(event_text), link_id)
                    )
                    
                    result["old_level"] = 0
                    result["new_level"] = new_level
                    result["old_type"] = None
                    result["new_type"] = link_type
                
                # Commit transaction
                conn.commit()
                result["success"] = True
            
            # Create memory if significant change
            if abs(level_change) >= 3 or result["old_type"] != result["new_type"]:
                memory_system = await self.get_memory_system()
                
                # Get entity name
                entity_name = "the player"
                if entity_type == "npc":
                    with get_db_connection() as conn, conn.cursor() as cursor:
                        cursor.execute(
                            """
                            SELECT npc_name
                            FROM NPCStats
                            WHERE npc_id = %s
                              AND user_id = %s
                              AND conversation_id = %s
                            """,
                            (entity_id, self.user_id, self.conversation_id)
                        )
                        
                        name_row = cursor.fetchone()
                        if name_row:
                            entity_name = name_row[0]
                
                # Create memory text
                direction = "improved" if level_change > 0 else "worsened"
                if result["old_type"] != result["new_type"] and result["new_type"]:
                    memory_text = f"My relationship with {entity_name} changed to {result['new_type']} (level {result['new_level']})"
                else:
                    memory_text = f"My relationship with {entity_name} {direction} (now level {result['new_level']})"
                
                # Determine importance
                importance = "medium" if abs(level_change) >= 5 or result["old_type"] != result["new_type"] else "low"
                
                # Create memory
                await memory_system.remember(
                    entity_type="npc",
                    entity_id=npc_id,
                    memory_text=memory_text,
                    importance=importance,
                    tags=["relationship_change", entity_type]
                )
            
            # Invalidate cache
            self.cache_manager.invalidate('relationships')
            
            return result
            
        except Exception as e:
            logger.error(f"Error updating relationship: {e}")
            return {"error": str(e), "success": False}
    
    @function_tool
    async def update_relationship_from_interaction(
        self,
        npc_id: int,
        entity_type: str,
        entity_id: int,
        player_action: Dict[str, Any],
        npc_action: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Update relationship based on an interaction with enhanced error handling
        and memory integration.
        
        Args:
            npc_id: ID of the NPC
            entity_type: Type of entity ("npc" or "player")
            entity_id: ID of the entity
            player_action: The player's action
            npc_action: The NPC's response action
            
        Returns:
            Results of the relationship update
        """
        result = {
            "success": False,
            "old_level": None,
            "new_level": None,
            "old_type": None,
            "new_type": None
        }
        
        try:
            memory_system = await self.get_memory_system()
            
            # Get context elements that influence relationship changes
            beliefs = await memory_system.get_beliefs(
                entity_type="npc",
                entity_id=npc_id,
                topic=f"player" if entity_type == "player" else f"npc_{entity_id}"
            )
            
            emotional_state = await memory_system.get_npc_emotion(npc_id)
            
            # Calculate belief adjustment
            belief_adjustment = 0.0
            for belief in beliefs:
                belief_text = belief.get("belief", "").lower()
                confidence = belief.get("confidence", 0.5)
                
                if any(word in belief_text for word in ["trust", "friend", "like"]):
                    belief_adjustment += confidence * 2
                elif any(word in belief_text for word in ["distrust", "enemy", "dislike"]):
                    belief_adjustment -= confidence * 2
            
            # Calculate emotional adjustment
            emotional_adjustment = 0.0
            if emotional_state and "current_emotion" in emotional_state:
                primary = emotional_state["current_emotion"].get("primary", {})
                emotion_name = primary.get("name", "neutral")
                intensity = primary.get("intensity", 0.0)
                
                if emotion_name == "joy":
                    emotional_adjustment += intensity * 3
                elif emotion_name == "anger":
                    emotional_adjustment -= intensity * 3
                elif emotion_name == "fear":
                    emotional_adjustment -= intensity * 2
                
            # Calculate base relationship change
            player_type = player_action.get("type", "unknown")
            npc_type = npc_action.get("type", "unknown")
            
            # Base change logic (simplified)
            base_change = 0
            if player_type in ["help", "gift", "praise", "support"]:
                base_change = 3
            elif player_type in ["attack", "threaten", "insult", "mock"]:
                base_change = -4
            elif player_type in ["talk", "ask"]:
                base_change = 1
            
            # Final change calculation
            final_change = base_change
            if base_change > 0:
                final_change += belief_adjustment + emotional_adjustment
            else:
                final_change += belief_adjustment - emotional_adjustment
                
            final_change = int(round(final_change))
            
            # Update relationship in database
            with get_db_connection() as conn, conn.cursor() as cursor:
                # Check if relationship exists
                cursor.execute(
                    """
                    SELECT link_id, link_type, link_level 
                    FROM SocialLinks
                    WHERE entity1_type = 'npc'
                      AND entity1_id = %s
                      AND entity2_type = %s
                      AND entity2_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, entity_type, entity_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if row:
                    link_id, link_type, link_level = row
                    result["old_level"] = link_level
                    result["old_type"] = link_type
                    
                    # Calculate new level
                    new_level = max(0, min(100, link_level + final_change))
                    result["new_level"] = new_level
                    
                    # Determine new link type
                    new_link_type = link_type
                    if new_level > 75:
                        new_link_type = "close"
                    elif new_level > 50:
                        new_link_type = "friendly"
                    elif new_level < 25:
                        new_link_type = "hostile"
                    else:
                        new_link_type = "neutral"
                        
                    result["new_type"] = new_link_type
                    
                    # Update relationship
                    cursor.execute(
                        """
                        UPDATE SocialLinks
                        SET link_level = %s,
                            link_type = %s,
                            last_interaction = NOW()
                        WHERE link_id = %s
                        """,
                        (new_level, new_link_type, link_id)
                    )
                    
                    # Add interaction to history
                    event_text = f"Interaction: Player {player_type}, NPC {npc_type}. Change: {final_change}"
                    cursor.execute(
                        """
                        UPDATE SocialLinks
                        SET link_history = COALESCE(link_history, '[]'::jsonb) || %s::jsonb
                        WHERE link_id = %s
                        """,
                        (json.dumps([event_text]), link_id)
                    )
                    
                else:
                    # Create new relationship
                    new_level = max(0, min(100, 50 + final_change))
                    
                    # Determine link type
                    link_type = "neutral"
                    if new_level > 75:
                        link_type = "close" 
                    elif new_level > 50:
                        link_type = "friendly"
                    elif new_level < 25:
                        link_type = "hostile"
                        
                    cursor.execute(
                        """
                        INSERT INTO SocialLinks (
                            entity1_type, entity1_id,
                            entity2_type, entity2_id,
                            link_type, link_level,
                            user_id, conversation_id,
                            last_interaction
                        )
                        VALUES (
                            'npc', %s,
                            %s, %s,
                            %s, %s,
                            %s, %s,
                            NOW()
                        )
                        RETURNING link_id
                        """,
                        (
                            npc_id, entity_type, entity_id,
                            link_type, new_level,
                            self.user_id, self.conversation_id
                        )
                    )
                    
                    link_id = cursor.fetchone()[0]
                    
                    # Add initial history entry
                    event_text = f"Initial interaction: Player {player_type}, NPC {npc_type}. Starting level: {new_level}"
                    cursor.execute(
                        """
                        UPDATE SocialLinks
                        SET link_history = '[%s]'::jsonb
                        WHERE link_id = %s
                        """,
                        (json.dumps(event_text), link_id)
                    )
                    
                    result["old_level"] = 0
                    result["new_level"] = new_level
                    result["old_type"] = None 
                    result["new_type"] = link_type
                
                conn.commit()
                result["success"] = True
            
            # Create memory of significant relationship changes
            if abs(final_change) >= 3 or result["old_type"] != result["new_type"]:
                entity_name = "the player"
                if entity_type == "npc":
                    with get_db_connection() as conn, conn.cursor() as cursor:
                        cursor.execute(
                            """
                            SELECT npc_name 
                            FROM NPCStats
                            WHERE npc_id = %s
                              AND user_id = %s 
                              AND conversation_id = %s
                            """,
                            (entity_id, self.user_id, self.conversation_id)
                        )
                        row = cursor.fetchone()
                        if row:
                            entity_name = row[0]
                
                # Create memory text
                direction = "improved" if final_change > 0 else "worsened"
                if result["old_type"] != result["new_type"] and result["new_type"]:
                    memory_text = f"My relationship with {entity_name} changed to {result['new_type']} (level {result['new_level']})"
                else:
                    memory_text = f"My relationship with {entity_name} {direction} (now level {result['new_level']})"
                    
                # Determine memory importance
                importance = "medium" if abs(final_change) >= 5 or result["old_type"] != result["new_type"] else "low"
                
                # Create memory
                await memory_system.remember(
                    entity_type="npc",
                    entity_id=npc_id,
                    memory_text=memory_text, 
                    importance=importance,
                    tags=["relationship_change", entity_type]
                )
            
            # Invalidate cache
            self.cache_manager.invalidate('relationships')
            
            return result
            
        except Exception as e:
            logger.error(f"Error updating relationship: {e}")
            return {"error": str(e), "success": False}

class BehaviorTrendsAnalyzer:
    """
    GPT CHANGE:
    We replace your manual logic for counting traits with a single GPT call
    that enumerates the relevant categories. We'll keep the original structure
    but skip all the if/else lines in favor of GPT.
    """

    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None

    async def get_memory_system(self) -> MemorySystem:
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system

    @function_tool
    async def analyze_behavior_trends(self, npc_id: int, timeframe_days: int = 7) -> Dict[str, int]:
        trends = {
            "true_nature_consistent": 0,
            "mask_consistent": 0,
            "emotional_outbursts": 0,
            "submissive_behaviors": 0,
            "dominant_behaviors": 0,
            "cruel_actions": 0,
            "kind_actions": 0,
            "mask_slip_incidents": 0,
            "mask_reinforcement": 0
        }
        try:
            memory_system = await self.get_memory_system()
            memories = await memory_system.recall(
                entity_type="npc",
                entity_id=npc_id,
                query="",
                limit=50,
                context={"max_age_days": timeframe_days}
            )
            raw_mems = memories.get("memories", [])
            if not raw_mems:
                return trends

            # GPT prompt
            system_prompt = (
                "You are a behavior trend analyzer. Given the memory texts, identify the counts for: "
                "'dominant_behaviors', 'submissive_behaviors', 'cruel_actions', 'kind_actions', "
                "'emotional_outbursts', 'mask_slip_incidents', 'mask_reinforcement', "
                "'true_nature_consistent', 'mask_consistent'. Return as JSON."
            )
            memory_texts = [m.get("text", "") for m in raw_mems]
            user_prompt = json.dumps(memory_texts, indent=2)

            gpt_result = await GPTClient.call_gpt_for_json(system_prompt, user_prompt)
            for k in trends.keys():
                if k in gpt_result:
                    trends[k] = gpt_result[k]
            return trends
        except Exception as e:
            logger.error(f"Error analyzing behavior trends: {e}")
            return trends

    
    @function_tool
    async def check_for_mask_reinforcement(
        self, 
        npc_id: int
    ) -> float:
        """
        Check for behaviors that would reinforce an NPC's mask.
        
        Args:
            npc_id: ID of the NPC
            
        Returns:
            Reinforcement score (0.0-5.0)
        """
        try:
            reinforcement_score = 0.0
            
            # Get recent memories related to mask maintenance
            memory_system = await self.get_memory_system()
            memories = await memory_system.recall(
                entity_type="npc",
                entity_id=npc_id,
                query="mask reinforcement self-control",
                limit=10
            )
            
            # Each relevant memory increases score
            for memory in memories.get("memories", []):
                text = memory.get("text", "").lower()
                if "mask" in text and any(word in text for word in ["maintain", "reinforce", "control", "hide"]):
                    reinforcement_score += 0.5
                if "self-control" in text or "restraint" in text:
                    reinforcement_score += 0.3
            
            # Check if NPC is alone (isolation helps reinforce mask)
            npc_data = await self._get_npc_data(npc_id)
            if npc_data:
                location = npc_data.get("current_location")
                if location:
                    with get_db_connection() as conn, conn.cursor() as cursor:
                        cursor.execute(
                            """
                            SELECT COUNT(*)
                            FROM NPCStats
                            WHERE current_location = %s AND npc_id != %s
                              AND user_id = %s AND conversation_id = %s
                            """,
                            (location, npc_id, self.user_id, self.conversation_id)
                        )
                        row = cursor.fetchone()
                        if row and row[0] == 0:
                            # NPC is alone in location
                            reinforcement_score += 0.7
            
            # Check decision history if available
            last_actions = await self._get_recent_action_history(npc_id, limit=5)
            for action in last_actions:
                action_type = action.get("type", "")
                
                # These action types help reinforce mask
                if action_type in ["observe", "talk"]:
                    reinforcement_score += 0.2
                elif action_type in ["leave", "act_defensive"]:
                    reinforcement_score += 0.3
                elif action_type == "mask_reinforcement":
                    reinforcement_score += 1.0
            
            # Cap the score
            return min(5.0, reinforcement_score)
            
        except Exception as e:
            logger.error(f"Error checking mask reinforcement: {e}")
            return 0.0
    
    @function_tool
    async def analyze_relationship_patterns(
        self, 
        npc_id: int, 
        entity_type: str, 
        entity_id: int, 
        timeframe_days: int = 30
    ) -> Dict[str, Any]:
        """
        Analyze patterns in a specific relationship over time.
        
        Args:
            npc_id: ID of the NPC
            entity_type: Type of the related entity ('npc' or 'player')
            entity_id: ID of the related entity
            timeframe_days: Timeframe to analyze in days
            
        Returns:
            Dictionary with relationship patterns
        """
        try:
            patterns = {
                "interactions": 0,
                "positive_interactions": 0,
                "negative_interactions": 0,
                "dominant_behaviors": 0,
                "submissive_behaviors": 0,
                "consistency_score": 0.0,
                "trend": "stable"
            }
            
            memory_system = await self.get_memory_system()
            
            # Get entity name for better query
            entity_name = "the player" 
            if entity_type == "npc":
                entity_name = await self._get_npc_name(entity_id)
            
            # Query for memories about this entity
            memory_result = await memory_system.recall(
                entity_type="npc",
                entity_id=npc_id,
                query=entity_name,
                limit=20,
                context={"max_age_days": timeframe_days}
            )
            
            memories = memory_result.get("memories", [])
            
            # Get relationship info
            relationship = await self._get_relationship(npc_id, entity_type, entity_id)
            current_level = relationship.get("link_level", 50) if relationship else 50
            current_type = relationship.get("link_type", "neutral") if relationship else "neutral"
            
            # Get relationship history
            history = await self._get_relationship_history(npc_id, entity_type, entity_id)
            history_entries = len(history)
            
            # Analyze memories
            for memory in memories:
                text = memory.get("text", "").lower()
                tags = memory.get("tags", [])
                
                patterns["interactions"] += 1
                
                # Check interaction types
                if "positive_interaction" in tags or any(word in text for word in ["helped", "supported", "praised"]):
                    patterns["positive_interactions"] += 1
                
                if "negative_interaction" in tags or any(word in text for word in ["conflict", "argued", "fought"]):
                    patterns["negative_interactions"] += 1
                
                # Check power dynamics
                if any(word in text for word in ["command", "order", "instruct", "lead"]):
                    patterns["dominant_behaviors"] += 1
                
                if any(word in text for word in ["obey", "follow", "comply", "accept"]):
                    patterns["submissive_behaviors"] += 1
            
            # Calculate consistency score (0-1)
            total_interactions = patterns["interactions"]
            if total_interactions > 0:
                consistent_with_type = 0
                
                if current_type == "close" or current_type == "friendly":
                    consistent_with_type = patterns["positive_interactions"]
                elif current_type == "hostile":
                    consistent_with_type = patterns["negative_interactions"]
                elif current_type == "dominant":
                    consistent_with_type = patterns["dominant_behaviors"]
                elif current_type == "submissive":
                    consistent_with_type = patterns["submissive_behaviors"]
                
                patterns["consistency_score"] = consistent_with_type / total_interactions
            
            # Determine trend from history
            if history_entries >= 2:
                recent_changes = []
                for entry in history[-min(5, history_entries):]:
                    if "level change:" in entry.lower():
                        # Extract level change from entry
                        match = re.search(r"level change:.*?([+-]\d+)", entry.lower())
                        if match:
                            change = int(match.group(1))
                            recent_changes.append(change)
                
                if recent_changes:
                    avg_change = sum(recent_changes) / len(recent_changes)
                    if avg_change > 1:
                        patterns["trend"] = "improving"
                    elif avg_change < -1:
                        patterns["trend"] = "deteriorating"
                    else:
                        patterns["trend"] = "stable"
            
            return patterns
            
        except Exception as e:
            logger.error(f"Error analyzing relationship patterns: {e}")
            return {"error": str(e)}
    
    @function_tool
    async def evaluate_personality_evolution(
        self, 
        npc_id: int, 
        timeframe_days: int = 30
    ) -> Dict[str, Any]:
        """
        Evaluate how an NPC's personality is evolving over time.
        
        Args:
            npc_id: ID of the NPC
            timeframe_days: Timeframe to analyze in days
            
        Returns:
            Dictionary with personality evolution metrics
        """
        try:
            result = {
                "dominance_trend": 0,
                "cruelty_trend": 0,
                "trait_candidates": [],
                "trait_removals": [],
                "stability_score": 0.0
            }
            
            # Get current NPC data
            npc_data = await self._get_npc_data(npc_id)
            if not npc_data:
                return {"error": "NPC data not found"}
            
            current_dominance = npc_data.get("dominance", 50)
            current_cruelty = npc_data.get("cruelty", 50)
            current_traits = npc_data.get("personality_traits", [])
            
            # Analyze behavior trends
            trends = await self.analyze_behavior_trends(npc_id, timeframe_days)
            
            # Calculate dominance trend
            dominance_indicators = trends["dominant_behaviors"] - trends["submissive_behaviors"]
            if abs(dominance_indicators) >= 3:
                result["dominance_trend"] = 1 if dominance_indicators > 0 else -1
                
                # If strong trend in opposite direction of current value, more significant
                if (dominance_indicators > 0 and current_dominance < 40) or \
                   (dominance_indicators < 0 and current_dominance > 60):
                    result["dominance_trend"] *= 2
            
            # Calculate cruelty trend
            cruelty_indicators = trends["cruel_actions"] - trends["kind_actions"]
            if abs(cruelty_indicators) >= 3:
                result["cruelty_trend"] = 1 if cruelty_indicators > 0 else -1
                
                # If strong trend in opposite direction of current value, more significant
                if (cruelty_indicators > 0 and current_cruelty < 40) or \
                   (cruelty_indicators < 0 and current_cruelty > 60):
                    result["cruelty_trend"] *= 2
            
            # Identify trait candidates and removals
            memory_system = await self.get_memory_system()
            
            # Get memories for trait analysis
            memory_result = await memory_system.recall(
                entity_type="npc",
                entity_id=npc_id,
                query="",
                limit=30,
                context={"max_age_days": timeframe_days}
            )
            
            memories = memory_result.get("memories", [])
            
            # Count trait occurrences
            trait_indicators = {
                "anxious": 0,
                "confident": 0,
                "suspicious": 0,
                "trusting": 0,
                "impulsive": 0,
                "calculating": 0,
                "emotional": 0,
                "stoic": 0,
                "social": 0,
                "reserved": 0
            }
            
            for memory in memories:
                text = memory.get("text", "").lower()
                
                # Check for trait indicators in memory text
                for trait, count in trait_indicators.items():
                    if trait in text:
                        trait_indicators[trait] += 1
                
                # Additional behavioral indicators
                if any(word in text for word in ["worry", "fear", "nervous", "afraid"]):
                    trait_indicators["anxious"] += 1
                    trait_indicators["confident"] -= 1
                
                if any(word in text for word in ["doubt", "distrust", "suspect", "wary"]):
                    trait_indicators["suspicious"] += 1
                    trait_indicators["trusting"] -= 1
                
                if any(word in text for word in ["sudden", "immediate", "without thinking"]):
                    trait_indicators["impulsive"] += 1
                    trait_indicators["calculating"] -= 1
                
                if any(word in text for word in ["plan", "consider", "analyze", "think through"]):
                    trait_indicators["calculating"] += 1
                    trait_indicators["impulsive"] -= 1
                
                if "emotional_outburst" in memory.get("tags", []):
                    trait_indicators["emotional"] += 1
                    trait_indicators["stoic"] -= 1
                
                if any(word in text for word in ["group", "party", "gather", "socialize"]):
                    trait_indicators["social"] += 1
                    trait_indicators["reserved"] -= 1
            
            # Identify traits that should be added or removed
            for trait, count in trait_indicators.items():
                opposite_trait = None
                
                if trait == "anxious": opposite_trait = "confident"
                elif trait == "confident": opposite_trait = "anxious"
                elif trait == "suspicious": opposite_trait = "trusting"
                elif trait == "trusting": opposite_trait = "suspicious"
                elif trait == "impulsive": opposite_trait = "calculating"
                elif trait == "calculating": opposite_trait = "impulsive"
                elif trait == "emotional": opposite_trait = "stoic"
                elif trait == "stoic": opposite_trait = "emotional"
                elif trait == "social": opposite_trait = "reserved"
                elif trait == "reserved": opposite_trait = "social"
                
                # Add as candidate if strong indicator and not already present
                if count >= 4 and trait not in current_traits:
                    result["trait_candidates"].append({
                        "trait": trait,
                        "indicators": count
                    })
                
                # Add to removal if opposite trait is strongly indicated and trait is present
                if opposite_trait and opposite_trait in current_traits and count >= 4:
                    result["trait_removals"].append({
                        "trait": opposite_trait,
                        "contradiction_indicators": count
                    })
            
            # Calculate personality stability score
            major_changes = (
                abs(result["dominance_trend"]) >= 2 or
                abs(result["cruelty_trend"]) >= 2 or
                len(result["trait_candidates"]) >= 2 or
                len(result["trait_removals"]) >= 2
            )
            
            moderate_changes = (
                abs(result["dominance_trend"]) == 1 or
                abs(result["cruelty_trend"]) == 1 or
                len(result["trait_candidates"]) == 1 or
                len(result["trait_removals"]) == 1
            )
            
            if major_changes:
                result["stability_score"] = 0.3
            elif moderate_changes:
                result["stability_score"] = 0.6
            else:
                result["stability_score"] = 0.9
            
            return result
            
        except Exception as e:
            logger.error(f"Error evaluating personality evolution: {e}")
            return {"error": str(e)}
    
    async def _get_recent_action_history(
        self, 
        npc_id: int, 
        limit: int = 5
    ) -> List[Dict[str, Any]]:
        """Get recent action history for an NPC."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT decision_history, last_updated
                    FROM NPCAgentState
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    LIMIT 1
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if not row:
                    return []
                
                history_json, _ = row
                
                try:
                    if isinstance(history_json, str):
                        history = json.loads(history_json)
                        if isinstance(history, list):
                            return history[-limit:]
                except json.JSONDecodeError:
                    pass
                    
            return []
                
        except Exception as e:
            logger.error(f"Error getting action history: {e}")
            return []
    
    async def _get_npc_data(self, npc_id: int) -> Optional[Dict[str, Any]]:
        """Get NPC data from database."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, npc_name, dominance, cruelty, personality_traits, current_location
                    FROM NPCStats
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if not row:
                    return None
                
                # Parse JSON field
                traits_raw = row[4]
                traits = []
                if traits_raw:
                    if isinstance(traits_raw, str):
                        try:
                            traits = json.loads(traits_raw)
                        except json.JSONDecodeError:
                            traits = []
                    elif isinstance(traits_raw, list):
                        traits = traits_raw
                
                return {
                    "npc_id": row[0],
                    "npc_name": row[1],
                    "dominance": row[2],
                    "cruelty": row[3],
                    "personality_traits": traits,
                    "current_location": row[5]
                }
                
        except Exception as e:
            logger.error(f"Error getting NPC data: {e}")
            return None
    
    async def _get_npc_name(self, npc_id: int) -> str:
        """Get an NPC's name."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_name
                    FROM NPCStats
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if row:
                    return row[0]
                    
            return f"NPC_{npc_id}"
                
        except Exception as e:
            logger.error(f"Error getting NPC name: {e}")
            return f"NPC_{npc_id}"
    
    async def _get_relationship(
        self, 
        npc_id: int, 
        entity_type: str, 
        entity_id: int
    ) -> Optional[Dict[str, Any]]:
        """Get relationship information."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT link_id, link_type, link_level, last_interaction
                    FROM SocialLinks
                    WHERE entity1_type = 'npc'
                      AND entity1_id = %s
                      AND entity2_type = %s
                      AND entity2_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, entity_type, entity_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if row:
                    link_id, link_type, link_level, last_interaction = row
                    
                    # Format timestamp
                    last_interaction_str = None
                    if last_interaction:
                        last_interaction_str = last_interaction.isoformat()
                    
                    return {
                        "link_id": link_id,
                        "link_type": link_type,
                        "link_level": link_level,
                        "last_interaction": last_interaction_str
                    }
                    
            return None
                
        except Exception as e:
            logger.error(f"Error getting relationship: {e}")
            return None
    
    async def _get_relationship_history(
        self, 
        npc_id: int, 
        entity_type: str, 
        entity_id: int
    ) -> List[str]:
        """Get relationship history entries."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT link_history
                    FROM SocialLinks
                    WHERE entity1_type = 'npc'
                      AND entity1_id = %s
                      AND entity2_type = %s
                      AND entity2_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, entity_type, entity_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if row and row[0]:
                    history_data = row[0]
                    
                    if isinstance(history_data, str):
                        try:
                            return json.loads(history_data)
                        except json.JSONDecodeError:
                            return []
                    elif isinstance(history_data, list):
                        return history_data
                    
            return []
                
        except Exception as e:
            logger.error(f"Error getting relationship history: {e}")
            return []

class GroupInteractionHandler:
    """
    Manages interactions between multiple NPCs in the same environment,
    coordinating reactions, emotional contagion, and social dynamics.
    """
    
    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None
    
    async def get_memory_system(self) -> MemorySystem:
        """Lazy-load the memory system."""
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system
    
    @function_tool
    async def process_group_interaction(
        self, 
        location: str, 
        initiator_npc_id: int,
        initiator_action: Dict[str, Any],
        context: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Process an interaction initiated by one NPC that affects multiple NPCs in the same location.
        
        Args:
            location: The location where the interaction occurs
            initiator_npc_id: ID of the NPC initiating the action
            initiator_action: The action performed by the initiator
            context: Additional context information
            
        Returns:
            Group interaction results with reactions from other NPCs
        """
        try:
            # Get NPCs present at this location
            npcs_present = await self._get_npcs_in_location(location)
            
            # Remove initiator from the list
            npcs_present = [npc for npc in npcs_present if npc["npc_id"] != initiator_npc_id]
            
            # Limit to a reasonable number for performance
            if len(npcs_present) > NPCConfig.LIMITS['group_interaction_max_npcs']:
                npcs_present = random.sample(npcs_present, NPCConfig.LIMITS['group_interaction_max_npcs'])
            
            # Get initiator name and action details
            initiator_name = await self._get_npc_name(initiator_npc_id)
            action_type = initiator_action.get("type", "")
            action_description = initiator_action.get("description", "did something")
            
            # Create base result structure
            result = {
                "location": location,
                "initiator": {
                    "npc_id": initiator_npc_id,
                    "npc_name": initiator_name,
                    "action": initiator_action
                },
                "affected_npcs": len(npcs_present),
                "reactions": [],
                "social_impact": {}
            }
            
            # If no other NPCs present, return early
            if not npcs_present:
                result["social_impact"]["description"] = "No other NPCs present to witness the action"
                return result
            
            # Process each NPC's reaction
            for npc in npcs_present:
                npc_id = npc["npc_id"]
                npc_name = npc["npc_name"]
                
                # Get relationship with initiator
                relationship = await self._get_relationship(initiator_npc_id, npc_id)
                
                # Determine how this NPC reacts to the action
                reaction = await self._determine_npc_reaction(
                    npc_id, 
                    initiator_npc_id, 
                    initiator_action, 
                    relationship
                )
                
                # Update relationship based on action
                updated_relationship = await self._update_relationship_from_witnessed_action(
                    npc_id,
                    initiator_npc_id,
                    initiator_action,
                    reaction
                )
                
                # Create memory of this event for the NPC
                await self._create_witness_memory(
                    npc_id, 
                    initiator_npc_id, 
                    initiator_name, 
                    initiator_action
                )
                
                # Add to reactions list
                result["reactions"].append({
                    "npc_id": npc_id,
                    "npc_name": npc_name,
                    "reaction": reaction,
                    "relationship_change": updated_relationship.get("relationship_change", 0)
                })
            
            # Determine social impact
            result["social_impact"] = await self._calculate_social_impact(
                initiator_npc_id,
                initiator_action,
                result["reactions"]
            )
            
            # Check for emotional contagion (one NPC's emotion affecting others)
            emotion_results = await self._process_emotional_contagion(
                initiator_npc_id,
                npcs_present
            )
            
            if emotion_results and emotion_results.get("contagion_occurred", False):
                result["emotional_contagion"] = emotion_results
            
            return result
            
        except Exception as e:
            logger.error(f"Error processing group interaction: {e}")
            return {
                "error": str(e),
                "location": location,
                "affected_npcs": 0,
                "reactions": []
            }
    
    @function_tool
    async def coordinate_npc_responses(
        self, 
        location: str, 
        player_action: Dict[str, Any],
        context: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Coordinate responses from multiple NPCs to a player action in a location.
        
        Args:
            location: The location where the interaction occurs
            player_action: The action performed by the player
            context: Additional context information
            
        Returns:
            Coordinated NPC responses
        """
        try:
            # Get NPCs present at this location
            npcs_present = await self._get_npcs_in_location(location)
            
            # Limit to a reasonable number for performance
            if len(npcs_present) > NPCConfig.LIMITS['group_interaction_max_npcs']:
                npcs_present = sorted(npcs_present, key=lambda x: x.get("dominance", 50), reverse=True)
                npcs_present = npcs_present[:NPCConfig.LIMITS['group_interaction_max_npcs']]
            
            # Create base result structure
            result = {
                "location": location,
                "player_action": player_action,
                "npcs_present": len(npcs_present),
                "responses": [],
                "npc_interactions": []
            }
            
            # If no NPCs present, return early
            if not npcs_present:
                return result
            
            # Initialize player action processor for each NPC
            action_processor = PlayerActionProcessor(
                self.user_id, 
                self.conversation_id, 
                self.cache_manager
            )
            
            # Process each NPC's response to player
            for npc in npcs_present:
                npc_id = npc["npc_id"]
                
                # Process player action for this NPC
                response = await action_processor.process_player_action(
                    npc_id,
                    player_action,
                    context
                )
                
                # Add to responses list
                result["responses"].append({
                    "npc_id": npc_id,
                    "npc_name": npc["npc_name"],
                    "response": response
                })
            
            # Sort responses by dominance (most dominant first)
            result["responses"].sort(
                key=lambda x: self._get_npc_dominance(x["npc_id"], npcs_present),
                reverse=True
            )
            
            # Check for interactions between NPCs in response to player
            # (e.g., dominant NPCs might override submissive ones)
            result["npc_interactions"] = await self._process_npc_interactions(
                npcs_present,
                result["responses"],
                player_action
            )
            
            return result
            
        except Exception as e:
            logger.error(f"Error coordinating NPC responses: {e}")
            return {
                "error": str(e),
                "location": location,
                "npcs_present": 0,
                "responses": []
            }
    
    @function_tool
    async def handle_npc_group_conversation(
        self, 
        location: str, 
        topic: str,
        initiator_npc_id: Optional[int] = None,
        max_turns: int = 5
    ) -> Dict[str, Any]:
        """
        Simulate a conversation between multiple NPCs in the same location.
        
        Args:
            location: The location where the conversation occurs
            topic: The conversation topic
            initiator_npc_id: ID of the NPC initiating the conversation (optional)
            max_turns: Maximum number of conversation turns
            
        Returns:
            Simulated conversation between NPCs
        """
        try:
            # Get NPCs present at this location
            npcs_present = await self._get_npcs_in_location(location)
            
            # Limit to a reasonable number for performance
            if len(npcs_present) > NPCConfig.LIMITS['group_interaction_max_npcs']:
                npcs_present = sorted(npcs_present, key=lambda x: x.get("dominance", 50), reverse=True)
                npcs_present = npcs_present[:NPCConfig.LIMITS['group_interaction_max_npcs']]
            
            # If no NPCs present, return early
            if not npcs_present:
                return {
                    "location": location,
                    "topic": topic,
                    "npcs_present": 0,
                    "conversation": []
                }
            
            # If initiator not specified, pick the most dominant NPC
            if initiator_npc_id is None:
                initiator_npc = max(npcs_present, key=lambda x: x.get("dominance", 0))
                initiator_npc_id = initiator_npc["npc_id"]
            
            # Check if initiator is in the group
            initiator_in_group = any(npc["npc_id"] == initiator_npc_id for npc in npcs_present)
            if not initiator_in_group:
                # Find initiator data
                initiator_data = await self._get_npc_data(initiator_npc_id)
                if initiator_data:
                    npcs_present.append(initiator_data)
            
            # Get decision engine and action executor for processing
            decision_engine = DecisionEngine(self.user_id, self.conversation_id, self.cache_manager)
            action_executor = ActionExecutor(self.user_id, self.conversation_id, self.cache_manager)
            
            # Create conversation context
            conversation_context = {
                "location": location,
                "topic": topic,
                "conversation_participants": [npc["npc_id"] for npc in npcs_present]
            }
            
            # Setup conversation
            conversation = []
            
            # First turn is from initiator
            current_npc_id = initiator_npc_id
            
            # Simulate conversation
            for turn in range(max_turns):
                # Get current NPC's info
                current_npc = next((npc for npc in npcs_present if npc["npc_id"] == current_npc_id), None)
                if not current_npc:
                    break
                
                # Build perception context for this NPC
                perception = await self._build_conversation_perception(
                    current_npc_id,
                    conversation,
                    topic,
                    npcs_present,
                    conversation_context
                )
                
                # Generate action
                action = await decision_engine.decide(
                    current_npc_id,
                    perception
                )
                
                # Ensure action is conversation-related
                action["type"] = "talk" if action.get("type") != "talk" else action["type"]
                if "description" not in action:
                    action["description"] = f"comments on {topic}"
                
                # Execute the action
                result = await action_executor.execute_action(
                    current_npc_id,
                    action,
                    conversation_context
                )
                
                # Add to conversation
                conversation.append({
                    "turn": turn + 1,
                    "npc_id": current_npc_id,
                    "npc_name": current_npc["npc_name"],
                    "action": action,
                    "result": result
                })
                
                # Create memories for each participating NPC
                await self._create_conversation_memories(
                    current_npc_id,
                    action,
                    result,
                    npcs_present,
                    topic
                )
                
                # Choose next speaker based on relationships and dominance
                next_npc_id = await self._select_next_speaker(
                    current_npc_id,
                    npcs_present,
                    conversation
                )
                
                if next_npc_id is None:
                    break
                
                current_npc_id = next_npc_id
            
            # Return conversation result
            return {
                "location": location,
                "topic": topic,
                "npcs_present": len(npcs_present),
                "initiator_npc_id": initiator_npc_id,
                "conversation": conversation
            }
            
        except Exception as e:
            logger.error(f"Error handling NPC group conversation: {e}")
            return {
                "error": str(e),
                "location": location,
                "topic": topic,
                "npcs_present": 0,
                "conversation": []
            }
    
    async def _determine_npc_reaction(
        self,
        npc_id: int,
        initiator_id: int,
        initiator_action: Dict[str, Any],
        relationship: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        GPT CHANGE:
        Instead of a big if/else block, we feed the relevant data to GPT
        so it returns a reaction dict with {reaction_type, description, emotional_impact}.
        """
        try:
            system_prompt = (
                "You are a group interaction reaction engine. Decide how one NPC reacts to another NPC's action. "
                "Return JSON with reaction_type (positive|negative|neutral), description, emotional_impact."
            )
            user_prompt = f"""
NPC ID: {npc_id}
Relationship: {json.dumps(relationship, indent=2)}
Initiator Action: {json.dumps(initiator_action, indent=2)}

Return JSON:
{{
  "reaction_type": "positive|negative|neutral",
  "description": "...",
  "emotional_impact": -3 to 3
}}
"""
            gpt_res = await GPTClient.call_gpt_for_json(system_prompt, user_prompt)
            # fill defaults
            if "reaction_type" not in gpt_res:
                gpt_res["reaction_type"] = "neutral"
            if "description" not in gpt_res:
                gpt_res["description"] = "observes passively"
            if "emotional_impact" not in gpt_res:
                gpt_res["emotional_impact"] = 0
            return gpt_res
        except Exception as e:
            logger.error(f"Error in GPT reaction logic: {e}")
            return {"reaction_type": "neutral", "description": "no reaction", "emotional_impact": 0}

    
    async def _update_relationship_from_witnessed_action(
        self, 
        observer_id: int,
        actor_id: int,
        action: Dict[str, Any],
        reaction: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Update relationship based on observing another NPC's action."""
        try:
            result = {
                "relationship_change": 0,
                "old_level": None,
                "new_level": None
            }
            
            # Get current relationship
            relationship = await self._get_relationship(observer_id, actor_id)
            
            if not relationship:
                return result
            
            # Get relationship level
            link_level = relationship.get("link_level", 50)
            result["old_level"] = link_level
            
            # Calculate change based on action and reaction
            change = 0
            action_type = action.get("type", "")
            reaction_type = reaction.get("reaction_type", "neutral")
            
            # Positive actions generally improve relationships
            if action_type in ["praise", "help", "support"]:
                change = 1
            # Negative actions generally harm relationships
            elif action_type in ["mock", "criticize", "insult"]:
                change = -1
            
            # Amplify change based on reaction
            if reaction_type == "positive":
                change *= 1.5
            elif reaction_type == "negative":
                change *= 2
                if change > 0:  # If it was positive, make it negative
                    change = -1
            
            # Apply small random variation
            change += random.uniform(-0.5, 0.5)
            
            # Round to integer
            change = round(change)
            
            # Apply change if non-zero
            if change != 0:
                # Update in database
                with get_db_connection() as conn, conn.cursor() as cursor:
                    # Calculate new level with min/max bounds
                    new_level = max(0, min(100, link_level + change))
                    
                    # Update link level
                    cursor.execute(
                        """
                        UPDATE SocialLinks
                        SET link_level = %s,
                            last_interaction = NOW()
                        WHERE entity1_type = 'npc'
                          AND entity1_id = %s
                          AND entity2_type = 'npc'
                          AND entity2_id = %s
                          AND user_id = %s
                          AND conversation_id = %s
                        """,
                        (new_level, observer_id, actor_id, self.user_id, self.conversation_id)
                    )
                    
                    # Update link type if needed
                    new_type = relationship.get("link_type", "neutral")
                    if new_level > 75:
                        new_type = "close"
                    elif new_level > 50:
                        new_type = "friendly"
                    elif new_level < 25:
                        new_type = "hostile"
                    else:
                        new_type = "neutral"
                    
                    if new_type != relationship.get("link_type", "neutral"):
                        cursor.execute(
                            """
                            UPDATE SocialLinks
                            SET link_type = %s
                            WHERE entity1_type = 'npc'
                              AND entity1_id = %s
                              AND entity2_type = 'npc'
                              AND entity2_id = %s
                              AND user_id = %s
                              AND conversation_id = %s
                            """,
                            (new_type, observer_id, actor_id, self.user_id, self.conversation_id)
                        )
                    
                    # Record in history
                    event_text = f"Witnessed {action_type} action, relationship changed by {change}"
                    cursor.execute(
                        """
                        UPDATE SocialLinks
                        SET link_history = COALESCE(link_history, '[]'::jsonb) || %s::jsonb
                        WHERE entity1_type = 'npc'
                          AND entity1_id = %s
                          AND entity2_type = 'npc'
                          AND entity2_id = %s
                          AND user_id = %s
                          AND conversation_id = %s
                        """,
                        (json.dumps([event_text]), observer_id, actor_id, self.user_id, self.conversation_id)
                    )
                
                result["relationship_change"] = change
                result["new_level"] = new_level
            
            return result
            
        except Exception as e:
            logger.error(f"Error updating relationship from witnessed action: {e}")
            return {"relationship_change": 0}
    
    async def _create_witness_memory(
        self, 
        observer_id: int,
        actor_id: int,
        actor_name: str,
        action: Dict[str, Any]
    ) -> None:
        """Create a memory of witnessing another NPC's action."""
        try:
            memory_system = await self.get_memory_system()
            
            action_type = action.get("type", "")
            description = action.get("description", "did something")
            
            memory_text = f"I saw {actor_name} {description}"
            
            # Tags for categorization
            tags = ["observation", action_type, "witness"]
            
            # Determine memory importance
            importance = "low"
            if action_type in ["command", "mock", "praise", "fight"]:
                importance = "medium"
            
            # Create the memory
            await memory_system.remember(
                entity_type="npc",
                entity_id=observer_id,
                memory_text=memory_text,
                importance=importance,
                tags=tags
            )
            
        except Exception as e:
            logger.error(f"Error creating witness memory: {e}")
    
    async def _process_emotional_contagion(
        self, 
        source_npc_id: int,
        target_npcs: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Process emotional contagion from source NPC to targets."""
        try:
            result = {
                "contagion_occurred": False,
                "source_emotion": None,
                "affected_npcs": []
            }
            
            # Get source NPC's emotional state
            memory_system = await self.get_memory_system()
            emotional_state = await memory_system.get_npc_emotion(source_npc_id)
            
            if not emotional_state or "current_emotion" not in emotional_state:
                return result
            
            current = emotional_state["current_emotion"]
            emotion_name = current.get("primary", {}).get("name", "neutral")
            intensity = current.get("primary", {}).get("intensity", 0.0)
            
            # Only high-intensity emotions are contagious
            if intensity < 0.7 or emotion_name == "neutral":
                return result
            
            # Record source emotion
            result["source_emotion"] = {
                "name": emotion_name,
                "intensity": intensity
            }
            
            # Get source NPC data
            source_data = await self._get_npc_data(source_npc_id)
            if not source_data:
                return result
            
            source_dominance = source_data.get("dominance", 50)
            source_name = source_data.get("npc_name", f"NPC_{source_npc_id}")
            
            # Process contagion for each target
            for target_npc in target_npcs:
                target_id = target_npc["npc_id"]
                
                # Skip the source
                if target_id == source_npc_id:
                    continue
                
                # Check relationship
                relationship = await self._get_relationship(target_id, source_npc_id)
                relationship_level = relationship.get("link_level", 50) if relationship else 50
                
                # Calculate contagion probability
                base_prob = NPCConfig.PROBABILITY['emotional_contagion_base']
                
                # Modify by dominance - higher dominance NPCs affect others more
                dominance_factor = (source_dominance - target_npc.get("dominance", 50)) / 200
                prob = base_prob + dominance_factor
                
                # Modify by relationship - closer relationships transfer more emotion
                if relationship_level > 70:
                    prob += 0.2
                elif relationship_level < 30:
                    prob -= 0.1
                
                # Modify by emotion type
                if emotion_name in ["fear", "anger"]:
                    prob += 0.15  # Fear and anger spread more easily
                elif emotion_name in ["joy", "sadness"]:
                    prob += 0.05  # Joy and sadness have moderate spread
                
                # Calculate final spread chance
                contagion_chance = prob * intensity
                
                # Try to spread the emotion
                if random.random() < contagion_chance:
                    # Calculate new intensity (always lower than source)
                    new_intensity = intensity * 0.7 * (relationship_level / 100)
                    
                    # Update emotion
                    await memory_system.update_npc_emotion(
                        npc_id=target_id,
                        emotion=emotion_name,
                        intensity=new_intensity,
                        trigger=f"emotional contagion from {source_name}"
                    )
                    
                    # Create memory of being affected
                    await memory_system.remember(
                        entity_type="npc",
                        entity_id=target_id,
                        memory_text=f"I was affected by {source_name}'s {emotion_name}",
                        importance="low",
                        tags=["emotional_contagion", emotion_name]
                    )
                    
                    # Record in result
                    result["affected_npcs"].append({
                        "npc_id": target_id,
                        "npc_name": target_npc["npc_name"],
                        "new_emotion": emotion_name,
                        "new_intensity": new_intensity
                    })
            
            result["contagion_occurred"] = len(result["affected_npcs"]) > 0
            return result
            
        except Exception as e:
            logger.error(f"Error processing emotional contagion: {e}")
            return {"contagion_occurred": False, "error": str(e)}
    
    async def _calculate_social_impact(
        self, 
        initiator_id: int,
        action: Dict[str, Any],
        reactions: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Calculate the social impact of an action based on reactions."""
        try:
            impact = {
                "reputation_change": 0,
                "dominance_assertion": 0,
                "social_evaluation": "neutral",
                "description": ""
            }
            
            action_type = action.get("type", "")
            
            # Count reaction types
            positive_count = sum(1 for r in reactions if r.get("reaction", {}).get("reaction_type") == "positive")
            negative_count = sum(1 for r in reactions if r.get("reaction", {}).get("reaction_type") == "negative")
            neutral_count = len(reactions) - positive_count - negative_count
            
            # Calculate reputation change
            if len(reactions) > 0:
                impact["reputation_change"] = (positive_count - negative_count) / len(reactions)
            
            # Calculate dominance assertion
            if action_type in ["command", "dominate", "lead", "protect"]:
                impact["dominance_assertion"] = 2
                
                # Higher if well-received
                if positive_count > negative_count:
                    impact["dominance_assertion"] += 1
                # Lower if poorly received
                elif negative_count > positive_count:
                    impact["dominance_assertion"] -= 2
            
            # Determine social evaluation
            if positive_count > (len(reactions) * 0.6):
                impact["social_evaluation"] = "positive"
                impact["description"] = "The action was well-received by the group"
            elif negative_count > (len(reactions) * 0.6):
                impact["social_evaluation"] = "negative"
                impact["description"] = "The action was poorly received by the group"
            else:
                impact["social_evaluation"] = "mixed"
                impact["description"] = "The action received mixed reactions from the group"
            
            # Special case for commands/dominance
            if action_type == "command" and impact["dominance_assertion"] >= 2:
                impact["description"] += " and reinforced the NPC's dominant position"
            elif action_type == "command" and impact["dominance_assertion"] < 0:
                impact["description"] += " and undermined the NPC's authority"
            
            return impact
            
        except Exception as e:
            logger.error(f"Error calculating social impact: {e}")
            return {
                "reputation_change": 0,
                "social_evaluation": "neutral",
                "description": "Unable to determine social impact"
            }
    
    async def _process_npc_interactions(
        self, 
        npcs_present: List[Dict[str, Any]],
        npc_responses: List[Dict[str, Any]],
        player_action: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """Process interactions between NPCs in response to player action."""
        try:
            interactions = []
            
            # Skip if fewer than 2 NPCs
            if len(npcs_present) < 2:
                return interactions
            
            # Get dominance-sorted NPCs
            sorted_npcs = sorted(
                npcs_present, 
                key=lambda x: x.get("dominance", 50), 
                reverse=True
            )
            
            # Check for contradicting responses where one NPC might override another
            for i, high_npc in enumerate(sorted_npcs[:-1]):
                high_npc_id = high_npc["npc_id"]
                high_npc_response = next(
                    (r for r in npc_responses if r["npc_id"] == high_npc_id), 
                    None
                )
                
                if not high_npc_response:
                    continue
                
                high_action = high_npc_response.get("response", {}).get("action", {})
                high_action_type = high_action.get("type", "")
                
                # Only dominant actions can override others
                if high_action_type not in ["command", "dominate", "override", "protect"]:
                    continue
                
                # Check lower dominance NPCs for potential overrides
                for low_npc in sorted_npcs[i+1:]:
                    low_npc_id = low_npc["npc_id"]
                    low_npc_response = next(
                        (r for r in npc_responses if r["npc_id"] == low_npc_id), 
                        None
                    )
                    
                    if not low_npc_response:
                        continue
                    
                    low_action = low_npc_response.get("response", {}).get("action", {})
                    low_action_type = low_action.get("type", "")
                    
                    # Check if actions contradict
                    contradict = False
                    if (high_action_type == "command" and low_action_type != "obey") or \
                       (high_action_type == "protect" and low_action_type == "attack"):
                        contradict = True
                    
                    # Check relationship
                    relationship = await self._get_relationship(high_npc_id, low_npc_id)
                    
                    if contradict:
                        # Create override interaction
                        dom_difference = high_npc.get("dominance", 50) - low_npc.get("dominance", 50)
                        
                        # Higher dominance difference means more likely to override
                        override_chance = 0.5 + (dom_difference / 100)
                        
                        # Adjust by relationship
                        if relationship:
                            link_type = relationship.get("link_type", "neutral")
                            if link_type == "close":
                                override_chance -= 0.2  # Less likely to override friends
                            elif link_type == "hostile":
                                override_chance += 0.2  # More likely to override enemies
                        
                        # Apply override
                        if random.random() < override_chance:
                            interactions.append({
                                "type": "override",
                                "dominant_npc_id": high_npc_id,
                                "dominant_npc_name": high_npc["npc_name"],
                                "submissive_npc_id": low_npc_id,
                                "submissive_npc_name": low_npc["npc_name"],
                                "description": f"{high_npc['npc_name']} overrides {low_npc['npc_name']}'s response"
                            })
                            
                            # Create memories
                            memory_system = await self.get_memory_system()
                            
                            # For dominant NPC
                            await memory_system.remember(
                                entity_type="npc",
                                entity_id=high_npc_id,
                                memory_text=f"I overruled {low_npc['npc_name']}'s response to the player",
                                importance="medium",
                                tags=["dominance", "social_interaction"]
                            )
                            
                            # For submissive NPC
                            await memory_system.remember(
                                entity_type="npc",
                                entity_id=low_npc_id,
                                memory_text=f"{high_npc['npc_name']} overruled my response to the player",
                                importance="medium",
                                tags=["submission", "social_interaction"]
                            )
                            
                            # Update relationship
                            await self._update_relationship_from_override(
                                high_npc_id,
                                low_npc_id,
                                relationship
                            )
            
            return interactions
            
        except Exception as e:
            logger.error(f"Error processing NPC interactions: {e}")
            return []
    
    async def _update_relationship_from_override(
        self, 
        high_npc_id: int,
        low_npc_id: int,
        relationship: Optional[Dict[str, Any]]
    ) -> None:
        """Update relationship after a dominance override interaction."""
        try:
            if not relationship:
                return
            
            current_level = relationship.get("link_level", 50)
            current_type = relationship.get("link_type", "neutral")
            
            # Calculate change (small negative as being overridden usually causes resentment)
            change = -2
            
            with get_db_connection() as conn, conn.cursor() as cursor:
                # Calculate new level with min/max bounds
                new_level = max(0, min(100, current_level + change))
                
                # Update link level
                cursor.execute(
                    """
                    UPDATE SocialLinks
                    SET link_level = %s,
                        last_interaction = NOW()
                    WHERE entity1_type = 'npc'
                      AND entity1_id = %s
                      AND entity2_type = 'npc'
                      AND entity2_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (new_level, low_npc_id, high_npc_id, self.user_id, self.conversation_id)
                )
                
                # Update link type if needed
                new_type = current_type
                if new_level > 75:
                    new_type = "close"
                elif new_level > 50:
                    new_type = "friendly"
                elif new_level < 25:
                    new_type = "hostile"
                else:
                    new_type = "neutral"
                
                if new_type != current_type:
                    cursor.execute(
                        """
                        UPDATE SocialLinks
                        SET link_type = %s
                        WHERE entity1_type = 'npc'
                          AND entity1_id = %s
                          AND entity2_type = 'npc'
                          AND entity2_id = %s
                          AND user_id = %s
                          AND conversation_id = %s
                        """,
                        (new_type, low_npc_id, high_npc_id, self.user_id, self.conversation_id)
                    )
                
                # Record in history
                event_text = f"Was overridden in group interaction, relationship changed by {change}"
                cursor.execute(
                    """
                    UPDATE SocialLinks
                    SET link_history = COALESCE(link_history, '[]'::jsonb) || %s::jsonb
                    WHERE entity1_type = 'npc'
                      AND entity1_id = %s
                      AND entity2_type = 'npc'
                      AND entity2_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (json.dumps([event_text]), low_npc_id, high_npc_id, self.user_id, self.conversation_id)
                )
            
        except Exception as e:
            logger.error(f"Error updating relationship from override: {e}")
    
    async def _build_conversation_perception(
        self, 
        npc_id: int,
        conversation: List[Dict[str, Any]],
        topic: str,
        npcs_present: List[Dict[str, Any]],
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Build perception context for an NPC in a conversation."""
        try:
            perception_manager = PerceptionManager(self.user_id, self.conversation_id, self.cache_manager)
            
            # Create context for perception
            perception_context = context.copy()
            perception_context["text"] = f"Conversation about {topic}"
            
            # Add conversation history
            conversation_history = [
                f"{turn['npc_name']} {turn['action'].get('description', 'said something')}"
                for turn in conversation[-3:] if "npc_name" in turn
            ]
            
            perception_context["conversation_history"] = conversation_history
            
            # Get detailed perception
            perception = await perception_manager.perceive_environment_detailed(
                npc_id=npc_id,
                context=perception_context
            )
            
            # Add information about conversation topic
            perception["conversation_topic"] = topic
            
            # Add relationships with other participants
            perception["participant_relationships"] = {}
            
            for other_npc in npcs_present:
                if other_npc["npc_id"] == npc_id:
                    continue
                
                relationship = await self._get_relationship(npc_id, other_npc["npc_id"])
                if relationship:
                    perception["participant_relationships"][other_npc["npc_name"]] = {
                        "npc_id": other_npc["npc_id"],
                        "link_type": relationship.get("link_type", "neutral"),
                        "link_level": relationship.get("link_level", 50)
                    }
            
            return perception
            
        except Exception as e:
            logger.error(f"Error building conversation perception: {e}")
            # Return minimal perception
            return {
                "environment": context,
                "conversation_topic": topic,
                "participant_relationships": {}
            }
    
    async def _select_next_speaker(
        self, 
        current_speaker_id: int,
        npcs_present: List[Dict[str, Any]],
        conversation: List[Dict[str, Any]]
    ) -> Optional[int]:
        """Select the next speaker in a conversation based on social dynamics."""
        try:
            # Filter out current speaker
            other_npcs = [npc for npc in npcs_present if npc["npc_id"] != current_speaker_id]
            
            if not other_npcs:
                return None
            
            # Check who has already spoken
            speakers = set(turn["npc_id"] for turn in conversation)
            
            # Prioritize NPCs who haven't spoken yet
            unspoken_npcs = [npc for npc in other_npcs if npc["npc_id"] not in speakers]
            
            if unspoken_npcs:
                # Weight by dominance (more dominant NPCs more likely to speak)
                weights = [max(0.1, npc.get("dominance", 50) / 100) for npc in unspoken_npcs]
                total = sum(weights)
                normalized_weights = [w / total for w in weights] if total > 0 else None
                
                return random.choices(
                    [npc["npc_id"] for npc in unspoken_npcs],
                    weights=normalized_weights,
                    k=1
                )[0]
            
            # All have spoken, select based on dominance and relationship
            current_speaker = next((npc for npc in npcs_present if npc["npc_id"] == current_speaker_id), None)
            if not current_speaker:
                # Fallback to random selection
                return random.choice([npc["npc_id"] for npc in other_npcs])
            
            # Calculate candidate scores based on dominance and relationship
            candidates = []
            for npc in other_npcs:
                score = npc.get("dominance", 50) / 100  # Base on dominance
                
                # Check relationship
                relationship = await self._get_relationship(current_speaker_id, npc["npc_id"])
                if relationship:
                    link_level = relationship.get("link_level", 50)
                    # Close relationships more likely to respond to each other
                    if link_level > 70:
                        score *= 1.5
                    # Hostile relationships less likely
                    elif link_level < 30:
                        score *= 0.5
                
                candidates.append((npc["npc_id"], score))
            
            # Normalize scores and select
            total_score = sum(score for _, score in candidates)
            if total_score <= 0:
                # Fallback to random selection
                return random.choice([npc["npc_id"] for npc in other_npcs])
            
            weights = [score / total_score for _, score in candidates]
            return random.choices(
                [npc_id for npc_id, _ in candidates],
                weights=weights,
                k=1
            )[0]
            
        except Exception as e:
            logger.error(f"Error selecting next speaker: {e}")
            # Fallback to random selection
            if other_npcs:
                return random.choice([npc["npc_id"] for npc in other_npcs])
            return None
    
    async def _create_conversation_memories(
        self, 
        speaker_id: int,
        action: Dict[str, Any],
        result: Dict[str, Any],
        npcs_present: List[Dict[str, Any]],
        topic: str
    ) -> None:
        """Create memories of conversation for all participating NPCs."""
        try:
            memory_system = await self.get_memory_system()
            speaker_name = next((npc["npc_name"] for npc in npcs_present if npc["npc_id"] == speaker_id), f"NPC_{speaker_id}")
            
            for npc in npcs_present:
                npc_id = npc["npc_id"]
                
                if npc_id == speaker_id:
                    # Memory for the speaker
                    memory_text = f"I talked about {topic}, saying: {action.get('description', 'something')}"
                    await memory_system.remember(
                        entity_type="npc",
                        entity_id=npc_id,
                        memory_text=memory_text,
                        importance="low",
                        tags=["conversation", topic, "speaking"]
                    )
                else:
                    # Memory for the listeners
                    memory_text = f"During a conversation about {topic}, {speaker_name} said: {action.get('description', 'something')}"
                    await memory_system.remember(
                        entity_type="npc",
                        entity_id=npc_id,
                        memory_text=memory_text,
                        importance="low",
                        tags=["conversation", topic, "listening"]
                    )
            
        except Exception as e:
            logger.error(f"Error creating conversation memories: {e}")
    
    async def _get_npcs_in_location(self, location: str) -> List[Dict[str, Any]]:
        """Get NPCs present in a specific location."""
        try:
            npcs = []
            
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, npc_name, dominance, cruelty
                    FROM NPCStats
                    WHERE current_location = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (location, self.user_id, self.conversation_id)
                )
                
                for row in cursor.fetchall():
                    npc_id, npc_name, dominance, cruelty = row
                    npcs.append({
                        "npc_id": npc_id,
                        "npc_name": npc_name,
                        "dominance": dominance,
                        "cruelty": cruelty
                    })
            
            return npcs
            
        except Exception as e:
            logger.error(f"Error getting NPCs in location: {e}")
            return []
    
    def _get_npc_dominance(self, npc_id: int, npcs_list: List[Dict[str, Any]]) -> int:
        """Get an NPC's dominance from a list of NPCs."""
        for npc in npcs_list:
            if npc["npc_id"] == npc_id:
                return npc.get("dominance", 50)
        return 50
    
    async def _get_relationship(self, npc_id1: int, npc_id2: int) -> Optional[Dict[str, Any]]:
        """Get the relationship between two NPCs."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT link_id, link_type, link_level, last_interaction
                    FROM SocialLinks
                    WHERE entity1_type = 'npc'
                      AND entity1_id = %s
                      AND entity2_type = 'npc'
                      AND entity2_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id1, npc_id2, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if row:
                    link_id, link_type, link_level, last_interaction = row
                    return {
                        "link_id": link_id,
                        "link_type": link_type,
                        "link_level": link_level,
                        "last_interaction": last_interaction.isoformat() if last_interaction else None
                    }
                    
            return None
                
        except Exception as e:
            logger.error(f"Error getting relationship: {e}")
            return None
    
    async def _get_npc_name(self, npc_id: int) -> str:
        """Get an NPC's name."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_name
                    FROM NPCStats
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if row:
                    return row[0]
                    
            return f"NPC_{npc_id}"
                
        except Exception as e:
            logger.error(f"Error getting NPC name: {e}")
            return f"NPC_{npc_id}"
    
    async def _get_npc_data(self, npc_id: int) -> Optional[Dict[str, Any]]:
        """Get NPC data from database."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, npc_name, dominance, cruelty, personality_traits
                    FROM NPCStats
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if not row:
                    return None
                
                # Parse JSON field
                traits_raw = row[4]
                traits = []
                if traits_raw:
                    if isinstance(traits_raw, str):
                        try:
                            traits = json.loads(traits_raw)
                        except json.JSONDecodeError:
                            traits = []
                    elif isinstance(traits_raw, list):
                        traits = traits_raw
                
                return {
                    "npc_id": row[0],
                    "npc_name": row[1],
                    "dominance": row[2],
                    "cruelty": row[3],
                    "personality_traits": traits
                }
                
        except Exception as e:
            logger.error(f"Error getting NPC data: {e}")
            return None

class FlashbackSystem:
    """
    Enhanced system for generating and managing NPC flashbacks with
    deep psychological realism and narrative integration.
    """
    
    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None
    
    async def get_memory_system(self) -> MemorySystem:
        """Lazy-load the memory system."""
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system
    
    @function_tool
    async def generate_flashback(
        self, 
        npc_id: int, 
        trigger_text: str, 
        intensity: float = 0.5
    ) -> Dict[str, Any]:
        """
        Generate a flashback for an NPC based on a trigger and intensity.
        
        Args:
            npc_id: ID of the NPC
            trigger_text: Text that triggers the flashback
            intensity: Intensity of the flashback (0.0-1.0)
            
        Returns:
            Detailed flashback information
        """
        try:
            # Check cache first
            cache_key = f"{npc_id}_{hash(trigger_text)}_{intensity}"
            cached_data = self.cache_manager.get('flashbacks', cache_key)
            if cached_data:
                return cached_data
            
            memory_system = await self.get_memory_system()
            
            # Analyze the trigger text for themes and concepts
            keywords = await self._extract_trigger_keywords(trigger_text)
            
            # Find related memories that could serve as flashback content
            memory_candidates = []
            
            # Try each keyword for memory retrieval
            for keyword in keywords:
                memory_result = await memory_system.recall(
                    entity_type="npc",
                    entity_id=npc_id,
                    query=keyword,
                    limit=3,
                    context={"max_age_days": 90, "significance_min": 5}
                )
                
                if memory_result and "memories" in memory_result:
                    memory_candidates.extend(memory_result["memories"])
            
            # If no specific memories found, try general significant memories
            if not memory_candidates:
                memory_result = await memory_system.recall(
                    entity_type="npc",
                    entity_id=npc_id,
                    query="",
                    limit=5,
                    context={"significance_min": 7}
                )
                
                if memory_result and "memories" in memory_result:
                    memory_candidates.extend(memory_result["memories"])
            
            # If still no memories, create a synthetic one
            if not memory_candidates:
                synthetic_memory = await self._create_synthetic_flashback_memory(
                    npc_id, 
                    trigger_text, 
                    keywords
                )
                
                if synthetic_memory:
                    memory_candidates.append(synthetic_memory)
            
            # If we have candidates, select the best one
            flashback_memory = None
            if memory_candidates:
                # Sort by emotional intensity and significance
                scored_candidates = []
                for memory in memory_candidates:
                    emotional_score = memory.get("emotional_intensity", 0) / 100
                    significance_score = memory.get("significance", 0) / 10
                    
                    # Check for certain tags that make good flashbacks
                    tags = memory.get("tags", [])
                    tag_score = 0.0
                    if "trauma" in tags:
                        tag_score += 0.3
                    if "emotional" in tags:
                        tag_score += 0.2
                    if "fear" in tags or "anger" in tags:
                        tag_score += 0.2
                    
                    # Calculate total score
                    total_score = emotional_score * 0.4 + significance_score * 0.4 + tag_score * 0.2
                    
                    scored_candidates.append((memory, total_score))
                
                # Select best candidate with some randomness
                if scored_candidates:
                    scored_candidates.sort(key=lambda x: x[1], reverse=True)
                    
                    # Take top 3 if available
                    top_candidates = scored_candidates[:min(3, len(scored_candidates))]
                    
                    # Select with probability proportional to score
                    weights = [score for _, score in top_candidates]
                    total_weight = sum(weights)
                    if total_weight > 0:
                        normalized_weights = [w / total_weight for w in weights]
                        selected_idx = random.choices(
                            range(len(top_candidates)),
                            weights=normalized_weights,
                            k=1
                        )[0]
                        flashback_memory = top_candidates[selected_idx][0]
                    else:
                        flashback_memory = top_candidates[0][0]
            
            # If we have a memory to use as flashback, enhance it
            if flashback_memory:
                flashback = await self._enhance_flashback(
                    npc_id,
                    flashback_memory,
                    trigger_text,
                    intensity
                )
                
                # Create a memory of having this flashback
                await memory_system.remember(
                    entity_type="npc",
                    entity_id=npc_id,
                    memory_text=f"I experienced a flashback triggered by '{trigger_text}' to {flashback_memory.get('text', '')}",
                    importance="medium",
                    emotional=True,
                    tags=["flashback", "trauma"]
                )
                
                # Update emotional state
                emotion = "fear"
                if "anger" in flashback_memory.get("tags", []):
                    emotion = "anger"
                elif "sadness" in flashback_memory.get("tags", []):
                    emotion = "sadness"
                
                await memory_system.update_npc_emotion(
                    npc_id=npc_id,
                    emotion=emotion,
                    intensity=min(0.9, intensity + 0.2),
                    trigger=f"flashback to {flashback_memory.get('text', '')[:30]}..."
                )
                
                # Store in cache
                self.cache_manager.set('flashbacks', cache_key, flashback)
                
                return flashback
            
            # If no suitable memory found
            return {
                "flashback": False,
                "trigger": trigger_text,
                "reason": "No suitable memories found for flashback"
            }
            
        except Exception as e:
            logger.error(f"Error generating flashback: {e}")
            return {"flashback": False, "error": str(e)}
    
    @function_tool
    async def detect_flashback_opportunity(
        self, 
        npc_id: int, 
        context: Dict[str, Any], 
        current_emotion: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Detect if current context provides an opportunity for a flashback.
        
        Args:
            npc_id: ID of the NPC
            context: Current context information
            current_emotion: Current emotional state (optional)
            
        Returns:
            Information about flashback opportunity
        """
        try:
            # Extract text from context
            context_text = self._extract_text_from_context(context)
            if not context_text:
                return {"opportunity": False}
            
            # Get NPC data
            npc_data = await self._get_npc_data(npc_id)
            if not npc_data:
                return {"opportunity": False}
            
            memory_system = await self.get_memory_system()
            
            # Check for traumatic triggers if not already provided
            trauma_trigger = None
            if isinstance(context, dict) and "traumatic_trigger" in context:
                trauma_trigger = context["traumatic_trigger"]
            else:
                trigger_result = await memory_system.emotional_manager.process_traumatic_triggers(
                    entity_type="npc",
                    entity_id=npc_id,
                    text=context_text
                )
                trauma_trigger = trigger_result if trigger_result and trigger_result.get("triggered", False) else None
            
            # Get current emotion if not provided
            emotion_state = current_emotion
            if not emotion_state:
                emotion_state = await memory_system.get_npc_emotion(npc_id)
            
            emotion = "neutral"
            intensity = 0.0
            
            if emotion_state and "current_emotion" in emotion_state:
                primary = emotion_state["current_emotion"].get("primary", {})
                emotion = primary.get("name", "neutral")
                intensity = primary.get("intensity", 0.0)
            
            # Calculate base flashback probability
            base_probability = NPCConfig.PROBABILITY['flashback_chance']
            if trauma_trigger:
                base_probability = NPCConfig.PROBABILITY['flashback_with_trauma']
            
            # Adjust probability by mental resilience
            mental_resilience = npc_data.get("mental_resilience", 50)
            resilience_factor = mental_resilience / 100  # 0-1 scale
            probability = base_probability * (1 - resilience_factor * 0.5)  # Reduce by up to 50% based on resilience
            
            # Further adjust by emotional state
            if emotion in ["fear", "anxiety"] and intensity > 0.5:
                probability *= 1.5  # More likely when afraid
            elif emotion == "anger" and intensity > 0.6:
                probability *= 1.3  # More likely when angry
            
            # Recent flashbacks can make new ones more likely (state priming)
            recent_flashback = await self._check_for_recent_flashback(npc_id)
            if recent_flashback:
                probability *= 1.2  # Increased chance with recent flashback
            
            # Return opportunity information
            return {
                "opportunity": True,
                "probability": probability,
                "trauma_triggered": trauma_trigger is not None,
                "emotional_state": {
                    "emotion": emotion,
                    "intensity": intensity
                },
                "trigger_text": context_text
            }
            
        except Exception as e:
            logger.error(f"Error detecting flashback opportunity: {e}")
            return {"opportunity": False, "error": str(e)}
    
    @function_tool
    async def process_flashback_response(
        self, 
        npc_id: int, 
        flashback: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Process an NPC's response to experiencing a flashback.
        
        Args:
            npc_id: ID of the NPC
            flashback: Flashback information
            
        Returns:
            NPC's response to the flashback
        """
        try:
            # Get NPC data
            npc_data = await self._get_npc_data(npc_id)
            if not npc_data:
                return {"type": "freeze", "description": "freezes suddenly", "emotional_impact": -1}
            
            # Extract flashback details
            intensity = flashback.get("intensity", 0.5)
            
            # Determine response type based on NPC personality (fight/flight/freeze)
            dominance = npc_data.get("dominance", 50)
            cruelty = npc_data.get("cruelty", 50)
            personality_traits = npc_data.get("personality_traits", [])
            
            # Default response is freeze
            response_type = "freeze"
            
            # High dominance tends toward fight
            if dominance > 70 or cruelty > 70:
                response_type = "fight"
            # Low dominance tends toward flight
            elif dominance < 30:
                response_type = "flight"
            
            # Personality trait overrides
            if "aggressive" in personality_traits:
                response_type = "fight"
            elif "timid" in personality_traits or "anxious" in personality_traits:
                response_type = "flight"
            elif "analytical" in personality_traits:
                response_type = "intellectualize"  # Special case - intellectualizes to cope
            
            # Create appropriate response
            response = {}
            
            if response_type == "fight":
                response = {
                    "type": "flashback_response",
                    "response_type": "fight",
                    "description": "becomes suddenly agitated and defensive",
                    "target_type": "group",
                    "target_id": None,
                    "emotional_impact": -2,
                    "weight": 2.0 * intensity
                }
                
                # Variations based on intensity
                if intensity > 0.7:
                    response["description"] = "reacts with aggression to a vivid flashback"
                    response["emotional_impact"] = -3
                
            elif response_type == "flight":
                response = {
                    "type": "flashback_response",
                    "response_type": "flight",
                    "description": "tries to distance themselves from the situation",
                    "target_type": "location",
                    "target_id": None,
                    "emotional_impact": -1,
                    "weight": 2.0 * intensity
                }
                
                # Variations based on intensity
                if intensity > 0.7:
                    response["description"] = "attempts to flee from the flashback"
                    response["emotional_impact"] = -2
                
            elif response_type == "intellectualize":
                response = {
                    "type": "flashback_response",
                    "response_type": "intellectualize",
                    "description": "begins analyzing the situation with detached precision",
                    "target_type": "self",
                    "target_id": None,
                    "emotional_impact": -1,
                    "weight": 1.5 * intensity
                }
                
            else:  # freeze
                response = {
                    "type": "flashback_response",
                    "response_type": "freeze",
                    "description": "suddenly goes still, lost in a memory",
                    "target_type": "self",
                    "target_id": None,
                    "emotional_impact": -1,
                    "weight": 2.0 * intensity
                }
                
                # Variations based on intensity
                if intensity > 0.7:
                    response["description"] = "becomes completely frozen, trapped in a flashback"
                    response["emotional_impact"] = -2
            
            # Add flashback details
            response["flashback_details"] = {
                "memory_text": flashback.get("memory_text", ""),
                "intensity": flashback.get("intensity", 0.5),
                "emotional_impact": flashback.get("emotional_impact", "disturbing")
            }
            
            # Check for mask effects
            memory_system = await self.get_memory_system()
            mask_info = await memory_system.get_npc_mask(npc_id)
            
            if mask_info and intensity > 0.6:
                # Flashbacks can cause mask slippage
                integrity = mask_info.get("integrity", 100)
                if integrity < 90:
                    slip_chance = (0.9 - (integrity / 100)) * intensity
                    if random.random() < slip_chance:
                        slip_result = await memory_system.reveal_npc_trait(
                            npc_id=npc_id,
                            trigger="intense flashback"
                        )
                        response["mask_slippage"] = slip_result
            
            return response
            
        except Exception as e:
            logger.error(f"Error processing flashback response: {e}")
            return {"type": "freeze", "description": "appears disturbed", "emotional_impact": -1}
    
    async def _extract_trigger_keywords(self, text: str) -> List[str]:
        """Extract keywords from trigger text."""
        keywords = []
        
        # Simple keyword extraction
        words = text.lower().split()
        
        # Remove common stop words
        stop_words = {"a", "an", "the", "and", "or", "but", "in", "on", "at", "to", "for", "with", "by", "is", "are"}
        filtered_words = [word for word in words if word not in stop_words]
        
        # Extract n-grams
        if len(filtered_words) >= 2:
            bigrams = [f"{filtered_words[i]} {filtered_words[i+1]}" for i in range(len(filtered_words)-1)]
            keywords.extend(bigrams[:2])  # Add top 2 bigrams
        
        # Add individual keywords
        keywords.extend(filtered_words[:5])  # Add top 5 individual words
        
        # Check for emotional/trauma keywords with higher priority
        emotional_keywords = ["fear", "anger", "pain", "hurt", "scared", "angry", "terrified", "anxious", "panic"]
        trauma_keywords = ["attack", "hurt", "threat", "danger", "betrayal", "abandon"]
        
        priority_words = []
        for word in filtered_words:
            if word in emotional_keywords or word in trauma_keywords:
                priority_words.append(word)
        
        # Ensure priority words are at the beginning
        for word in priority_words:
            if word in keywords:
                keywords.remove(word)
            keywords.insert(0, word)
        
        return keywords
    
    async def _create_synthetic_flashback_memory(
        self, 
        npc_id: int, 
        trigger_text: str, 
        keywords: List[str]
    ) -> Optional[Dict[str, Any]]:
        """Create a synthetic memory when no actual memory is available."""
        try:
            # Get NPC data
            npc_data = await self._get_npc_data(npc_id)
            if not npc_data:
                return None
            
            memory_system = await self.get_memory_system()
            
            # Check if we have beliefs that can inform the synthetic memory
            beliefs = await memory_system.get_beliefs(
                entity_type="npc",
                entity_id=npc_id,
                min_confidence=0.6
            )
            
            # Curate themes based on trigger and keywords
            themes = []
            fear_themes = ["abandonment", "failure", "humiliation", "powerlessness", "betrayal"]
            
            # Check keywords for themes
            for keyword in keywords:
                if keyword in ["abandon", "alone", "left"]:
                    themes.append("abandonment")
                elif keyword in ["fail", "mistake", "wrong"]:
                    themes.append("failure")
                elif keyword in ["shame", "embarrass", "humiliate"]:
                    themes.append("humiliation")
                elif keyword in ["power", "control", "dominate", "helpless"]:
                    themes.append("powerlessness")
                elif keyword in ["betray", "trust", "deceive"]:
                    themes.append("betrayal")
            
            # If no themes identified, pick one based on personality
            if not themes:
                dominance = npc_data.get("dominance", 50)
                if dominance > 70:
                    themes.append("betrayal")
                elif dominance < 30:
                    themes.append("powerlessness")
                else:
                    themes.append(random.choice(fear_themes))
            
            # Create memory text
            theme = themes[0] if themes else random.choice(fear_themes)
            
            # Base memory text on theme
            memory_text = ""
            if theme == "abandonment":
                memory_text = "I was left alone when I needed help the most"
            elif theme == "failure":
                memory_text = "I failed terribly at something important to me"
            elif theme == "humiliation":
                memory_text = "I was deeply humiliated in front of others"
            elif theme == "powerlessness":
                memory_text = "I felt completely powerless to change what was happening"
            elif theme == "betrayal":
                memory_text = "Someone I trusted betrayed me in a painful way"
            
            # Create synthetic memory
            synthetic_memory = {
                "id": f"synthetic_{random.randint(1000, 9999)}",
                "text": memory_text,
                "type": "synthetic",
                "tags": ["trauma", "emotional", theme],
                "emotional_intensity": 80,
                "significance": 8,
                "confidence": 0.7
            }
            
            return synthetic_memory
            
        except Exception as e:
            logger.error(f"Error creating synthetic flashback memory: {e}")
            return None
    
    async def _enhance_flashback(
        self, 
        npc_id: int, 
        memory: Dict[str, Any], 
        trigger_text: str, 
        intensity: float
    ) -> Dict[str, Any]:
        """Enhance a memory with flashback-specific details."""
        try:
            # Start with base information
            memory_text = memory.get("text", "")
            
            # Create enhanced flashback
            flashback = {
                "flashback": True,
                "memory_id": memory.get("id"),
                "memory_text": memory_text,
                "trigger": trigger_text,
                "intensity": intensity,
                "tags": memory.get("tags", []),
                "sensory_details": {},
                "emotional_impact": "disturbing"  # Default impact
            }
            
            # Add sensory details based on tags and text
            sensory_details = {}
            
            # Visual details
            if "night" in memory_text.lower() or "dark" in memory_text.lower():
                sensory_details["visual"] = "darkness with shadows"
            elif "bright" in memory_text.lower() or "light" in memory_text.lower():
                sensory_details["visual"] = "bright, almost blinding light"
            else:
                sensory_details["visual"] = "vivid images from the memory"
            
            # Auditory details
            if "scream" in memory_text.lower() or "shout" in memory_text.lower():
                sensory_details["auditory"] = "echoing screams or shouts"
            elif "quiet" in memory_text.lower() or "silence" in memory_text.lower():
                sensory_details["auditory"] = "deafening silence"
            else:
                sensory_details["auditory"] = "voices or sounds from the memory"
            
            # Physical sensations
            if "pain" in memory_text.lower() or "hurt" in memory_text.lower():
                sensory_details["physical"] = "remembered pain or discomfort"
            elif "cold" in memory_text.lower():
                sensory_details["physical"] = "chilling cold"
            elif "heat" in memory_text.lower() or "hot" in memory_text.lower():
                sensory_details["physical"] = "burning sensation"
            else:
                sensory_details["physical"] = "physical tension or unease"
            
            flashback["sensory_details"] = sensory_details
            
            # Determine emotional impact
            tags = memory.get("tags", [])
            
            if "fear" in tags or "terror" in tags:
                flashback["emotional_impact"] = "terrifying"
            elif "anger" in tags or "rage" in tags:
                flashback["emotional_impact"] = "infuriating"
            elif "sadness" in tags or "grief" in tags:
                flashback["emotional_impact"] = "deeply saddening"
            elif "shame" in tags or "humiliation" in tags:
                flashback["emotional_impact"] = "humiliating"
            
            # Adjust impact by intensity
            if intensity > 0.8:
                flashback["emotional_impact"] = "overwhelming " + flashback["emotional_impact"]
            elif intensity < 0.4:
                flashback["emotional_impact"] = "mildly " + flashback["emotional_impact"]
            
            # Add psychological significance
            psychological_themes = []
            
            if "abandonment" in tags or "alone" in memory_text.lower():
                psychological_themes.append("abandonment fears")
            if "betrayal" in tags or "betray" in memory_text.lower():
                psychological_themes.append("trust issues")
            if "control" in memory_text.lower() or "helpless" in memory_text.lower():
                psychological_themes.append("power dynamics")
            if "shame" in tags or "embarrass" in memory_text.lower():
                psychological_themes.append("shame and self-worth")
            
            if psychological_themes:
                flashback["psychological_themes"] = psychological_themes
            
            return flashback
            
        except Exception as e:
            logger.error(f"Error enhancing flashback: {e}")
            return {
                "flashback": True,
                "memory_text": memory.get("text", ""),
                "trigger": trigger_text,
                "intensity": intensity
            }
    
    def _extract_text_from_context(self, context: Any) -> str:
        """Extract text content from context object."""
        if isinstance(context, str):
            return context
        
        if isinstance(context, dict):
            if "text" in context:
                return context["text"]
            elif "description" in context:
                return context["description"]
            elif "player_action" in context and isinstance(context["player_action"], dict):
                return context["player_action"].get("description", "")
            
            # Combine all string values
            text_parts = []
            for key, value in context.items():
                if isinstance(value, str):
                    text_parts.append(value)
            
            if text_parts:
                return " ".join(text_parts)
        
        return ""
    
    async def _check_for_recent_flashback(self, npc_id: int) -> bool:
        """Check if NPC has had a recent flashback."""
        try:
            memory_system = await self.get_memory_system()
            
            memory_result = await memory_system.recall(
                entity_type="npc",
                entity_id=npc_id,
                query="flashback",
                limit=1,
                context={"max_age_days": 1}  # Only check last day
            )
            
            memories = memory_result.get("memories", [])
            return len(memories) > 0
            
        except Exception as e:
            logger.error(f"Error checking for recent flashback: {e}")
            return False
    
    async def _get_npc_data(self, npc_id: int) -> Optional[Dict[str, Any]]:
        """Get NPC data from database."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, npc_name, dominance, cruelty, mental_resilience, personality_traits
                    FROM NPCStats
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if not row:
                    return None
                
                # Parse JSON field
                traits_raw = row[5]
                traits = []
                if traits_raw:
                    if isinstance(traits_raw, str):
                        try:
                            traits = json.loads(traits_raw)
                        except json.JSONDecodeError:
                            traits = []
                    elif isinstance(traits_raw, list):
                        traits = traits_raw
                
                return {
                    "npc_id": row[0],
                    "npc_name": row[1],
                    "dominance": row[2],
                    "cruelty": row[3],
                    "mental_resilience": row[4] or 50,  # Default to 50 if NULL
                    "personality_traits": traits
                }
                
        except Exception as e:
            logger.error(f"Error getting NPC data: {e}")
            return None

class TraumaResponseManager:
    """
    Handles trauma responses and psychological realism for NPCs
    encountering triggering situations.
    """
    
    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None
    
    async def get_memory_system(self) -> MemorySystem:
        """Lazy-load the memory system."""
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system
    
    @function_tool
    async def process_trauma_trigger(
        self, 
        npc_id: int, 
        trigger_text: str, 
        context: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Process a potential trauma trigger and generate appropriate response.
        
        Args:
            npc_id: ID of the NPC
            trigger_text: The text that might trigger trauma
            context: Additional context information
            
        Returns:
            Trauma response information if triggered, or indication no trauma was triggered
        """
        try:
            memory_system = await self.get_memory_system()
            
            # Check if text triggers trauma
            trigger_result = await memory_system.emotional_manager.process_traumatic_triggers(
                entity_type="npc",
                entity_id=npc_id,
                text=trigger_text
            )
            
            # If no trauma triggered, return early
            if not trigger_result or not trigger_result.get("triggered", False):
                return {"triggered": False}
            
            # Get emotional response from trigger result
            emotional_response = trigger_result.get("emotional_response", {})
            primary_emotion = emotional_response.get("primary_emotion", "fear")
            intensity = emotional_response.get("intensity", 0.5)
            
            # Update emotional state based on trigger
            await memory_system.update_npc_emotion(
                npc_id=npc_id,
                emotion=primary_emotion,
                intensity=intensity,
                trigger=f"traumatic memory triggered by: {trigger_text[:50]}..."
            )
            
            # Generate trauma response action
            trauma_action = await self._create_trauma_response_action(
                npc_id, trigger_result
            )
            
            # Create memory of trauma response
            await memory_system.remember(
                entity_type="npc",
                entity_id=npc_id,
                memory_text=(
                    f"I was triggered by '{trigger_text[:50]}...' and experienced "
                    f"a {primary_emotion} response"
                ),
                importance="high",
                emotional=True,
                tags=["trauma", "trigger", primary_emotion]
            )
            
            # Check for mask effects
            mask_info = await memory_system.get_npc_mask(npc_id)
            mask_effects = {}
            
            if mask_info and "integrity" in mask_info:
                integrity = mask_info.get("integrity", 100)
                
                # Trauma can cause mask slippage
                if integrity < 80 and intensity > 0.6:
                    slip_chance = (0.8 - (integrity / 100)) * intensity
                    if random.random() < slip_chance:
                        slip_result = await memory_system.reveal_npc_trait(
                            npc_id=npc_id,
                            trigger=f"trauma response to {trigger_text[:30]}..."
                        )
                        mask_effects["mask_slippage"] = slip_result
            
            # Return comprehensive response
            return {
                "triggered": True,
                "trigger_text": trigger_text,
                "emotional_response": emotional_response,
                "trauma_action": trauma_action,
                "mask_effects": mask_effects
            }
            
        except Exception as e:
            logger.error(f"Error processing trauma trigger: {e}")
            return {"triggered": False, "error": str(e)}
    
    @function_tool
    async def create_trauma_response_action(
        self, 
        npc_id: int, 
        trauma_trigger: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Create a psychologically realistic action in response to a traumatic trigger.
        
        Args:
            npc_id: ID of the NPC
            trauma_trigger: Information about the traumatic trigger
            
        Returns:
            A trauma-response action
        """
        return await self._create_trauma_response_action(npc_id, trauma_trigger)
    
    async def _create_trauma_response_action(
        self, 
        npc_id: int, 
        trauma_trigger: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Create a psychologically realistic action in response to a traumatic trigger.
        
        Args:
            npc_id: ID of the NPC
            trauma_trigger: Information about the traumatic trigger
            
        Returns:
            A trauma-response action dictionary
        """
        try:
            # Extract information from trigger
            emotional_response = trauma_trigger.get("emotional_response", {})
            primary_emotion = emotional_response.get("primary_emotion", "fear")
            intensity = emotional_response.get("intensity", 0.5)
            trigger_text = trauma_trigger.get("trigger_text", "")
            
            # Get NPC data to personalize response
            npc_data = await self._get_npc_data(npc_id)
            
            if primary_emotion == "fear":
                # Default response is freeze, but can be fight or flight based on personality
                response_type = "freeze"
                
                if npc_data:
                    dominance = npc_data.get("dominance", 50)
                    cruelty = npc_data.get("cruelty", 50)
                    
                    if dominance > 70 or cruelty > 70:
                        response_type = "fight"
                    elif dominance < 30:
                        response_type = "flight"
                
                if response_type == "fight":
                    return {
                        "type": "traumatic_response",
                        "description": "react aggressively to a triggering memory",
                        "target_type": "group",
                        "target_id": None,
                        "weight": 2.0 * intensity,
                        "emotional_impact": -2,
                        "trauma_trigger": trigger_text
                    }
                elif response_type == "flight":
                    return {
                        "type": "traumatic_response",
                        "description": "try to escape from a triggering situation",
                        "target_type": "location",
                        "target_id": None,
                        "weight": 2.0 * intensity,
                        "emotional_impact": -1,
                        "trauma_trigger": trigger_text
                    }
                else:  # freeze
                    return {
                        "type": "traumatic_response",
                        "description": "freeze in response to a triggering memory",
                        "target_type": "self",
                        "target_id": None,
                        "weight": 2.0 * intensity,
                        "emotional_impact": -1,
                        "trauma_trigger": trigger_text
                    }
                    
            elif primary_emotion == "anger":
                return {
                    "type": "traumatic_response",
                    "description": "respond with anger to a triggering situation",
                    "target_type": "group",
                    "target_id": None,
                    "weight": 1.8 * intensity,
                    "emotional_impact": -2,
                    "trauma_trigger": trigger_text
                }
                
            elif primary_emotion == "sadness":
                return {
                    "type": "traumatic_response",
                    "description": "become visibly downcast due to a painful memory",
                    "target_type": "self",
                    "target_id": None,
                    "weight": 1.7 * intensity,
                    "emotional_impact": -1,
                    "trauma_trigger": trigger_text
                }
                
            else:
                # Default for other emotions
                return {
                    "type": "traumatic_response",
                    "description": f"respond emotionally with {primary_emotion} to a triggering memory",
                    "target_type": "self",
                    "target_id": None,
                    "weight": 1.5 * intensity,
                    "emotional_impact": -1,
                    "trauma_trigger": trigger_text
                }
                
        except Exception as e:
            logger.error(f"Error creating trauma response: {e}")
            # Fallback action
            return {
                "type": "observe",
                "description": "look uncomfortable and distracted",
                "target_type": "self",
                "target_id": None,
                "weight": 1.0,
                "emotional_impact": -1
            }
    
    @function_tool
    async def detect_flashback_opportunity(
        self, 
        npc_id: int, 
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Detect if a context provides an opportunity for a flashback.
        
        Args:
            npc_id: ID of the NPC
            context: Current context information
            
        Returns:
            Flashback information if triggered, or indication no flashback was triggered
        """
        try:
            # Extract context text
            context_text = ""
            if isinstance(context, dict):
                if "text" in context:
                    context_text = context["text"]
                elif "description" in context:
                    context_text = context["description"]
            else:
                context_text = str(context)
            
            if not context_text:
                return {"flashback": False}
            
            # Check if trauma trigger exists
            trauma_result = await self.process_trauma_trigger(npc_id, context_text)
            has_trauma = trauma_result.get("triggered", False)
            
            # Calculate flashback chance
            base_chance = NPCConfig.PROBABILITY['flashback_chance']
            if has_trauma:
                base_chance = NPCConfig.PROBABILITY['flashback_with_trauma']
            
            # Adjust chance based on NPC mental resilience
            npc_data = await self._get_npc_data(npc_id)
            if npc_data and "mental_resilience" in npc_data:
                resilience = npc_data.get("mental_resilience", 50)
                # Lower resilience = higher flashback chance
                base_chance *= (100 - resilience) / 50
            
            # Roll for flashback
            if random.random() < base_chance:
                memory_system = await self.get_memory_system()
                flashback = await memory_system.npc_flashback(
                    npc_id=npc_id,
                    context=context_text
                )
                
                # Create memory of flashback
                if flashback:
                    await memory_system.remember(
                        entity_type="npc",
                        entity_id=npc_id,
                        memory_text=f"I experienced a flashback to {flashback.get('memory_text', '')}",
                        importance="high",
                        emotional=True,
                        tags=["flashback", "trauma"]
                    )
                    
                    # Return flashback information
                    return {
                        "flashback": True,
                        "content": flashback,
                        "trauma_related": has_trauma
                    }
            
            return {"flashback": False}
            
        except Exception as e:
            logger.error(f"Error detecting flashback opportunity: {e}")
            return {"flashback": False, "error": str(e)}
    
    async def _get_npc_data(self, npc_id: int) -> Optional[Dict[str, Any]]:
        """Get NPC data from database."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, npc_name, dominance, cruelty, mental_resilience, personality_traits
                    FROM NPCStats
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if not row:
                    return None
                
                # Parse JSON field
                traits_raw = row[5]
                traits = []
                if traits_raw:
                    if isinstance(traits_raw, str):
                        try:
                            traits = json.loads(traits_raw)
                        except json.JSONDecodeError:
                            traits = []
                    elif isinstance(traits_raw, list):
                        traits = traits_raw
                
                return {
                    "npc_id": row[0],
                    "npc_name": row[1],
                    "dominance": row[2],
                    "cruelty": row[3],
                    "mental_resilience": row[4] or 50,  # Default to 50 if NULL
                    "personality_traits": traits
                }
                
        except Exception as e:
            logger.error(f"Error getting NPC data: {e}")
            return None

class PlayerActionProcessor:
    """
    GPT approach for processing player actions with memory + decision + execution.
    """

    def __init__(
        self,
        user_id: int,
        conversation_id: int,
        cache_manager: CacheManager,
        decision_engine=None,
        action_executor=None
    ):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None
        self.decision_engine = decision_engine
        self.action_executor = action_executor

    async def get_memory_system(self) -> MemorySystem:
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system

    @function_tool
    async def process_player_action(
        self,
        npc_id: int,
        action: Dict[str, Any],
        context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        GPT CHANGE: We keep the chain but let GPT handle the big logic in the 'decide' and 'execute' steps.
        """
        perf_start = time.time()
        try:
            context = context or {}
            # 1) Create a memory of the player action
            memory_system = await self.get_memory_system()
            mem_text = f"The player performed: {action.get('description','something')}"
            await memory_system.remember(
                entity_type="npc",
                entity_id=npc_id,
                memory_text=mem_text,
                importance="low",
                tags=["player_action", action.get("type", "unknown")]
            )
            # 2) Possibly update emotion
            # (left as numeric or partial GPT approach)

            # 3) Decide how to respond with GPT
            if not self.decision_engine:
                self.decision_engine = DecisionEngine(self.user_id, self.conversation_id, self.cache_manager)
            perception = {"context": context}  # simplified
            chosen_action = await self.decision_engine.decide_gpt(npc_id, perception)

            # 4) Execute action via GPT
            if not self.action_executor:
                self.action_executor = ActionExecutor(self.user_id, self.conversation_id, self.cache_manager)
            outcome = await self.action_executor.execute_action_gpt(npc_id, chosen_action, context)

            elapsed = time.time() - perf_start
            return {
                "npc_id": npc_id,
                "action": chosen_action,
                "result": outcome,
                "processing_time_ms": int(elapsed * 1000)
            }
        except Exception as e:
            elapsed = time.time() - perf_start
            logger.error(f"Error processing player action: {e}")
            return {
                "npc_id": npc_id,
                "action": {"type": "error", "description": "had an internal error"},
                "result": {"outcome": "NPC seems confused", "emotional_impact": -1},
                "error": str(e),
                "processing_time_ms": int(elapsed * 1000)
            }

class MemoryPropagationManager:
    """Manager for memory propagation between NPCs."""
    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None

    async def get_memory_system(self) -> MemorySystem:
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system

    @function_tool
    async def propagate_memory(
        self,
        source_npc_id: int,
        memory_text: str,
        tags: List[str] = None,
        significance: int = 3,
        emotional_intensity: int = 50
    ) -> Dict[str, Any]:
        # same as original or partially GPT
        return {}

    @function_tool
    async def propagate_significant_action(
        self,
        npc_id: int,
        action: Dict[str, Any],
        result: Dict[str, Any]
    ) -> Dict[str, Any]:
        # same as original or partially GPT
        return {}



class ActionExecutor:
    """
    GPT-based approach for outcomes, replacing if/else in the original code.
    """

    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None

    async def get_memory_system(self) -> MemorySystem:
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system

    @function_tool
    async def execute_action(
        self,
        npc_id: int,
        action: Dict[str, Any],
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        We keep the old approach or you do GPT-based. Here's the old approach, ignoring GPT for demonstration.
        """
        return {
            "outcome": f"Old approach: {action.get('description')}",
            "emotional_impact": 0,
            "target_reactions": []
        }

    @function_tool
    async def execute_action_gpt(
        self,
        npc_id: int,
        action: Dict[str, Any],
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        GPT-based approach. We pass the action and minimal NPC data to GPT, parse the outcome and emotional impact.
        """
        try:
            memory_system = await self.get_memory_system()
            # gather minimal NPC data
            # omitted for brevity, assume we have dominance/cruelty
            npc_data = {
                "dominance": 50,
                "cruelty": 50
            }
            system_prompt = (
                "You are an Action Outcome generator. You get an NPC's short personality data and an action. "
                "Return JSON: {outcome: str, emotional_impact: number}."
            )
            user_prompt = f"""
NPC data: {json.dumps(npc_data)}
Action: {json.dumps(action)}
Context: {json.dumps(context)}

Return JSON. Example:
{{
  "outcome": "...",
  "emotional_impact": 0
}}
"""

            result = await GPTClient.call_gpt_for_json(system_prompt, user_prompt)
            if "outcome" not in result:
                result["outcome"] = "No outcome from GPT"
            if "emotional_impact" not in result:
                result["emotional_impact"] = 0
            return result
        except Exception as e:
            logger.error(f"Error in GPT execute_action: {e}")
            return {
                "outcome": "Error in GPT action",
                "emotional_impact": 0
            }



class DecisionEngine:
    """GPT-based approach to picking an action from a list, replaced manual weighting."""

    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None

    async def get_memory_system(self) -> MemorySystem:
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system

    @function_tool
    async def decide(
        self,
        npc_id: int,
        perception: Dict[str, Any],
        available_actions: List[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        The old code for numeric weighting. We'll keep it but skip for demonstration.
        """
        return {"type": "observe", "description": "default old approach"}

    @function_tool
    async def decide_gpt(
        self,
        npc_id: int,
        perception: Dict[str, Any],
        possible_actions: Optional[List[Dict[str, Any]]] = None
    ) -> Dict[str, Any]:
        """
        GPT approach. We pass the NPC data + environment + list of possible actions,
        GPT picks one in JSON form.
        """
        if not possible_actions:
            possible_actions = [
                {"type": "observe", "description": "observe quietly"},
                {"type": "talk", "description": "talk to someone nearby"},
                {"type": "leave", "description": "leave the area"},
            ]
        npc_data = {"dominance": 50, "cruelty": 50, "traits": []}  # or real DB look-up

        system_prompt = (
            "You are a Decision Maker for an NPC. Return only JSON with keys 'type', 'description', and 'reason'."
        )
        user_prompt = f"""
NPC data: {json.dumps(npc_data, indent=2)}
Perception: {json.dumps(perception, indent=2)}
Possible Actions: {json.dumps(possible_actions, indent=2)}

Return best action as JSON:
{{
  "type": "...",
  "description": "...",
  "reason": "..."
}}
"""
        raw = await GPTClient.call_gpt_for_json(system_prompt, user_prompt)
        if "type" not in raw:
            raw["type"] = "observe"
            raw["description"] = "observe quietly"
            raw["reason"] = "fallback"
        return raw

class PersonalityEvolutionSystem:
    """
    System for evolving NPC personalities over time based on experiences,
    decisions, and interactions, providing deep character development.
    """
    
    def __init__(self, user_id: int, conversation_id: int, cache_manager: CacheManager):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None
        self._behavior_analyzer = None
    
    async def get_memory_system(self) -> MemorySystem:
        """Lazy-load the memory system."""
        if self._memory_system is None:
            self._memory_system = await MemorySystem.get_instance(self.user_id, self.conversation_id)
        return self._memory_system
    
    async def get_behavior_analyzer(self) -> 'BehaviorTrendsAnalyzer':
        """Lazy-load the behavior analyzer."""
        if self._behavior_analyzer is None:
            self._behavior_analyzer = BehaviorTrendsAnalyzer(
                self.user_id, 
                self.conversation_id, 
                self.cache_manager
            )
        return self._behavior_analyzer
    
    @function_tool
    async def evaluate_personality_evolution(
        self, 
        npc_id: int, 
        timeframe_days: int = 30
    ) -> Dict[str, Any]:
        """
        Evaluate how an NPC's personality should evolve based on recent experiences.
        
        Args:
            npc_id: ID of the NPC
            timeframe_days: Timeframe to analyze in days
            
        Returns:
            Personality evolution recommendations
        """
        try:
            # Get current NPC data
            npc_data = await self._get_npc_data(npc_id)
            if not npc_data:
                return {"error": "NPC data not found"}
            
            current_dominance = npc_data.get("dominance", 50)
            current_cruelty = npc_data.get("cruelty", 50)
            current_traits = npc_data.get("personality_traits", [])
            
            # Get behavior analyzer for trends analysis
            behavior_analyzer = await self.get_behavior_analyzer()
            trends = await behavior_analyzer.analyze_behavior_trends(npc_id, timeframe_days)
            
            # Calculate evolution recommendations
            evolution = {
                "dominance_adjustment": 0,
                "cruelty_adjustment": 0,
                "traits_to_add": [],
                "traits_to_remove": [],
                "stability_score": 0.0,
                "evolution_description": ""
            }
            
            # Analyze trends to determine dominance/cruelty shifts
            dominant_behaviors = trends.get("dominant_behaviors", 0)
            submissive_behaviors = trends.get("submissive_behaviors", 0)
            cruel_actions = trends.get("cruel_actions", 0)
            kind_actions = trends.get("kind_actions", 0)
            
            # Calculate dominance adjustment
            dominance_delta = dominant_behaviors - submissive_behaviors
            if abs(dominance_delta) >= 3:
                # Convert to a smaller scale adjustment (-5 to +5)
                evolution["dominance_adjustment"] = max(-5, min(5, dominance_delta // 2))
                
                # More significant if against current tendency
                if (dominance_delta > 0 and current_dominance < 40) or \
                   (dominance_delta < 0 and current_dominance > 60):
                    evolution["dominance_adjustment"] *= 1.5
            
            # Calculate cruelty adjustment
            cruelty_delta = cruel_actions - kind_actions
            if abs(cruelty_delta) >= 3:
                # Convert to a smaller scale adjustment (-5 to +5)
                evolution["cruelty_adjustment"] = max(-5, min(5, cruelty_delta // 2))
                
                # More significant if against current tendency
                if (cruelty_delta > 0 and current_cruelty < 40) or \
                   (cruelty_delta < 0 and current_cruelty > 60):
                    evolution["cruelty_adjustment"] *= 1.5
            
            # Analyze memory for trait evidence
            memory_system = await self.get_memory_system()
            
            # Get recent significant memories
            memory_result = await memory_system.recall(
                entity_type="npc",
                entity_id=npc_id,
                query="",
                limit=30,
                context={"max_age_days": timeframe_days, "significance_min": 5}
            )
            
            memories = memory_result.get("memories", [])
            
            # Analyze trait indicators in memories
            trait_indicators = await self._analyze_trait_indicators(memories)
            
            # Determine traits to add/remove
            for trait, score in trait_indicators.items():
                # Only consider strong enough indicators
                if abs(score) < 3:
                    continue
                
                # Check for trait pairs
                opposite_trait = self._get_opposite_trait(trait)
                
                if score > 0:  # Positive indicator
                    if trait not in current_traits:
                        evolution["traits_to_add"].append({
                            "trait": trait,
                            "confidence": min(0.9, 0.5 + (score / 10)),
                            "evidence_strength": score
                        })
                    
                    # If opposite trait exists, consider removing it
                    if opposite_trait and opposite_trait in current_traits:
                        evolution["traits_to_remove"].append({
                            "trait": opposite_trait,
                            "contradiction_strength": score,
                            "confidence": min(0.9, 0.5 + (score / 10))
                        })
                        
                else:  # Negative indicator
                    if trait in current_traits:
                        evolution["traits_to_remove"].append({
                            "trait": trait,
                            "contradiction_strength": abs(score),
                            "confidence": min(0.9, 0.5 + (abs(score) / 10))
                        })
            
            # Calculate stability score
            adjustment_magnitude = (
                abs(evolution["dominance_adjustment"]) + 
                abs(evolution["cruelty_adjustment"])
            ) / 10.0  # 0-1 scale
            
            trait_changes = len(evolution["traits_to_add"]) + len(evolution["traits_to_remove"])
            trait_magnitude = min(1.0, trait_changes / 5.0)  # 0-1 scale, caps at 5 changes
            
            stability_score = 1.0 - (adjustment_magnitude * 0.6 + trait_magnitude * 0.4)
            evolution["stability_score"] = stability_score
            
            # Generate description
            description = "The NPC's personality is "
            if stability_score > 0.8:
                description += "very stable, with minimal changes indicated."
            elif stability_score > 0.6:
                description += "generally stable, with minor adjustments suggested."
            elif stability_score > 0.4:
                description += "moderately evolving, with noticeable changes suggested."
            elif stability_score > 0.2:
                description += "significantly evolving, with substantial changes suggested."
            else:
                description += "undergoing a major transformation based on recent experiences."
            
            # Add specifics
            specifics = []
            if evolution["dominance_adjustment"] > 0:
                specifics.append("becoming more dominant")
            elif evolution["dominance_adjustment"] < 0:
                specifics.append("becoming more submissive")
                
            if evolution["cruelty_adjustment"] > 0:
                specifics.append("becoming more cruel")
            elif evolution["cruelty_adjustment"] < 0:
                specifics.append("becoming more kind")
                
            if evolution["traits_to_add"]:
                trait_names = [t["trait"] for t in evolution["traits_to_add"]]
                specifics.append(f"developing traits: {', '.join(trait_names)}")
                
            if evolution["traits_to_remove"]:
                trait_names = [t["trait"] for t in evolution["traits_to_remove"]]
                specifics.append(f"losing traits: {', '.join(trait_names)}")
            
            if specifics:
                description += " This includes " + ", and ".join(specifics) + "."
            
            evolution["evolution_description"] = description
            
            return evolution
            
        except Exception as e:
            logger.error(f"Error evaluating personality evolution: {e}")
            return {"error": str(e)}
    
    @function_tool
    async def apply_personality_evolution(
        self, 
        npc_id: int, 
        evolution: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Apply recommended personality evolution changes to an NPC.
        
        Args:
            npc_id: ID of the NPC
            evolution: Personality evolution recommendations
            
        Returns:
            Results of applying personality changes
        """
        try:
            # Get current NPC data
            npc_data = await self._get_npc_data(npc_id)
            if not npc_data:
                return {"error": "NPC data not found"}
            
            current_dominance = npc_data.get("dominance", 50)
            current_cruelty = npc_data.get("cruelty", 50)
            current_traits = npc_data.get("personality_traits", [])
            
            # Extract evolution changes
            dominance_adjustment = evolution.get("dominance_adjustment", 0)
            cruelty_adjustment = evolution.get("cruelty_adjustment", 0)
            traits_to_add = evolution.get("traits_to_add", [])
            traits_to_remove = evolution.get("traits_to_remove", [])
            
            # Apply changes
            new_dominance = max(0, min(100, current_dominance + dominance_adjustment))
            new_cruelty = max(0, min(100, current_cruelty + cruelty_adjustment))
            
            # Update traits
            new_traits = current_traits.copy()
            
            # Remove traits
            for trait_info in traits_to_remove:
                trait = trait_info.get("trait")
                if trait in new_traits:
                    new_traits.remove(trait)
            
            # Add traits
            for trait_info in traits_to_add:
                trait = trait_info.get("trait")
                if trait not in new_traits:
                    new_traits.append(trait)
            
            # Update database
            result = await self._update_npc_personality(
                npc_id,
                new_dominance,
                new_cruelty,
                new_traits
            )
            
            # Create memory of personality change
            memory_system = await self.get_memory_system()
            
            # Build memory text based on changes
            changes = []
            
            if abs(new_dominance - current_dominance) >= 2:
                if new_dominance > current_dominance:
                    changes.append("becoming more dominant")
                else:
                    changes.append("becoming more submissive")
            
            if abs(new_cruelty - current_cruelty) >= 2:
                if new_cruelty > current_cruelty:
                    changes.append("becoming more cruel")
                else:
                    changes.append("becoming more kind")
            
            added_traits = [t["trait"] for t in traits_to_add if t["trait"] in new_traits]
            if added_traits:
                changes.append(f"developing {', '.join(added_traits)} traits")
            
            removed_traits = [t["trait"] for t in traits_to_remove if t["trait"] not in new_traits]
            if removed_traits:
                changes.append(f"moving away from {', '.join(removed_traits)} traits")
            
            if changes:
                memory_text = "I noticed my personality changing, " + " and ".join(changes)
                
                await memory_system.remember(
                    entity_type="npc",
                    entity_id=npc_id,
                    memory_text=memory_text,
                    importance="high",
                    tags=["personality_change", "self_awareness", "character_development"]
                )
            
            # Create self-reflection belief
            if changes:
                await memory_system.create_belief(
                    entity_type="npc",
                    entity_id=npc_id,
                    belief_text=f"I am {' and '.join(changes)}",
                    confidence=0.7,
                    topic="self"
                )
            
            # Result of operations
            return {
                "success": result.get("success", False),
                "changes_applied": {
                    "dominance": {
                        "old": current_dominance,
                        "new": new_dominance,
                        "delta": new_dominance - current_dominance
                    },
                    "cruelty": {
                        "old": current_cruelty,
                        "new": new_cruelty,
                        "delta": new_cruelty - current_cruelty
                    },
                    "traits_added": added_traits,
                    "traits_removed": removed_traits
                },
                "memory_created": len(changes) > 0
            }
            
        except Exception as e:
            logger.error(f"Error applying personality evolution: {e}")
            return {"success": False, "error": str(e)}
    
    @function_tool
    async def handle_formative_experience(
        self, 
        npc_id: int, 
        experience: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Process a formative experience that might immediately impact an NPC's personality.
        
        Args:
            npc_id: ID of the NPC
            experience: Details of the formative experience
            
        Returns:
            Impact of the experience on the NPC's personality
        """
        try:
            # Extract experience details
            experience_type = experience.get("type", "generic")
            description = experience.get("description", "")
            intensity = experience.get("intensity", 0.5)
            immediate_impact = experience.get("immediate_impact", False)
            
            # Get current NPC data
            npc_data = await self._get_npc_data(npc_id)
            if not npc_data:
                return {"error": "NPC data not found"}
            
            current_dominance = npc_data.get("dominance", 50)
            current_cruelty = npc_data.get("cruelty", 50)
            current_traits = npc_data.get("personality_traits", [])
            
            # Analyze impact of experience
            dominance_impact = 0
            cruelty_impact = 0
            trait_impacts = {}
            
            # Customize impact based on experience type
            if experience_type == "betrayal":
                cruelty_impact = round(3 * intensity)
                trait_impacts["suspicious"] = 4 * intensity
                trait_impacts["trusting"] = -3 * intensity
                
            elif experience_type == "trauma":
                dominance_impact = round(-3 * intensity)
                trait_impacts["anxious"] = 4 * intensity
                trait_impacts["confident"] = -3 * intensity
                
            elif experience_type == "achievement":
                dominance_impact = round(2 * intensity)
                trait_impacts["confident"] = 3 * intensity
                trait_impacts["anxious"] = -2 * intensity
                
            elif experience_type == "humiliation":
                dominance_impact = round(-3 * intensity)
                cruelty_impact = round(2 * intensity)
                trait_impacts["anxious"] = 3 * intensity
                trait_impacts["confident"] = -3 * intensity
                
            elif experience_type == "power":
                dominance_impact = round(4 * intensity)
                trait_impacts["confident"] = 3 * intensity
                trait_impacts["submissive"] = -4 * intensity
                
            elif experience_type == "kindness":
                cruelty_impact = round(-3 * intensity)
                trait_impacts["trusting"] = 3 * intensity
                trait_impacts["suspicious"] = -2 * intensity
                
            elif experience_type == "loss":
                trait_impacts["emotional"] = 3 * intensity
                trait_impacts["stoic"] = -2 * intensity
                
            # Default/generic experience handling
            else:
                # Extract sentiment and themes from description
                if "dominant" in description.lower() or "power" in description.lower():
                    dominance_impact = round(2 * intensity)
                elif "submissive" in description.lower() or "helpless" in description.lower():
                    dominance_impact = round(-2 * intensity)
                    
                if "cruel" in description.lower() or "hurt" in description.lower():
                    cruelty_impact = round(2 * intensity)
                elif "kind" in description.lower() or "gentle" in description.lower():
                    cruelty_impact = round(-2 * intensity)
            
            # Create memory of the experience
            memory_system = await self.get_memory_system()
            
            memory_text = f"I experienced a formative event: {description}"
            
            memory_result = await memory_system.remember(
                entity_type="npc",
                entity_id=npc_id,
                memory_text=memory_text,
                importance="high",
                emotional=True,
                tags=["formative_experience", experience_type]
            )
            
            # Create belief about what this means
            belief_text = ""
            if dominance_impact > 0:
                belief_text = "I am more powerful than I realized"
            elif dominance_impact < 0:
                belief_text = "I am more vulnerable than I thought"
                
            if cruelty_impact > 0:
                belief_text = belief_text or "I need to be tougher to survive"
            elif cruelty_impact < 0:
                belief_text = belief_text or "Kindness is more important than I realized"
                
            if belief_text:
                await memory_system.create_belief(
                    entity_type="npc",
                    entity_id=npc_id,
                    belief_text=belief_text,
                    confidence=0.7 * intensity,
                    topic="self"
                )
            
            # Apply immediate changes if requested
            changes_applied = {
                "dominance_change": 0,
                "cruelty_change": 0,
                "traits_added": [],
                "traits_removed": []
            }
            
            if immediate_impact:
                # Apply stat changes
                new_dominance = max(0, min(100, current_dominance + dominance_impact))
                new_cruelty = max(0, min(100, current_cruelty + cruelty_impact))
                
                # Determine trait changes
                new_traits = current_traits.copy()
                traits_added = []
                traits_removed = []
                
                # Process trait impacts
                for trait, impact in trait_impacts.items():
                    # Only apply significant impacts
                    if abs(impact) < 2:
                        continue
                        
                    if impact > 0 and trait not in new_traits:
                        new_traits.append(trait)
                        traits_added.append(trait)
                        
                        # Remove opposite trait if it exists
                        opposite = self._get_opposite_trait(trait)
                        if opposite and opposite in new_traits:
                            new_traits.remove(opposite)
                            traits_removed.append(opposite)
                    
                    elif impact < 0 and trait in new_traits:
                        new_traits.remove(trait)
                        traits_removed.append(trait)
                
                # Update NPC in database
                await self._update_npc_personality(
                    npc_id,
                    new_dominance,
                    new_cruelty,
                    new_traits
                )
                
                # Record changes
                changes_applied = {
                    "dominance_change": new_dominance - current_dominance,
                    "cruelty_change": new_cruelty - current_cruelty,
                    "traits_added": traits_added,
                    "traits_removed": traits_removed
                }
            
            # Create impact response
            return {
                "memory_created": True,
                "memory_id": memory_result.get("memory_id"),
                "potential_impact": {
                    "dominance_impact": dominance_impact,
                    "cruelty_impact": cruelty_impact,
                    "trait_impacts": trait_impacts
                },
                "immediate_changes": changes_applied,
                "experience_processed": True
            }
            
        except Exception as e:
            logger.error(f"Error handling formative experience: {e}")
            return {"memory_created": False, "error": str(e)}
    
    async def _analyze_trait_indicators(
        self, 
        memories: List[Dict[str, Any]]
    ) -> Dict[str, float]:
        """Analyze memories for evidence of personality traits."""
        # Initialize trait indicators
        trait_indicators = {
            "anxious": 0,
            "confident": 0,
            "suspicious": 0,
            "trusting": 0,
            "impulsive": 0,
            "calculating": 0,
            "emotional": 0,
            "stoic": 0,
            "social": 0,
            "reserved": 0,
            "aggressive": 0,
            "passive": 0
        }
        
        # Analyze each memory for trait evidence
        for memory in memories:
            text = memory.get("text", "").lower()
            tags = memory.get("tags", [])
            
            # Direct trait mentions
            for trait in trait_indicators.keys():
                if trait in text:
                    trait_indicators[trait] += 1
            
            # Behavioral indicators
            if any(word in text for word in ["worry", "fear", "nervous", "afraid"]):
                trait_indicators["anxious"] += 1
                trait_indicators["confident"] -= 0.5
            
            if any(word in text for word in ["confident", "sure", "certain", "knew"]):
                trait_indicators["confident"] += 1
                trait_indicators["anxious"] -= 0.5
            
            if any(word in text for word in ["doubt", "distrust", "suspect", "wary"]):
                trait_indicators["suspicious"] += 1
                trait_indicators["trusting"] -= 0.5
            
            if any(word in text for word in ["trust", "believe", "faith", "relied"]):
                trait_indicators["trusting"] += 1
                trait_indicators["suspicious"] -= 0.5
            
            if any(word in text for word in ["sudden", "immediate", "without thinking"]):
                trait_indicators["impulsive"] += 1
                trait_indicators["calculating"] -= 0.5
            
            if any(word in text for word in ["plan", "consider", "analyze", "think through"]):
                trait_indicators["calculating"] += 1
                trait_indicators["impulsive"] -= 0.5
            
            if any(word in text for word in ["felt", "emotional", "upset", "cry", "tears"]):
                trait_indicators["emotional"] += 1
                trait_indicators["stoic"] -= 0.5
            
            if any(word in text for word in ["calm", "controlled", "didn't react", "composed"]):
                trait_indicators["stoic"] += 1
                trait_indicators["emotional"] -= 0.5
            
            if any(word in text for word in ["group", "party", "gather", "socialize", "friends"]):
                trait_indicators["social"] += 1
                trait_indicators["reserved"] -= 0.5
            
            if any(word in text for word in ["alone", "quiet", "private", "by myself"]):
                trait_indicators["reserved"] += 1
                trait_indicators["social"] -= 0.5
            
            if any(word in text for word in ["attacked", "confronted", "aggressive", "fought"]):
                trait_indicators["aggressive"] += 1
                trait_indicators["passive"] -= 0.5
            
            if any(word in text for word in ["avoided", "let it go", "didn't confront"]):
                trait_indicators["passive"] += 1
                trait_indicators["aggressive"] -= 0.5
            
            # Tag-based indicators
            for tag in tags:
                if tag == "fear" or tag == "anxiety":
                    trait_indicators["anxious"] += 0.5
                elif tag == "confidence":
                    trait_indicators["confident"] += 0.5
                elif tag == "betrayal":
                    trait_indicators["suspicious"] += 0.5
                elif tag == "trust":
                    trait_indicators["trusting"] += 0.5
                elif tag == "emotional_outburst":
                    trait_indicators["emotional"] += 1
                    trait_indicators["stoic"] -= 0.5
        
        return trait_indicators
    
    def _get_opposite_trait(self, trait: str) -> Optional[str]:
        """Get the opposite of a personality trait."""
        trait_opposites = {
            "anxious": "confident",
            "confident": "anxious",
            "suspicious": "trusting",
            "trusting": "suspicious",
            "impulsive": "calculating",
            "calculating": "impulsive",
            "emotional": "stoic",
            "stoic": "emotional",
            "social": "reserved",
            "reserved": "social",
            "aggressive": "passive",
            "passive": "aggressive"
        }
        
        return trait_opposites.get(trait)
    
    async def _update_npc_personality(
        self, 
        npc_id: int, 
        dominance: int, 
        cruelty: int, 
        traits: List[str]
    ) -> Dict[str, Any]:
        """Update NPC personality in database."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    UPDATE NPCStats
                    SET dominance = %s,
                        cruelty = %s,
                        personality_traits = %s,
                        last_updated = NOW()
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (dominance, cruelty, json.dumps(traits), npc_id, self.user_id, self.conversation_id)
                )
                
                rows_affected = cursor.rowcount
                
                return {
                    "success": rows_affected > 0,
                    "rows_affected": rows_affected
                }
                
        except Exception as e:
            logger.error(f"Error updating NPC personality: {e}")
            return {"success": False, "error": str(e)}
    
    async def _get_npc_data(self, npc_id: int) -> Optional[Dict[str, Any]]:
        """Get NPC data from database."""
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, npc_name, dominance, cruelty, personality_traits
                    FROM NPCStats
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                
                row = cursor.fetchone()
                if not row:
                    return None
                
                # Parse JSON field
                traits_raw = row[4]
                traits = []
                if traits_raw:
                    if isinstance(traits_raw, str):
                        try:
                            traits = json.loads(traits_raw)
                        except json.JSONDecodeError:
                            traits = []
                    elif isinstance(traits_raw, list):
                        traits = traits_raw
                
                return {
                    "npc_id": row[0],
                    "npc_name": row[1],
                    "dominance": row[2],
                    "cruelty": row[3],
                    "personality_traits": traits
                }
                
        except Exception as e:
            logger.error(f"Error getting NPC data: {e}")
            return None

class ConversationGenerationSystem:
    """
    System for generating contextually rich NPC dialogue using GPT calls,
    memory integration, personality influence, and emotional states.
    """

    def __init__(
        self, 
        user_id: int,
        conversation_id: int,
        cache_manager: "CacheManager"  # type: ignore
    ):
        self.user_id = user_id
        self.conversation_id = conversation_id
        self.cache_manager = cache_manager
        self._memory_system = None

    async def get_memory_system(self) -> "MemorySystem":  # type: ignore
        """
        Lazy-load the memory system.
        """
        if self._memory_system is None:
            # You likely have an async initialization or something similar
            self._memory_system = await MemorySystem.get_instance(
                self.user_id, 
                self.conversation_id
            )
        return self._memory_system

    # ---------------------------------------------------------
    # Public API: generate_dialogue
    # ---------------------------------------------------------
    async def generate_dialogue(
        self,
        npc_id: int,
        context: Dict[str, Any],
        dialogue_type: str = "response",
        target: Optional[Dict[str, Any]] = None,
        max_length: int = 150,
        style_params: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Generate dialogue for an NPC, with memory- and personality-informed context.
        Uses GPT for the final text generation instead of manual branching.

        :param npc_id: ID of the NPC
        :param context: Dialogue context (conversation history, location, time_of_day, etc.)
        :param dialogue_type: Type of dialogue to generate ("response", "greeting", etc.)
        :param target: Target of the dialogue (e.g., the player or another NPC)
        :param max_length: Maximum length of the generated dialogue (approx. in characters)
        :param style_params: Optional parameters to control the dialogue style
        :return: A dict containing the generated dialogue, NPC name, emotional state, etc.
        """
        try:
            # ---------------------------
            # 1) Fetch NPC data
            # ---------------------------
            npc_data = await self._get_npc_data(npc_id)
            if not npc_data:
                return {"error": "NPC data not found"}

            npc_name = npc_data.get("npc_name", f"NPC_{npc_id}")

            # ---------------------------
            # 2) Context extraction
            # ---------------------------
            conversation_history = context.get("conversation_history", [])
            location = context.get("location", "unknown")
            time_of_day = context.get("time_of_day", "unknown")

            # ---------------------------
            # 3) Memory system + emotional state
            # ---------------------------
            memory_system = await self.get_memory_system()
            emotional_state = await memory_system.get_npc_emotion(npc_id)
            
            # If user just said something, we might want to reference it in the prompt
            last_user_utterance = conversation_history[-1] if conversation_history else ""

            # ---------------------------
            # 4) Retrieve relevant memories
            # ---------------------------
            # Decide what to query. This is your existing logic:
            memory_query = ""
            if dialogue_type == "response" and conversation_history:
                memory_query = last_user_utterance
            elif target:
                memory_query = target.get("name", "unknown")
            else:
                memory_query = location

            memory_result = await memory_system.recall(
                entity_type="npc",
                entity_id=npc_id,
                query=memory_query,
                limit=3
            )
            relevant_memories = memory_result.get("memories", [])

            # ---------------------------
            # 5) Relationship with target
            # ---------------------------
            relationship = None
            if target:
                relationship = await self._get_relationship(
                    npc_id, 
                    target.get("type", "player"), 
                    target.get("id")
                )

            # ---------------------------
            # 6) Style parameters
            # ---------------------------
            base_style = {
                "formality": "neutral",
                "verbosity": "moderate",
                "emotionality": "standard"
            }
            if style_params:
                base_style.update(style_params)

            # ---------------------------
            # 7) Generate text via GPT
            # ---------------------------
            dialogue_text = await self._generate_dialogue_gpt(
                npc_data=npc_data,
                conversation_history=conversation_history,
                relevant_memories=relevant_memories,
                emotional_state=emotional_state,
                relationship=relationship,
                dialogue_type=dialogue_type,
                style=base_style,
                location=location,
                time_of_day=time_of_day,
                max_length=max_length,
                last_user_utterance=last_user_utterance
            )

            # ---------------------------
            # 8) Create new memory entry
            # ---------------------------
            if dialogue_type == "response" and target:
                memory_text = f"I talked to {target.get('name', 'someone')} about {memory_query}"
                await memory_system.remember(
                    entity_type="npc",
                    entity_id=npc_id,
                    memory_text=memory_text,
                    importance="low",
                    tags=["conversation", "dialogue"]
                )

            # ---------------------------
            # 9) Return final result
            # ---------------------------
            final_emotion = "neutral"
            intensity = 0.0
            if emotional_state and "current_emotion" in emotional_state:
                primary = emotional_state["current_emotion"].get("primary", {})
                final_emotion = primary.get("name", "neutral")
                intensity = primary.get("intensity", 0.0)

            return {
                "npc_name": npc_name,
                "dialogue": dialogue_text,
                "dialogue_type": dialogue_type,
                "emotional_state": {
                    "emotion": final_emotion,
                    "intensity": intensity
                },
                "style_used": base_style,
                "memory_influenced": len(relevant_memories) > 0,
                "memories_used": relevant_memories[:1] if relevant_memories else []
            }

        except Exception as e:
            logger.error(f"Error generating dialogue: {e}", exc_info=True)
            return {"error": str(e)}

    # ---------------------------------------------------------
    # Main GPT call method
    # ---------------------------------------------------------
    async def _generate_dialogue_gpt(
        self,
        npc_data: Dict[str, Any],
        conversation_history: List[str],
        relevant_memories: List[Dict[str, Any]],
        emotional_state: Dict[str, Any],
        relationship: Optional[Dict[str, Any]],
        dialogue_type: str,
        style: Dict[str, Any],
        location: str,
        time_of_day: str,
        max_length: int,
        last_user_utterance: str
    ) -> str:
        """
        Actually call GPT to get a piece of dialogue matching the NPC's personality,
        emotional state, memory context, etc.

        :return: The GPT-generated text response.
        """
        npc_name = npc_data.get("npc_name", "Unknown")
        traits = npc_data.get("personality_traits", [])
        dominance = npc_data.get("dominance", 50)
        cruelty = npc_data.get("cruelty", 50)

        # Determine final emotion & intensity
        emotion = "neutral"
        intensity = 0.0
        if emotional_state and "current_emotion" in emotional_state:
            primary = emotional_state["current_emotion"].get("primary", {})
            emotion = primary.get("name", "neutral")
            intensity = primary.get("intensity", 0.0)

        # Relationship data
        relationship_level = 50
        relationship_type = "neutral"
        if relationship:
            relationship_level = relationship.get("link_level", 50)
            relationship_type = relationship.get("link_type", "neutral")

        # Construct system message: “instruct” the model how to behave
        system_prompt = (
            "You are a helpful but contextually accurate NPC in a narrative game. "
            "Generate a short piece of dialogue that reflects the NPC's personality traits, "
            "emotional state, relationship context, and the conversation so far. "
            "Do not quote memory text verbatim; instead, refer to it naturally."
        )

        # Summarize or list memory in a short textual form
        memory_summaries = []
        for mem in relevant_memories:
            text = mem.get("text", "")
            # (Optionally shorten or sanitize text here)
            memory_summaries.append(text[:80] + "..." if len(text) > 80 else text)

        # Build the user message with all relevant info
        user_content = (
            f"NPC Name: {npc_name}\n"
            f"Personality Traits: {traits}\n"
            f"Dominance: {dominance}, Cruelty: {cruelty}\n"
            f"Current Emotion: {emotion}, Intensity: {intensity}\n"
            f"Relationship Type: {relationship_type}, Level: {relationship_level}\n"
            f"Location: {location}, Time of Day: {time_of_day}\n"
            f"Dialogue Type: {dialogue_type}\n"
            f"Style: {style}\n\n"
            f"Conversation History: {conversation_history}\n\n"
            f"Relevant Memories (summaries): {memory_summaries}\n\n"
            f"Last User Utterance: {last_user_utterance}\n\n"
            f"Please provide a single response (under ~{max_length} chars) that fits all this."
        )

        # We’ll use ChatCompletion for better conversational context
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_content}
        ]

        try:
            # Call OpenAI’s ChatCompletion
            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",      # Or a model suitable for your needs
                messages=messages,
                temperature=0.8,
                max_tokens=150,            # Enough headroom to produce ~100-120 chars of text
                n=1
            )
            generated_text = response["choices"][0]["message"]["content"].strip()
        except Exception as e:
            logger.error(f"OpenAI API error: {e}", exc_info=True)
            generated_text = "I... have nothing to say right now."

        # (Optionally) Trim to max_length to be safe
        if len(generated_text) > max_length:
            generated_text = generated_text[: max_length - 3] + "..."

        return generated_text

    # ---------------------------------------------------------
    # Additional supportive endpoints (unchanged or simplified)
    # ---------------------------------------------------------
    async def _get_npc_data(self, npc_id: int) -> Optional[Dict[str, Any]]:
        """
        Fetch NPC data from the DB, such as name, dominance, cruelty, personality traits, etc.
        """
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT npc_id, npc_name, dominance, cruelty, personality_traits
                    FROM NPCStats
                    WHERE npc_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, self.user_id, self.conversation_id)
                )
                row = cursor.fetchone()
                if not row:
                    return None

                traits_raw = row[4]
                if isinstance(traits_raw, str):
                    try:
                        traits = json.loads(traits_raw)
                    except json.JSONDecodeError:
                        traits = []
                elif isinstance(traits_raw, list):
                    traits = traits_raw
                else:
                    traits = []

                return {
                    "npc_id": row[0],
                    "npc_name": row[1],
                    "dominance": row[2],
                    "cruelty": row[3],
                    "personality_traits": traits
                }
        except Exception as e:
            logger.error(f"Error getting NPC data: {e}", exc_info=True)
            return None

    async def _get_relationship(
        self,
        npc_id: int,
        entity_type: str,
        entity_id: Any
    ) -> Optional[Dict[str, Any]]:
        """
        Fetch the relationship data from your DB. Return link_type, link_level, etc.
        """
        try:
            with get_db_connection() as conn, conn.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT link_id, link_type, link_level, last_interaction
                    FROM SocialLinks
                    WHERE entity1_type = 'npc'
                      AND entity1_id = %s
                      AND entity2_type = %s
                      AND entity2_id = %s
                      AND user_id = %s
                      AND conversation_id = %s
                    """,
                    (npc_id, entity_type, entity_id, self.user_id, self.conversation_id)
                )
                row = cursor.fetchone()
                if row:
                    link_id, link_type, link_level, last_interaction = row
                    return {
                        "link_id": link_id,
                        "link_type": link_type,
                        "link_level": link_level,
                        "last_interaction": last_interaction.isoformat() if last_interaction else None
                    }
            return None
        except Exception as e:
            logger.error(f"Error getting relationship: {e}", exc_info=True)
            return None

    async def initialize_maintenance_schedule(self) -> None:
        """Set up scheduled maintenance for the agent system."""
        async def run_maintenance_cycle():
            """Background task for scheduled maintenance."""
            while True:
                try:
                    # Sleep for the maintenance interval
                    await asyncio.sleep(NPCConfig.MAINTENANCE['cycle_minutes'] * 60)
                    
                    # Log maintenance start
                    logger.info("Starting scheduled maintenance cycle")
                    
                    # Run system maintenance
                    results = await self.run_system_maintenance()
                    
                    # Log completion
                    logger.info(f"Completed maintenance: {len(results['npcs'])} NPCs processed")
                    
                    # Update maintenance timestamp
                    self._last_maintenance = datetime.now()
                    
                except Exception as e:
                    logger.error(f"Error in scheduled maintenance: {e}")
                    # Wait a bit before retrying on error
                    await asyncio.sleep(300)  # 5 minutes
        
        # Start the maintenance task
        asyncio.create_task(run_maintenance_cycle())

    async def run_comprehensive_memory_maintenance(self, npc_id: int) -> Dict[str, Any]:
        """Run comprehensive memory maintenance for an NPC."""
        results = {}
        
        try:
            memory_system = await self.get_memory_system()
            
            # Basic memory maintenance (decay, pruning)
            basic_result = await memory_system.maintain(
                entity_type="npc",
                entity_id=npc_id
            )
            results["basic_maintenance"] = basic_result
            
            # Schema detection and application
            schema_result = await memory_system.generate_schemas(
                entity_type="npc",
                entity_id=npc_id
            )
            results["schema_generation"] = schema_result
            
            # Belief updates and consolidation
            beliefs = await memory_system.get_beliefs(
                entity_type="npc",
                entity_id=npc_id
            )
            
            belief_updates = 0
            for belief in beliefs:
                belief_id = belief.get("id")
                if belief_id and random.random() < 0.3:
                    confidence_change = random.uniform(-0.05, 0.05)
                    new_confidence = max(0.1, min(0.95, belief.get("confidence", 0.5) + confidence_change))
                    
                    await memory_system.update_belief_confidence(
                        entity_type="npc",
                        entity_id=npc_id,
                        belief_id=belief_id,
                        new_confidence=new_confidence,
                        reason="Regular belief reassessment"
                    )
                    belief_updates += 1
                    
            results["belief_updates"] = belief_updates
            
            # Emotional state decay
            emotional_state = await memory_system.get_npc_emotion(npc_id)
            if emotional_state and "current_emotion" in emotional_state:
                current = emotional_state["current_emotion"]
                emotion_name = current.get("primary", "neutral")
                intensity = current.get("intensity", 0.0)
                
                if emotion_name != "neutral" and intensity > 0.3:
                    decay_amount = NPCConfig.MAINTENANCE['emotion_decay_amount']
                    new_intensity = max(0.1, intensity - decay_amount)
                    
                    if new_intensity < 0.25:
                        emotion_name = "neutral"
                        new_intensity = 0.1
                    
                    await memory_system.update_npc_emotion(
                        npc_id=npc_id,
                        emotion=emotion_name,
                        intensity=new_intensity
                    )
                    
                    results["emotional_decay"] = {
                        "old_intensity": intensity,
                        "new_intensity": new_intensity,
                        "decayed": True
                    }
            
            return results
            
        except Exception as e:
            logger.error(f"Error in memory maintenance for NPC {npc_id}: {e}")
            return {"error": str(e)}
